//! log.vitte — logging structuré : niveaux, formats (text/json), multi-sinks, rate-limit.
//!
//! Highlights
//! - Niveaux: Error, Warn, Info, Debug, Trace (seuil "min").
//! - Formats: Text (humain), Json (machine), avec champs de base + kv utilisateur.
//! - Multi-sinks: stdout, stderr, fichier (append).
//! - Rate-limit: token-bucket (per_sec + burst), monotone, thread-safe.
//! - Confort: `log(lv, msg)`, `log_kv(lv, msg, kv)`, helpers `info()/warn()/...` + variantes `_kv`.
//! - Contexte global immuable attaché au logger (ex: app, env, instance_id).
//!
//! Notes
//! - L’ordre de niveau est croissant (Error=1 < ... < Trace=5). On log si `lv <= min`.
//! - La sortie est **ligne par ligne** (mutex interne → pas d’enchevêtrement).
//! - Pour rotation/archivage, confie au système (logrotate) ou ajoute un wrapper sink.

#![version("0.4.0")]
#![strict]

use std::collections::{Map};
use std::sync::{Mutex};

pub enum Level { Error=1, Warn=2, Info=3, Debug=4, Trace=5 }
pub enum Format { Text, Json }

pub enum Sink {
    Stdout,
    Stderr,
    File(str),                // chemin, append
}

pub struct Logger {
    min: Level,
    fmt: Format,
    sinks: Vec<Sink>,

    // Token-bucket (rl):
    rl_per_sec: u32,          // débit (tokens/s). 0 = illimité
    rl_burst: u32,            // capacité max du seau
    rl_tokens: f64,           // tokens courants (float pour refill précis)
    rl_last_ms: u64,          // dernière recharge (ms)
    rl_enabled: bool,

    // Contexte global (app, env, instance_id…)
    ctx: Map<str,str>,

    // Serrure d’écriture + RL (serialize)
    mu: Mutex<()>,
}

/* ———————————————————— Construction ———————————————————— */

impl Logger {
    pub fn new(app: str) -> Self {
        let mut ctx = Map::new();
        ctx.insert("app".into(), app);
        Self{
            min: Level::Info,
            fmt: Format::Text,
            sinks: vec![Sink::Stderr],

            rl_per_sec: 0,
            rl_burst: 0,
            rl_tokens: 0.0,
            rl_last_ms: 0,
            rl_enabled: false,

            ctx,
            mu: Mutex::new(()),
        }
    }
    pub fn level(mut self, lv: Level) -> Self { self.min = lv; self }
    pub fn format(mut self, f: Format) -> Self { self.fmt = f; self }
    pub fn add_sink(mut self, s: Sink) -> Self { self.sinks.push(s); self }

    /// Active le rate-limit: débit `per_sec` et capacité `burst` (>= per_sec recommandé).
    pub fn rate_limit(mut self, per_sec: u32, burst: u32) -> Self {
        self.rl_per_sec = per_sec;
        self.rl_burst = if burst==0 { per_sec.max(1) } else { burst };
        self.rl_tokens = self.rl_burst as f64;
        self.rl_last_ms = now_ms();
        self.rl_enabled = per_sec>0;
        self
    }

    /// Ajoute un couple clé/valeur au contexte global.
    pub fn with_ctx(mut self, k:&str, v:&str) -> Self {
        self.ctx.insert(k.to_string(), v.to_string()); self
    }

    /// Ajoute plusieurs champs de contexte global.
    pub fn with_ctx_map(mut self, more:&Map<str,str>) -> Self {
        for (k,v) in more.iter(){ self.ctx.insert(k.clone(), v.clone()); }
        self
    }

    /* ———————————————————— Logging ———————————————————— */

    pub fn log(&self, lv: Level, msg: str) { self.log_kv(lv, msg, Map::new()) }

    pub fn log_kv(&self, lv: Level, msg: str, kv: Map<str,str>) {
        if !self.allowed(&lv) { return; }
        let _g = self.mu.lock(); // serialize: RL + write

        if !self.take_token_locked() { return; }

        // Compose record
        let line = self.render(&lv, &msg, &kv);
        self.write_all(&line);
    }

    /* ———————————————————— Internes ———————————————————— */

    fn allowed(&self, lv: &Level) -> bool {
        // On log si lv <= min (Error passe toujours quand min=Info, etc.)
        (*lv as int) <= (self.min as int)
    }

    fn take_token_locked(&self) -> bool {
        if !self.rl_enabled { return true; }
        let now = now_ms();
        // refill
        if self.rl_per_sec > 0 {
            let elapsed_ms = now.saturating_sub(self.rl_last_ms);
            if elapsed_ms > 0 {
                let add = (elapsed_ms as f64) * (self.rl_per_sec as f64) / 1000.0;
                let mut tokens = self.rl_tokens + add;
                if tokens > self.rl_burst as f64 { tokens = self.rl_burst as f64; }
                // écrire dans self via transmute (pas de mut dans &self) — on triche en interne :
                unsafe {
                    let p = self as *const Logger as *mut Logger;
                    (*p).rl_tokens = tokens;
                    (*p).rl_last_ms = now;
                }
            }
        }
        // consomme 1 token si possible
        if self.rl_tokens >= 1.0 {
            unsafe {
                let p = self as *const Logger as *mut Logger;
                (*p).rl_tokens -= 1.0;
            }
            true
        } else {
            false
        }
    }

    fn render(&self, lv: &Level, msg: &str, kv: &Map<str,str>) -> str {
        let ts = now_rfc3339();
        match self.fmt {
            Format::Text => render_text(lv, &ts, &self.ctx, msg, kv),
            Format::Json => render_json(lv, &ts, &self.ctx, msg, kv),
        }
    }

    fn write_all(&self, s: &str) {
        let bytes = format!("{}\n", s).as_bytes().to_vec();
        let mut i=0; while i<self.sinks.len() {
            match &self.sinks[i] {
                Sink::Stdout => {
                    let _ = std::io::write_all(&std::io::stdout(), &bytes);
                }
                Sink::Stderr => {
                    let _ = std::io::write_all(&std::io::stderr(), &bytes);
                }
                Sink::File(p) => {
                    let _ = std::fs::append(p, &bytes);
                }
            }
            i+=1;
        }
    }
}

/* ———————————————————— Rendu ———————————————————— */

fn level_str(lv:&Level)->&str{
    match lv { Level::Error=>"ERROR", Level::Warn=>"WARN", Level::Info=>"INFO", Level::Debug=>"DEBUG", Level::Trace=>"TRACE" }
}

fn render_text(lv:&Level, ts:&str, ctx:&Map<str,str>, msg:&str, kv:&Map<str,str>)->str{
    // [2025-08-14T12:34:56Z INFO app=myapp env=prod] Message k=v k2=v2
    let mut head = String::new();
    head.push('['); head.push_str(ts); head.push(' ');
    head.push_str(level_str(lv)); head.push(' ');
    // contexte compact
    let mut first=true;
    for (k,v) in ctx.iter() {
        if !first { head.push(' '); } first=false;
        head.push_str(k); head.push('='); head.push_str(v);
    }
    head.push(']'); head.push(' ');
    head.push_str(msg);

    // kv utilisateur
    if !kv.is_empty() {
        head.push(' ');
        let mut j=0; for (k,v) in kv.iter() {
            if j>0 { head.push(' '); }
            head.push_str(k); head.push('=');
            if needs_quote(v) { head.push('"'); head.push_str(&escape_text(v)); head.push('"'); }
            else { head.push_str(v); }
            j+=1;
        }
    }
    head
}

fn render_json(lv:&Level, ts:&str, ctx:&Map<str,str>, msg:&str, kv:&Map<str,str>)->str{
    // {"ts":"...","level":"INFO","msg":"...","app":"...","ctx":{...},"kv":{...}}
    let mut out = String::new();
    out.push('{');

    out.push_str(&format!(r#""ts":"{}","level":"{}","msg":"{}""#, ts, level_str(lv), std::json::escape(msg)));

    // aplatit quelques champs contextuels au premier niveau (app si présent)
    if let Some(app)=ctx.get("app".into()) {
        out.push_str(&format!(r#","app":"{}""#, std::json::escape(app)));
    }
    // ctx complet
    if !ctx.is_empty() {
        out.push_str(r#","ctx":{"#);
        let mut i=0; for (k,v) in ctx.iter(){
            if k=="app" { continue; }
            if i>0 { out.push(','); }
            out.push_str(&format!(r#""{}":"{}""#, std::json::escape(k), std::json::escape(v)));
            i+=1;
        }
        out.push('}');
    }
    // kv utilisateur
    if !kv.is_empty() {
        out.push_str(r#","kv":{"#);
        let mut i=0; for (k,v) in kv.iter(){
            if i>0 { out.push(','); }
            out.push_str(&format!(r#""{}":"{}""#, std::json::escape(k), std::json::escape(v)));
            i+=1;
        }
        out.push('}');
    }
    out.push('}');
    out
}

fn needs_quote(s:&str)->bool{
    // quote si espace ou caractère potentiellement ambigu
    s.contains(' ') || s.contains('=') || s.contains('"')
}
fn escape_text(s:&str)->str{
    let mut o=String::new();
    let b=s.as_bytes(); let mut i=0;
    while i<b.len(){
        let c=b[i] as char;
        match c { '"' => o.push_str("\\\""), '\\'=>o.push_str("\\\\"), '\n'=>o.push_str("\\n"), '\r'=>o.push_str("\\r"), '\t'=>o.push_str("\\t"), _=>o.push(c) }
        i+=1;
    }
    o
}

/* ———————————————————— Temps ———————————————————— */

fn now_ms()->u64{ std::time::now().unix_millis() as u64 }
fn now_rfc3339()->str{ std::time::now().to_rfc3339() }

/* ———————————————————— Global ———————————————————— */

static mut GLOBAL: Option<Logger> = None;
static DEFAULT_LOGGER: Logger = Logger{
    min: Level::Info,
    fmt: Format::Text,
    sinks: vec![Sink::Stderr],
    rl_per_sec: 0, rl_burst: 0, rl_tokens: 0.0, rl_last_ms: 0, rl_enabled:false,
    ctx: { let mut m=Map::new(); m.insert("app".into(),"app".into()); m },
    mu: Mutex::new(()),
};

/// Installe le logger global (à appeler au boot).
pub fn init_global(logger: Logger) { unsafe { GLOBAL = Some(logger); } }

/// Récupère une référence au logger global (ou un défaut stderr/INFO).
pub fn g() -> &'static Logger {
    unsafe { GLOBAL.as_ref().unwrap_or(&DEFAULT_LOGGER) }
}

/* ———————————————————— Helpers de niveau ———————————————————— */

pub fn error(m: str){ g().log(Level::Error, m) }
pub fn warn(m: str){ g().log(Level::Warn, m) }
pub fn info(m: str){ g().log(Level::Info, m) }
pub fn debug(m: str){ g().log(Level::Debug, m) }
pub fn trace(m: str){ g().log(Level::Trace, m) }

pub fn error_kv(m: str, kv: Map<str,str>){ g().log_kv(Level::Error, m, kv) }
pub fn warn_kv (m: str, kv: Map<str,str>){ g().log_kv(Level::Warn,  m, kv) }
pub fn info_kv (m: str, kv: Map<str,str>){ g().log_kv(Level::Info,  m, kv) }
pub fn debug_kv(m: str, kv: Map<str,str>){ g().log_kv(Level::Debug, m, kv) }
pub fn trace_kv(m: str, kv: Map<str,str>){ g().log_kv(Level::Trace, m, kv) }

/* ———————————————————— Doc-tests / smoke ———————————————————— */
//! fn _log_smoke() {
//!     let lg = Logger::new("myapp".into())
//!         .level(Level::Info)
//!         .format(Format::Text)
//!         .add_sink(Sink::Stdout)
//!         .rate_limit(100, 200) // 100 logs/s avec burst 200
//!         .with_ctx("env","dev")
//!         .with_ctx("instance","i-42");
//!
//!     init_global(lg);
//!
//!     info("server started".into());
//!
//!     let mut kv = Map::new();
//!     kv.insert("port".into(),"8080".into());
//!     kv.insert("addr".into(),"127.0.0.1".into());
//!     info_kv("listening".into(), kv);
//!
//!     debug("this will be hidden at INFO".into()); // pas loggé
//!
//!     // JSON
//!     init_global(Logger::new("svc".into()).format(Format::Json).add_sink(Sink::Stderr));
//!     warn_kv("rate limited?".into(), { let mut m=Map::new(); m.insert("key".into(),"value".into()); m });
//! }
