//! graph.vitte — graphe orienté; topo_sort + détection de cycles (+ SCC, closure, réduction).
//!
//! Highlights :
//! - add_node / add_edge / remove_* / has_* / nodes / edges
//! - topo_sort() (Kahn, stable) → Err("cycle: a -> … -> a")
//! - find_cycle() (DFS couleurs) → Option<Vec<str>> témoin
//! - scc() (Tarjan) → composantes fortement connexes
//! - layers_topo() → couches topologiques
//! - transitive_closure() / reduce_transitive_dag()
//! - longest_path_dag() → chemin le plus long (en arêtes)
//! - to_dot() / from_pairs()
//!
//! NB: auto-crée les nœuds lors des add_edge() pour éviter les surprises.

#![version("0.3.0")]
#![strict]

use std::collections::{Map, Set, VecDeque};

pub struct Graph {
    pub g: Map<str, Set<str>>, // a -> {b,c}
}

impl Graph {
    /* —————————————— Base —————————————— */

    pub fn new()->Self{ Self{ g: Map::new() } }

    pub fn add_node(&mut self, n:str) -> bool {
        if self.g.contains_key(&n) { return false; }
        self.g.insert(n, Set::new()); true
    }

    /// Ajoute l'arête a->b; crée les nœuds si absents. Retourne true si nouvelle.
    pub fn add_edge(&mut self, a:str, b:str)->bool{
        if !self.g.contains_key(&a){ self.g.insert(a.clone(), Set::new()); }
        if !self.g.contains_key(&b){ self.g.insert(b.clone(), Set::new()); }
        let s = self.g.get_mut(&a).unwrap();
        if s.contains(&b){ return false; }
        s.insert(b); true
    }

    pub fn remove_edge(&mut self, a:&str, b:&str)->bool{
        if let Some(s)=self.g.get_mut(a){ s.remove(b) } else { false }
    }

    pub fn remove_node(&mut self, n:&str)->bool{
        let existed = self.g.remove(n).is_some();
        if existed {
            for (_, outs) in self.g.iter_mut(){ outs.remove(n); }
        }
        existed
    }

    pub fn has_node(&self, n:&str)->bool{ self.g.contains_key(n.to_string()) }
    pub fn has_edge(&self, a:&str, b:&str)->bool{ self.g.get(a.to_string()).map(|s| s.contains(b.to_string())).unwrap_or(false) }

    pub fn nodes(&self)->Vec<str>{
        let mut v:Vec<str> = self.g.keys().cloned().collect();
        v.sort(); v
    }

    pub fn edges(&self)->Vec<(str,str)>{
        let mut out=Vec::<(str,str)>::new();
        for (a, outs) in self.g.iter(){ for b in outs.iter(){ out.push((a.clone(), b.clone())); } }
        out.sort_by(|x,y| if x.0==y.0 { x.1.cmp(&y.1) } else { x.0.cmp(&y.0) });
        out
    }

    pub fn successors(&self, n:&str)->Vec<str>{
        self.g.get(n.to_string()).map(|s| {
            let mut v:Vec<str> = s.iter().cloned().collect(); v.sort(); v
        }).unwrap_or(Vec::new())
    }

    pub fn predecessors(&self, n:&str)->Vec<str>{
        let mut v=Vec::<str>::new();
        for (a, outs) in self.g.iter(){ if outs.contains(n.to_string()){ v.push(a.clone()); } }
        v.sort(); v
    }

    pub fn indegree(&self, n:&str)->usize{ self.predecessors(n).len() }
    pub fn outdegree(&self, n:&str)->usize{ self.g.get(n.to_string()).map(|s| s.len()).unwrap_or(0) }

    /* —————————————— Topo sort (Kahn stable) + cycle —————————————— */

    /// Topological sort stable. Err avec un témoin de cycle lisible.
    pub fn topo_sort(&self) -> Result<Vec<str>,str>{
        // indeg
        let mut indeg = Map::<str,usize>::new();
        for (n, outs) in self.g.iter(){
            indeg.entry(n.clone()).or_insert(0);
            for o in outs.iter(){ *indeg.entry(o.clone()).or_insert(0) += 1; }
        }
        // file des 0, triée (stabilité/déterminisme)
        let mut zeros:Vec<str> = indeg.iter().filter(|(_,d)| **d==0).map(|(k,_)| k.clone()).collect();
        zeros.sort();
        let mut q:VecDeque<str> = VecDeque::from(zeros);

        let mut order=Vec::<str>::new();
        let mut left = indeg.len();

        while let Some(n)=q.pop_front() {
            order.push(n.clone()); left-=1;
            let outs = self.g.get(&n).cloned().unwrap_or(Set::new());
            for o in outs.iter(){
                let d = indeg.get_mut(o).unwrap(); *d-=1;
                if *d==0 {
                    // insérer en gardant l'ordre lexicographique
                    insert_sorted(&mut q, o.clone());
                }
            }
        }

        if left==0 { Ok(order) }
        else {
            if let Some(c)=self.find_cycle() {
                Err(format!("cycle: {}", join_cycle(&c)))
            } else {
                Err("cycle détecté".into())
            }
        }
    }

    /// Détection de cycle par DFS (couleurs). Renvoie un chemin fermé a -> … -> a.
    pub fn find_cycle(&self) -> Option<Vec<str>> {
        // 0=white,1=gray,2=black
        let mut color = Map::<str,u8>::new();
        let mut parent = Map::<str,str>::new();
        let nodes = self.nodes();
        let mut i=0;
        while i<nodes.len() {
            let s = &nodes[i];
            if *color.get(s).unwrap_or(&0)==0 {
                if let Some(cyc) = self.dfs_cycle_from(s, &mut color, &mut parent) { return Some(cyc); }
            }
            i+=1;
        }
        None
    }

    fn dfs_cycle_from(&self, start:&str, color:&mut Map<str,u8>, parent:&mut Map<str,str>) -> Option<Vec<str>> {
        let mut stack = Vec::<(str, usize)>::new();
        stack.push((start.to_string(), 0));
        color.insert(start.to_string(), 1);

        while let Some((u, mut idx)) = stack.pop() {
            let outs = self.successors(&u);
            if idx < outs.len() {
                let v = outs[idx].clone();
                // remettre u avec idx+1
                stack.push((u.clone(), idx+1));

                let col = *color.get(&v).unwrap_or(&0);
                if col==0 {
                    parent.insert(v.clone(), u.clone());
                    color.insert(v.clone(), 1);
                    stack.push((v, 0));
                } else if col==1 {
                    // back-edge u -> v : reconstruire cycle
                    return Some(reconstruct_cycle(&parent, &u, &v));
                }
            } else {
                color.insert(u, 2);
            }
        }
        None
    }

    /* —————————————— SCC (Tarjan) —————————————— */

    /// Tarjan : renvoie les composantes fortement connexes (chaque composante = Vec<str>)
    pub fn scc(&self) -> Vec<Vec<str>> {
        let mut idx=0i32;
        let mut index = Map::<str,i32>::new();
        let mut low   = Map::<str,i32>::new();
        let mut onstk = Map::<str,bool>::new();
        let mut stk   = Vec::<str>::new();
        let mut out   = Vec::<Vec<str>>::new();

        let nodes = self.nodes();
        let mut i=0; while i<nodes.len() {
            let v = &nodes[i];
            if !index.contains_key(v.to_string()) {
                tarjan(self, v, &mut idx, &mut index, &mut low, &mut onstk, &mut stk, &mut out);
            }
            i+=1;
        }
        out
    }

    /* —————————————— Couches topo, fermeture & réduction —————————————— */

    /// Couches topologiques (Kahn) — Err si cycle.
    pub fn layers_topo(&self)->Result<Vec<Vec<str>>,str>{
        // indeg
        let mut indeg = Map::<str,usize>::new();
        for (n, outs) in self.g.iter(){
            indeg.entry(n.clone()).or_insert(0);
            for o in outs.iter(){ *indeg.entry(o.clone()).or_insert(0) += 1; }
        }
        let mut layer = Vec::<Vec<str>>::new();
        let mut zeros:Vec<str> = indeg.iter().filter(|(_,d)| **d==0).map(|(k,_)| k.clone()).collect();
        zeros.sort();

        let mut current=zeros;
        let mut visited=0usize;

        while !current.is_empty() {
            layer.push(current.clone());
            visited += current.len();
            // décrémenter pour chaque arête sortante
            let mut next = Set::<str>::new();
            let mut i=0; while i<current.len() {
                let n = &current[i];
                let outs = self.g.get(n.to_string()).cloned().unwrap_or(Set::new());
                for o in outs.iter(){
                    let d = indeg.get_mut(o).unwrap(); *d-=1;
                    if *d==0 { next.insert(o.clone()); }
                }
                i+=1;
            }
            // trier pour stabilité
            current = next.into_iter().collect();
            current.sort();
        }

        if visited==indeg.len() { Ok(layer) } else { Err("cycle détecté".into()) }
    }

    /// Fermeture transitive : pour chaque u, l'ensemble des v atteignables (u→*v).
    pub fn transitive_closure(&self)->Map<str,Set<str>>{
        let mut cl = Map::<str,Set<str>>::new();
        for u in self.nodes().into_iter() {
            let mut seen = Set::<str>::new();
            let mut st = VecDeque::<str>::new();
            st.push_back(u.clone());
            while let Some(x)=st.pop_front() {
                let outs = self.g.get(&x).cloned().unwrap_or(Set::new());
                for v in outs.iter() {
                    if !seen.contains(v.clone()) {
                        seen.insert(v.clone());
                        st.push_back(v.clone());
                    }
                }
            }
            seen.remove(&u); // optionnel
            cl.insert(u, seen);
        }
        cl
    }

    /// Réduction transitive (DAG requis) : supprime les arêtes u→v si u→*w→*v existe.
    /// Retourne le nombre d'arêtes supprimées.
    pub fn reduce_transitive_dag(&mut self)->Result<usize,str>{
        let _ = self.topo_sort()?; // vérifie DAG
        let reach = self.transitive_closure();
        let mut removed=0usize;
        // Pour chaque u→v, si ∃ w≠v tel que v ∈ reach[w] et w ∈ reach[u], alors u→v est redondant.
        let edges = self.edges();
        let mut i=0;
        while i<edges.len() {
            let (u,v) = (&edges[i].0, &edges[i].1);
            let mut redundant=false;
            if let Some(r_u)=reach.get(u.to_string()) {
                for w in r_u.iter() {
                    if w!=v {
                        if let Some(r_w)=reach.get(w.to_string()) {
                            if r_w.contains(v.to_string()) { redundant=true; break; }
                        }
                    }
                }
            }
            if redundant {
                if self.remove_edge(u,v) { removed+=1; }
            }
            i+=1;
        }
        Ok(removed)
    }

    /* —————————————— Chemin le plus long (DAG) —————————————— */

    /// Plus longue chaîne (en nombre d'arêtes) dans un DAG. Err si cycle.
    pub fn longest_path_dag(&self)->Result<Vec<str>,str>{
        let order = self.topo_sort()?;
        let mut dist = Map::<str,i32>::new();     // -inf par défaut
        let mut prev = Map::<str,str>::new();
        for n in order.iter(){ dist.insert(n.clone(), i32::MIN/4); }
        // sources: indegree 0
        let mut indeg=Map::<str,usize>::new();
        for (n, outs) in self.g.iter(){ indeg.entry(n.clone()).or_insert(0); for o in outs.iter(){ *indeg.entry(o.clone()).or_insert(0)+=1; } }
        for (n,d) in indeg.iter(){ if *d==0 { dist.insert(n.clone(), 0); } }

        // relax dans l'ordre topo
        let mut i=0; while i<order.len(){
            let u=&order[i];
            let du=*dist.get(u).unwrap();
            if du>i32::MIN/4 {
                let outs=self.g.get(u.to_string()).cloned().unwrap_or(Set::new());
                for v in outs.iter(){
                    let nv = du+1;
                    if nv>*dist.get(v).unwrap() {
                        dist.insert(v.clone(), nv);
                        prev.insert(v.clone(), u.clone());
                    }
                }
            }
            i+=1;
        }
        // pick meilleur
        let mut best_n = None; let mut best_d = i32::MIN/4;
        for (n,d) in dist.iter(){ if *d>best_d { best_d=*d; best_n=Some(n.clone()); } }
        if best_n.is_none(){ return Ok(Vec::new()); }
        // remonter le chemin
        let mut path=Vec::<str>::new();
        let mut cur=best_n.unwrap();
        path.push(cur.clone());
        while let Some(p)=prev.get(&cur) {
            cur=p.clone(); path.push(cur.clone());
        }
        path.reverse();
        Ok(path)
    }

    /* —————————————— I/O conviviaux —————————————— */

    /// Export Graphviz/DOT (orienté). `title` optionnel.
    pub fn to_dot(&self, title: Option<&str>)->str{
        let mut s=String::new();
        s.push_str("digraph G {");
        if let Some(t)=title { s.push_str(&format!("\n  label=\"{}\";", t)); s.push_str("\n  labelloc=top;"); }
        s.push('\n');
        for n in self.nodes().into_iter(){ s.push_str(&format!("  \"{}\";\n", n)); }
        for (a,b) in self.edges().into_iter(){ s.push_str(&format!("  \"{}\" -> \"{}\";\n", a, b)); }
        s.push_str("}\n"); s
    }

    /// Construit depuis des paires (a,b). Pratique pour tests/fixtures.
    pub fn from_pairs(pairs: Vec<(str,str)>)->Self{
        let mut g=Graph::new();
        let mut i=0; while i<pairs.len(){ let (a,b)=(&pairs[i].0,&pairs[i].1); g.add_edge(a.clone(), b.clone()); i+=1; }
        g
    }
}

/* —————————————— Internes —————————————— */

fn insert_sorted(q:&mut VecDeque<str>, x:str){
    // Insert trié (lexicographique). O(n) mais n <= |V0|
    let mut v:Vec<str> = q.iter().cloned().collect();
    v.push(x); v.sort();
    q.clear();
    let mut i=0; while i<v.len(){ q.push_back(v[i].clone()); i+=1; }
}

fn reconstruct_cycle(parent:&Map<str,str>, u:&str, v:&str)->Vec<str>{
    // back-edge u -> v ; remonter depuis u jusqu'à v
    let mut path=Vec::<str>::new();
    path.push(v.to_string());
    let mut cur = u.to_string();
    while cur!=*v {
        path.push(cur.clone());
        if let Some(p)=parent.get(&cur) { cur=p.clone(); } else { break; }
    }
    path.push(v.to_string());
    path.reverse();
    path
}

fn join_cycle(c:&[str])->str{
    let mut s=String::new();
    let mut i=0; while i<c.len(){ s.push_str(&c[i]); if i+1<c.len(){ s.push_str(" -> "); } i+=1; }
    s
}

fn tarjan(
    g:&Graph, v:&str, idx:&mut i32,
    index:&mut Map<str,i32>, low:&mut Map<str,i32>,
    onstk:&mut Map<str,bool>, stk:&mut Vec<str>, out:&mut Vec<Vec<str>>
){
    index.insert(v.to_string(), *idx); low.insert(v.to_string(), *idx); *idx+=1;
    stk.push(v.to_string()); onstk.insert(v.to_string(), true);

    let outs = g.successors(v);
    let mut i=0; while i<outs.len() {
        let w=&outs[i];
        if !index.contains_key(w.to_string()) {
            tarjan(g, w, idx, index, low, onstk, stk, out);
            let lw = *low.get(w.to_string()).unwrap();
            let lv = *low.get(v.to_string()).unwrap();
            if lw < lv { low.insert(v.to_string(), lw); }
        } else if *onstk.get(w.to_string()).unwrap_or(&false) {
            // back-edge sur la pile
            let iw = *index.get(w.to_string()).unwrap();
            let lv = *low.get(v.to_string()).unwrap();
            if iw < lv { low.insert(v.to_string(), iw); }
        }
        i+=1;
    }

    if index.get(v.to_string()) == low.get(v.to_string()) {
        // racine de composante
        let mut comp=Vec::<str>::new();
        loop {
            let w = stk.pop().unwrap();
            onstk.insert(w.clone(), false);
            comp.push(w.clone());
            if w==*v { break; }
        }
        comp.sort();
        out.push(comp);
    }
}

/* —————————————— Doc-tests / smoke —————————————— */
//! fn _smoke_graph() {
//!     let mut g = Graph::new();
//!     g.add_edge("parse".into(),"lower".into());
//!     g.add_edge("lower".into(),"opt".into());
//!     g.add_edge("opt".into(),"codegen".into());
//!     let topo = g.topo_sort().unwrap();
//!     assert(topo[0]=="parse");
//!
//!     // cycle
//!     g.add_edge("codegen".into(),"parse".into());
//!     assert(g.topo_sort().is_err());
//!     let cyc = g.find_cycle().unwrap();
//!     assert(cyc.first().unwrap()==cyc.last().unwrap());
//!
//!     // scc
//!     let scc = g.scc();
//!     assert(scc.iter().any(|c| c.len()>=2));
//!
//!     // couches topo (sur DAG simple)
//!     let mut h = Graph::from_pairs(vec![("a".into(),"c".into()),("b".into(),"c".into())]);
//!     let layers = h.layers_topo().unwrap();
//!     assert(layers[0]==vec!["a".into(),"b".into()]);
//!
//!     // plus longue chaîne
//!     let lp = h.longest_path_dag().unwrap();
//!     assert(lp.len()>=2);
//!
//!     // dot
//!     let dot = h.to_dot(Some("demo"));
//!     assert(dot.contains("digraph"));
//! }
