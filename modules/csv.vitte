//! csv.vitte — CSV robuste (parse/écrit), options, en-têtes, types, sniffer.
//!
//! ✨ Features
//! - Parsing solide : guillemets, quotes doublés, champs multi-lignes, CRLF, lignes vides.
//! - Options : délimiteur (`,` `;` `\t` `|` …), quote (par défaut `"`), has_headers,
//!             commentaires (ex: '#'), trim des champs non quotés, sortie CRLF.
//! - Sniffer : détection du séparateur le plus probable.
//! - Écriture : quoting auto si nécessaire, choix `\n` ou `\r\n`.
//! - Table & accès par nom de colonne : `row.get("email")`, conversions `get_u/get_f/get_bool`.
//!
//! ⚠️ Non-crypto, non-streaming vers fichiers (mais gère de gros textes).
//!
//! Usage rapide :
//! ```vitte
//! let s = "name,age\nAda,36\nBob,  7";
//! let csv = Csv::new(Options::default().has_headers(true).trim(true));
//! let table = csv.parse(s).unwrap();
//! let r0 = &table.rows[0];
//! assert(r0.get("age", &table).unwrap().get_u(0).unwrap()==36);
//! println!("{}", write_with(&table.rows_as_vecs(), None, Options::default()));
//! ```

#![version("0.2.0")]
#![strict]

use std::collections::{Map};

pub struct Options {
    pub delim: char,              // séparateur (par défaut ',')
    pub quote: char,              // guillemet (par défaut '"')
    pub has_headers: bool,        // première ligne = headers
    pub comment: Option<char>,    // ex: Some('#') → ignore lignes commençant par '#'
    pub trim: bool,               // trim des champs non quotés
    pub use_crlf: bool,           // écriture \r\n
}

impl Options {
    pub fn default() -> Self {
        Self{ delim:',', quote:'"', has_headers:false, comment:None, trim:false, use_crlf:false }
    }
    pub fn delim(mut self, c:char)->Self{ self.delim=c; self }
    pub fn quote(mut self, c:char)->Self{ self.quote=c; self }
    pub fn has_headers(mut self, yes:bool)->Self{ self.has_headers=yes; self }
    pub fn comment(mut self, c:Option<char>)->Self{ self.comment=c; self }
    pub fn trim(mut self, yes:bool)->Self{ self.trim=yes; self }
    pub fn crlf(mut self, yes:bool)->Self{ self.use_crlf=yes; self }
}

/* ———————————————————— Types table/ligne ———————————————————— */

pub struct Table {
    pub headers: Option<Vec<str>>,
    pub rows: Vec<Record>,
    index: Map<str, usize>, // nom -> idx (si headers)
}
impl Table {
    fn from_rows(headers: Option<Vec<str>>, rows: Vec<Record>) -> Self {
        let mut idx = Map::<str,usize>::new();
        if let Some(h)=&headers {
            let mut i=0; while i<h.len(){ idx.insert(h[i].to_lower(), i); i+=1; }
        }
        Self{ headers, rows, index: idx }
    }

    /// Accès: donne un RowView avec mapping par nom si headers présents
    pub fn row(&self, i:usize)->Option<RowView<'_>>{
        self.rows.get(i).map(|r| RowView{ r, table:self })
    }

    /// Simplifie l’écriture : exporte `Vec<Vec<str>>`
    pub fn rows_as_vecs(&self) -> Vec<Vec<str>> {
        self.rows.iter().map(|r| r.fields.clone()).collect()
    }
}

pub struct Record {
    pub fields: Vec<str>,
}
impl Record {
    pub fn get_idx(&self, i:usize)->Option<&str>{ self.fields.get(i).map(|s| &**s) }
}

pub struct RowView<'a> {
    r: &'a Record,
    table: &'a Table,
}
impl<'a> RowView<'a> {
    /// Récupère une cellule par nom de colonne (insensible à la casse).
    pub fn get(&self, name:&str) -> Option<Cell<'_>> {
        let k = name.to_lower();
        if let Some(i)=self.table.index.get(&k) {
            return Some(Cell{ s: self.r.fields.get(*i)? });
        }
        None
    }
    /// Récupère par index (0-based).
    pub fn get_i(&self, i:usize)->Option<Cell<'_>> {
        self.r.fields.get(i).map(|s| Cell{ s })
    }
}

pub struct Cell<'a> { s: &'a str }
impl<'a> Cell<'a> {
    pub fn as_str(&self)->&str { self.s }
    pub fn get_u(&self, _idx_unused:usize)->Option<u32>{ self.s.trim().parse::<u32>().ok() }
    pub fn get_i64(&self)->Option<i64>{ self.s.trim().parse::<i64>().ok() }
    pub fn get_f(&self)->Option<f64>{ self.s.trim().parse::<f64>().ok() }
    pub fn get_bool(&self)->Option<bool>{
        let t=self.s.trim().to_lower(); Some(t=="1"||t=="true"||t=="yes"||t=="on")
    }
}

/* ———————————————————— Erreurs ———————————————————— */

pub enum CsvError {
    UnterminatedQuote{ line:usize, col:usize },
    UnexpectedEofInQuote{ line:usize, col:usize },
    Generic(str),
}
impl CsvError {
    fn msg(&self)->str{
        match self {
            CsvError::UnterminatedQuote{line,col} => format!("guillemet non terminé (ligne {}, col {})", line, col),
            CsvError::UnexpectedEofInQuote{line,col} => format!("fin de fichier dans un champ quoté (ligne {}, col {})", line, col),
            CsvError::Generic(m) => m.clone(),
        }
    }
}

/* ———————————————————— Moteur ———————————————————— */

pub struct Csv { opts: Options }
impl Csv {
    pub fn new(opts: Options) -> Self { Self{ opts } }

    pub fn parse(&self, s:&str) -> Result<Table, str> {
        let mut rows:Vec<Record> = Vec::new();
        let mut cur = String::new();
        let mut row:Vec<str> = Vec::new();
        let mut in_q = false;
        let mut line = 1usize;
        let mut col  = 0usize;
        let mut at_line_start = true;
        let mut skipping_comment = false;

        let bytes = s.as_bytes();
        let mut i=0usize;
        while i<bytes.len() {
            let c = bytes[i] as char;
            col += 1;

            // fin de ligne ?
            if !in_q && !skipping_comment && (c=='\n' || c=='\r') {
                // consomme \r\n comme un seul EOL
                if c=='\r' && i+1<bytes.len() && bytes[i+1] as char=='\n' { i+=1; }
                push_cell(&mut row, &mut cur, self.opts.trim);
                if !(row.is_empty() && cur.is_empty()) { // ignore ligne vide pure
                    rows.push(Record{ fields: row.clone() }); row.clear();
                }
                cur.clear();
                line += 1; col = 0;
                at_line_start = true; skipping_comment = false;
                i+=1; continue;
            }

            if skipping_comment {
                i+=1; continue;
            }

            if at_line_start {
                // ligne commentée ?
                if let Some(h) = self.opts.comment {
                    if c == h { skipping_comment = true; i+=1; continue; }
                }
                at_line_start = false;
            }

            if in_q {
                if c == self.opts.quote {
                    // doublage de quotes ?
                    if i+1<bytes.len() && (bytes[i+1] as char)==self.opts.quote {
                        cur.push(self.opts.quote); i+=2; col+=1; continue;
                    } else {
                        in_q = false; i+=1; continue;
                    }
                } else {
                    cur.push(c); i+=1; continue;
                }
            } else {
                if c == self.opts.quote {
                    in_q = true; i+=1; continue;
                }
                if c == self.opts.delim {
                    push_cell(&mut row, &mut cur, self.opts.trim);
                    i+=1; continue;
                }
                if c=='\n' || c=='\r' {
                    // déjà géré plus haut
                    continue;
                }
                cur.push(c); i+=1; continue;
            }
        }

        // fin de buffer
        if in_q {
            return Err(CsvError::UnexpectedEofInQuote{ line, col }.msg());
        }
        // pousse dernière cellule/ligne
        push_cell(&mut row, &mut cur, self.opts.trim);
        if !(row.is_empty() && cur.is_empty()) {
            rows.push(Record{ fields: row.clone() }); row.clear();
        }

        // headers ?
        if self.opts.has_headers && !rows.is_empty() {
            let headers = rows.remove(0).fields;
            return Ok(Table::from_rows(Some(headers), rows));
        }
        Ok(Table::from_rows(None, rows))
    }
}

/* ———————————————————— Helpers parse ———————————————————— */

fn push_cell(row:&mut Vec<str>, cur:&mut String, trim:bool){
    let mut s = cur.clone();
    if trim { s = s.trim().to_string(); }
    row.push(s);
    cur.clear();
}

/* ———————————————————— Sniffer ———————————————————— */

/// Devine le séparateur parmi [',',';','\t','|'] (max 2048 octets).
pub fn sniff_delimiter(sample:&str) -> char {
    let cand = [',',';','\t','|'];
    let head = if sample.len()>2048 { &sample[..2048] } else { sample };
    let mut score = [0usize;4];
    for (ci,&d) in cand.iter().enumerate() {
        score[ci] = head.chars().filter(|&c| c==d).count();
    }
    // choisit le plus fréquent ; fallback ','
    let mut best=0usize; let mut idx=0usize;
    let mut i=0; while i<score.len(){ if score[i]>best { best=score[i]; idx=i; } i+=1; }
    cand[idx]
}

/* ———————————————————— Écriture ———————————————————— */

/// Écrit un tableau de lignes. Si `headers` est Some, ils sont écrits en premier.
pub fn write_with(rows:&[Vec<str>], headers: Option<&[str]>, opts: Options) -> str {
    let nl = if opts.use_crlf { "\r\n" } else { "\n" };
    let mut out = String::new();
    if let Some(h)=headers {
        out.push_str(&join_row(h, opts.delim, opts.quote));
        out.push_str(nl);
    }
    let mut i=0; while i<rows.len() {
        let row = &rows[i];
        // convertir &[str] facilement
        let mut refs:Vec<&str> = Vec::new();
        let mut j=0; while j<row.len(){ refs.push(&row[j]); j+=1; }
        out.push_str(&join_row(&refs, opts.delim, opts.quote));
        if i+1<rows.len(){ out.push_str(nl); }
        i+=1;
    }
    out
}

fn join_row(fields:&[&str], delim:char, quote:char) -> str {
    let mut out=String::new();
    let mut first=true;
    for f in fields {
        if !first { out.push(delim); } first=false;
        let need_quote = f.contains(delim) || f.contains('\n') || f.contains('\r') || f.contains(quote) || f.starts_with(' ') || f.ends_with(' ');
        if need_quote {
            out.push(quote);
            let mut i=0; while i<f.len() {
                let c = f.as_bytes()[i] as char;
                if c==quote { out.push(quote); out.push(quote); } else { out.push(c); }
                i+=1;
            }
            out.push(quote);
        } else {
            out.push_str(f);
        }
    }
    out
}

/* ———————————————————— Raccourcis "compat" ———————————————————— */

/// Parse simplifié (séparateur = ',', pas d’en-têtes). Retourne rows.
pub fn parse(s:&str)->Vec<Vec<str>>{
    let csv = Csv::new(Options::default());
    match csv.parse(s) {
        Ok(t)=>t.rows_as_vecs(),
        Err(_)=>Vec::new(),
    }
}

/// Écrit des lignes (séparateur ',', \n).
pub fn write(rows:&[Vec<str>])->str{
    write_with(rows, None, Options::default())
}

/* ———————————————————— Doc test ———————————————————— */
//! fn _csv_smoke() {
//!     let data = "name;age;note\r\n\"Ada;L.\";36;\"génie\"\nBob;7;\"ligne\nmulti\"";
//!     let opts = Options::default().delim(';').has_headers(true);
//!     let csv = Csv::new(opts);
//!     let t = csv.parse(data).unwrap();
//!     assert(t.headers.as_ref().unwrap()[0]=="name");
//!     assert(t.row(0).unwrap().get("age").unwrap().get_u(0).unwrap()==36);
//!
//!     // Écriture
//!     let txt = write_with(&t.rows_as_vecs(), t.headers.as_ref().map(|v| &v[..]), Options::default().delim(';').crlf(true));
//!     assert(txt.contains("\r\n"));
//! }
