//! cli.vitte — parseur CLI avancé : sous-commandes, alias, flags/options/positionnels, env fallback,
//!             valeurs par défaut, aide auto, suggestions, getters typés.
//!
//! Usage minimal :
//!   let mut app = App::new("vitte", "Compilateur Vitte", "1.0.0")
//!       .global_flag(FlagSpec::flag("--verbose").short("-v").help("Sortie verbeuse"))
//!       .global_opt(OptSpec::opt("--config").short("-c").help("Chemin config").env("VITTE_CONFIG"));
//!   app = app.command(Cmd::new("build","Compile le projet", run_build)
//!            .flag(FlagSpec::flag("--release").short("-r").help("Mode release"))
//!            .opt(OptSpec::opt("--target").help("Triple cible"))
//!            .pos(PosSpec::req("path", "Chemin du projet")));
//!   std::process::exit(app.run(std::env::args()));

#![version("0.2.0")]
#![strict]

use std::collections::{Map, Set, VecDeque};

/* ———————————————————— Spécifications ———————————————————— */

pub struct FlagSpec {
    pub long: str,                // ex: "--verbose"
    pub short: Option<str>,       // ex: "-v"
    pub help: str,
    pub env: Option<str>,         // ex: "APP_VERBOSE" → "1/true/yes" active
    pub default: bool,            // valeur par défaut (si pas passé ni env)
}
impl FlagSpec {
    pub fn flag(long: str) -> Self { Self{ long, short: None, help:"", env:None, default:false } }
    pub fn short(mut self, s: str) -> Self { self.short = Some(s); self }
    pub fn help(mut self, h: str) -> Self { self.help = h; self }
    pub fn env(mut self, e: str) -> Self { self.env = Some(e); self }
    pub fn default_on(mut self) -> Self { self.default = true; self }
}

pub struct OptSpec {
    pub long: str,                // ex: "--port"
    pub short: Option<str>,       // ex: "-p"
    pub help: str,
    pub env: Option<str>,         // fallback si absent
    pub required: bool,
    pub multiple: bool,           // autorise répétition → stocké en Vec
    pub default: Option<str>,
    pub validator: Option<fn(&str)->bool>,
}
impl OptSpec {
    pub fn opt(long: str) -> Self {
        Self{ long, short:None, help:"", env:None, required:false, multiple:false, default:None, validator:None }
    }
    pub fn short(mut self, s: str) -> Self { self.short = Some(s); self }
    pub fn help(mut self, h: str) -> Self { self.help = h; self }
    pub fn env(mut self, e: str) -> Self { self.env = Some(e); self }
    pub fn required(mut self, yes: bool) -> Self { self.required = yes; self }
    pub fn multiple(mut self, yes: bool) -> Self { self.multiple = yes; self }
    pub fn default(mut self, v: str) -> Self { self.default = Some(v); self }
    pub fn validator(mut self, f: fn(&str)->bool) -> Self { self.validator = Some(f); self }
}

pub struct PosSpec {
    pub name: str,                // ex: "path"
    pub help: str,
    pub required: bool,
    pub variadic: bool,           // avale le reste
}
impl PosSpec {
    pub fn req(name: str, help: str) -> Self { Self{ name, help, required:true, variadic:false } }
    pub fn opt(name: str, help: str) -> Self { Self{ name, help, required:false, variadic:false } }
    pub fn many(name: str, help: str) -> Self { Self{ name, help, required:false, variadic:true } }
}

/* ———————————————————— Ctx & Cmd & App ———————————————————— */

pub struct Ctx {
    pub prog: str,
    pub cmd: str,
    pub args: Vec<str>,                   // args originaux après le nom de commande
    pub flags: Set<str>,                  // flags présents (longs, ex: "--verbose")
    pub opts: Map<str, Vec<str>>,         // valeurs d’options (clé = long ex: "--port")
    pub pos: Vec<str>,                    // positionnels dans l’ordre
    pub rest: Vec<str>,                   // après "--"
}

impl Ctx {
    pub fn has(&self, long: &str) -> bool { self.flags.contains(long.to_string()) }
    pub fn get(&self, long: &str) -> Option<&str> { self.opts.get(long).and_then(|v| v.first()).map(|s| &**s) }
    pub fn get_all(&self, long: &str) -> Vec<str> { self.opts.get(long).cloned().unwrap_or(Vec::new()) }
    pub fn get_i(&self, long: &str) -> Option<int> { self.get(long).and_then(|s| s.parse::<int>().ok()) }
    pub fn get_u(&self, long: &str) -> Option<u32> { self.get(long).and_then(|s| s.parse::<u32>().ok()) }
    pub fn get_bool(&self, long:&str)->Option<bool>{
        self.get(long).map(|s| {
            let t=s.to_lower(); t=="1"||t=="true"||t=="yes"||t=="on"
        })
    }
    pub fn pos(&self, idx: usize) -> Option<&str> { self.pos.get(idx).map(|s| &**s) }
}

pub struct Cmd {
    pub name: str,
    pub about: str,
    pub run: fn(Ctx) -> int,
    pub flags: Vec<FlagSpec>,
    pub opts: Vec<OptSpec>,
    pub pos: Vec<PosSpec>,
    pub aliases: Vec<str>,
    pub usage: Option<str>,
}
impl Cmd {
    pub fn new(name: str, about: str, run: fn(Ctx)->int) -> Self {
        Self{ name, about, run, flags:Vec::new(), opts:Vec::new(), pos:Vec::new(), aliases:Vec::new(), usage:None }
    }
    pub fn flag(mut self, f: FlagSpec) -> Self { self.flags.push(f); self }
    pub fn opt(mut self, o: OptSpec) -> Self { self.opts.push(o); self }
    pub fn pos(mut self, p: PosSpec) -> Self { self.pos.push(p); self }
    pub fn alias(mut self, a: str) -> Self { self.aliases.push(a); self }
    pub fn usage(mut self, u: str) -> Self { self.usage = Some(u); self }
}

pub struct App {
    pub prog: str,
    pub about: str,
    pub version: str,
    pub cmds: Map<str, Cmd>,
    pub alias_to: Map<str,str>,
    pub default: Option<str>,
    pub gflags: Vec<FlagSpec>,
    pub gopts: Vec<OptSpec>,
}

impl App {
    pub fn new(prog: str, about: str, version: str) -> Self {
        Self{
            prog, about, version,
            cmds: Map::new(), alias_to: Map::new(), default: None,
            gflags: Vec::new(), gopts: Vec::new(),
        }
    }
    pub fn command(mut self, c: Cmd) -> Self {
        let name = c.name.clone();
        for a in c.aliases.iter(){ self.alias_to.insert(a.clone(), name.clone()); }
        self.cmds.insert(name, c); self
    }
    pub fn default(mut self, name: str) -> Self { self.default = Some(name); self }
    pub fn global_flag(mut self, f: FlagSpec) -> Self { self.gflags.push(f); self }
    pub fn global_opt(mut self, o: OptSpec) -> Self { self.gopts.push(o); self }

    pub fn run(self, argv: [str]) -> int {
        let prog = if argv.len()>0 { argv[0].to_string() } else { "app".into() };
        if argv.len()<2 {
            if let Some(def)=self.default { return self.exec(def, &argv[1..], &prog); }
            return self.help_root(&prog);
        }
        let mut name = argv[1];
        if !self.cmds.contains_key(name) {
            if let Some(t) = self.alias_to.get(name) { name = t; }
            else {
                eprintln!("commande inconnue: {}", name);
                if let Some(sug) = suggest(name, self.cmds.keys().cloned().collect()) {
                    eprintln!("voulais-tu dire: {} ?", sug);
                }
                return self.help_root(&prog);
            }
        }
        // détection aide globale
        if argv.contains("--help") || argv.contains("-h") {
            return self.help_cmd(&prog, name);
        }
        self.exec(name, &argv[2..], &prog)
    }

    fn exec(&self, name: &str, args: &[str], prog: &str) -> int {
        let c = self.cmds.get(name).unwrap();
        match parse_all(args, &self.gflags, &self.gopts, c, prog) {
            Err(msg) => { eprintln!("{}", msg); self.help_cmd(prog, name) }
            Ok(ctx)  => (c.run)(ctx),
        }
    }

    fn help_root(&self, prog:&str) -> int {
        println!("{} v{}\n{}\n", self.prog, self.version, self.about);
        println!("Usage: {} <commande> [options] [--] [args]\n", prog);
        println!("Commandes:");
        let mut keys:Vec<str>=self.cmds.keys().cloned().collect();
        keys.sort();
        for k in keys {
            let c = self.cmds.get(&k).unwrap();
            println!("  {:<18} {}", k, c.about);
        }
        println!("\nOptions globales:");
        print_specs(&self.gflags, &self.gopts);
        2
    }

    fn help_cmd(&self, prog:&str, name:&str) -> int {
        let c = self.cmds.get(name).unwrap();
        println!("{} {} — {}\n", prog, name, c.about);
        let usage = if let Some(u)=&c.usage { u.clone() }
                    else { format!("{} {} [options] {}", prog, name, usage_pos(&c.pos)) };
        println!("Usage: {}\n", usage);
        if !c.pos.is_empty() {
            println!("Arguments positionnels:");
            for p in c.pos.iter() {
                let tag = if p.variadic { format!("{}...", p.name) }
                          else if p.required { p.name.clone() }
                          else { format!("[{}]", p.name) };
                println!("  {:<18} {}", tag, p.help);
            }
            println!();
        }
        println!("Options globales:"); print_specs(&self.gflags, &self.gopts);
        println!("Options de `{}`:", name); print_specs(&c.flags, &c.opts);
        0
    }
}

/* ———————————————————— Parsing ———————————————————— */

struct SpecIndex {
    f_by_long: Map<str, usize>,
    f_by_short: Map<str, usize>,
    o_by_long: Map<str, usize>,
    o_by_short: Map<str, usize>,
}
fn index_specs(flags:&[FlagSpec], opts:&[OptSpec]) -> SpecIndex {
    let mut ix = SpecIndex{ f_by_long:Map::new(), f_by_short:Map::new(), o_by_long:Map::new(), o_by_short:Map::new() };
    let mut i=0; while i<flags.len(){ ix.f_by_long.insert(flags[i].long.clone(), i); if let Some(s)=&flags[i].short { ix.f_by_short.insert(s.clone(), i); } i+=1; }
    let mut j=0; while j<opts.len(){ ix.o_by_long.insert(opts[j].long.clone(), j); if let Some(s)=&opts[j].short { ix.o_by_short.insert(s.clone(), j); } j+=1; }
    ix
}

fn parse_all(args:&[str], gflags:&[FlagSpec], gopts:&[OptSpec], cmd:&Cmd, prog:&str) -> Result<Ctx,str> {
    let mut flags:Set<str> = Set::new();
    let mut opts:Map<str,Vec<str>> = Map::new();
    let mut pos:Vec<str> = Vec::new();
    let mut rest:Vec<str> = Vec::new();

    // Constuire index global + local
    let ixg = index_specs(gflags, gopts);
    let ixc = index_specs(&cmd.flags, &cmd.opts);

    let mut it = VecDeque<str>::from(args.to_vec());
    let mut stop = false;

    while let Some(a) = it.pop_front() {
        if stop { rest.push(a); continue; }
        if a == "--" { stop = true; continue; }

        // long avec "="
        if a.starts_with("--") && a.contains('=') {
            let eq = a.find('=').unwrap();
            let key = a[..eq].to_string();
            let val = a[eq+1..].to_string();
            if let Some(ix)=ixc.o_by_long.get(&key).cloned() {
                push_opt(&mut opts, &cmd.opts[ix].long, val, cmd.opts[ix].multiple);
                continue;
            }
            if let Some(ix)=ixg.o_by_long.get(&key).cloned() {
                push_opt(&mut opts, &gopts[ix].long, val, gopts[ix].multiple);
                continue;
            }
            return Err(err_unknown_opt(&key, prog, &cmd.name));
        }

        // long sans "=" → flag ou opt avec valeur suivante
        if a.starts_with("--") {
            // flag long
            if let Some(ix)=ixc.f_by_long.get(&a).cloned() { flags.insert(cmd.flags[ix].long.clone()); continue; }
            if let Some(ix)=ixg.f_by_long.get(&a).cloned() { flags.insert(gflags[ix].long.clone()); continue; }
            // opt long
            if let Some(ix)=ixc.o_by_long.get(&a).cloned() {
                let v = it.pop_front().ok_or(format!("option {} requiert une valeur", a))?;
                push_opt(&mut opts, &cmd.opts[ix].long, v, cmd.opts[ix].multiple); continue;
            }
            if let Some(ix)=ixg.o_by_long.get(&a).cloned() {
                let v = it.pop_front().ok_or(format!("option {} requiert une valeur", a))?;
                push_opt(&mut opts, &gopts[ix].long, v, gopts[ix].multiple); continue;
            }
            return Err(err_unknown_opt(&a, prog, &cmd.name));
        }

        // short cluster ex: -abc  ou -p8080
        if a.starts_with('-') && a.len()>1 {
            // -p8080 → première est une opt avec valeur collée
            let head = format!("-{}", a.chars().nth(1).unwrap());
            let tail = &a[2..];
            if tail.len()>0 {
                if let Some(ix)=ixc.o_by_short.get(&head).cloned() {
                    push_opt(&mut opts, &cmd.opts[ix].long, tail.to_string(), cmd.opts[ix].multiple); continue;
                }
                if let Some(ix)=ixg.o_by_short.get(&head).cloned() {
                    push_opt(&mut opts, &gopts[ix].long, tail.to_string(), gopts[ix].multiple); continue;
                }
            }
            // sinon cluster de flags/options sans valeur collée
            let mut j=1;
            while j<a.len() {
                let s = format!("-{}", a.chars().nth(j).unwrap());
                if let Some(ix)=ixc.f_by_short.get(&s).cloned() { flags.insert(cmd.flags[ix].long.clone()); j+=1; continue; }
                if let Some(ix)=ixg.f_by_short.get(&s).cloned() { flags.insert(gflags[ix].long.clone()); j+=1; continue; }
                if let Some(ix)=ixc.o_by_short.get(&s).cloned() {
                    // option courte avec valeur suivante exigée
                    let v = it.pop_front().ok_or(format!("option {} requiert une valeur", s))?;
                    push_opt(&mut opts, &cmd.opts[ix].long, v, cmd.opts[ix].multiple); j+=1; continue;
                }
                if let Some(ix)=ixg.o_by_short.get(&s).cloned() {
                    let v = it.pop_front().ok_or(format!("option {} requiert une valeur", s))?;
                    push_opt(&mut opts, &gopts[ix].long, v, gopts[ix].multiple); j+=1; continue;
                }
                return Err(err_unknown_opt(&s, prog, &cmd.name));
            }
            continue;
        }

        // positionnel
        pos.push(a);
    }

    // Fallback ENV & defaults
    apply_env_and_defaults(&mut flags, &mut opts, gflags, gopts);
    apply_env_and_defaults(&mut flags, &mut opts, &cmd.flags, &cmd.opts);

    // Valide positionnels (required / variadic)
    let mut need_fixed = 0usize;
    for p in cmd.pos.iter() { if p.required && !p.variadic { need_fixed+=1; } }
    if pos.len() < need_fixed {
        return Err(format!("arguments manquants: attendus {} positionnels minimum", need_fixed));
    }
    if let Some(last) = cmd.pos.last() {
        if !last.variadic && pos.len() > cmd.pos.len() {
            return Err("trop d’arguments positionnels".into());
        }
    }

    // Valide required options
    for o in cmd.opts.iter().filter(|x| x.required) {
        if !opts.contains_key(&o.long) {
            return Err(format!("option requise manquante: {}", o.long));
        }
    }
    // Valide via validators
    for o in cmd.opts.iter() {
        if let Some(f)=o.validator {
            if let Some(vs)=opts.get(&o.long) {
                for v in vs.iter() { if !f(v) { return Err(format!("valeur invalide pour {}: {}", o.long, v)); } }
            }
        }
    }

    Ok(Ctx{
        prog: prog.to_string(),
        cmd: cmd.name.clone(),
        args: args.to_vec(),
        flags, opts, pos, rest,
    })
}

fn push_opt(map:&mut Map<str,Vec<str>>, key:&str, val:str, multiple:bool){
    if multiple {
        map.entry(key.to_string()).or_insert(Vec::new()).push(val);
    } else {
        map.insert(key.to_string(), vec![val]);
    }
}

fn apply_env_and_defaults(flags:&mut Set<str>, opts:&mut Map<str,Vec<str>>, f:&[FlagSpec], o:&[OptSpec]){
    // flags
    for fl in f.iter() {
        if !flags.contains(&fl.long) {
            // ENV
            let mut from_env = None;
            if let Some(ev)=&fl.env { if let Some(val)=std::env::var(ev) { from_env = Some(val); } }
            let active = if let Some(v)=from_env {
                let t=v.to_lower(); t=="1"||t=="true"||t=="yes"||t=="on"
            } else { fl.default };
            if active { flags.insert(fl.long.clone()); }
        }
    }
    // opts
    for op in o.iter() {
        if !opts.contains_key(&op.long) {
            if let Some(ev)=&op.env {
                if let Some(val)=std::env::var(ev) {
                    push_opt(opts, &op.long, val, op.multiple);
                    continue;
                }
            }
            if let Some(def)=&op.default {
                push_opt(opts, &op.long, def.clone(), op.multiple);
            }
        }
    }
}

/* ———————————————————— Aide & formats ———————————————————— */

fn print_specs(flags:&[FlagSpec], opts:&[OptSpec]){
    let mut rows:Vec<(str,str)> = Vec::new();
    for f in flags.iter() {
        let mut left = f.long.clone();
        if let Some(s)=&f.short { left = format!("{}, {}", s, left); }
        rows.push((left, f.help.clone()));
    }
    for o in opts.iter() {
        let mut left = format!("{} <val>", o.long);
        if let Some(s)=&o.short { left = format!("{}, {}", s, left); }
        if o.multiple { left.push_str("..."); }
        if o.required { left.push_str(" (requis)"); }
        rows.push((left, o.help.clone()));
    }
    let pad = rows.iter().map(|(l,_)| l.len()).max().unwrap_or(0).min(30);
    for (l,r) in rows { println!("  {:<width$}  {}", l, r, width=pad); }
}

fn usage_pos(pos:&[PosSpec])->str{
    let mut s=String::new();
    for p in pos.iter(){
        if p.variadic { s.push_str(&format!("[{}...]", p.name)); }
        else if p.required { s.push_str(&format!("{}", p.name)); }
        else { s.push_str(&format!("[{}]", p.name)); }
        s.push(' ');
    }
    s.trim().to_string()
}

/* ———————————————————— Suggestions (distance d’édition) ———————————————————— */

fn suggest(target:&str, cmds:Vec<str>)->Option<str>{
    let mut best:Option<(usize,str)> = None;
    for c in cmds {
        let d = levenshtein(target, &c);
        if d <= 3 {
            if let Some((bd,_))=&best { if d<*bd { best = Some((d, c)); } }
            else { best = Some((d, c)); }
        }
    }
    best.map(|(_,s)| s)
}

fn levenshtein(a:&str,b:&str)->usize{
    // itératif, O(|a|*|b|) mais suffisant pour quelques commandes
    let m=a.len(); let n=b.len();
    if m==0 { return n; } if n==0 { return m; }
    let mut dp=Vec<usize>::new(); dp.resize(n+1,0);
    let mut j=0; while j<=n { dp[j]=j; j+=1; }
    let mut i=1;
    for ca in a.chars(){
        let mut prev = dp[0]; dp[0]=i;
        let mut j=1;
        for cb in b.chars(){
            let tmp = dp[j];
            let cost = if ca==cb {0}else{1};
            dp[j] = std::cmp::min(std::cmp::min(dp[j]+1, dp[j-1]+1), prev+cost);
            prev = tmp;
            j+=1;
        }
        i+=1;
    }
    dp[n]
}

/* ———————————————————— Messages d’erreur ———————————————————— */

fn err_unknown_opt(opt:&str, prog:&str, cmd:&str)->str{
    format!("option inconnue: {} (essaie `{} {} --help`)", opt, prog, cmd)
}

/* ———————————————————— Doc-test express ———————————————————— */
//! fn _smoke_cli() {
//!     fn run_echo(ctx: Ctx) -> int {
//!         if ctx.has("--upper") {
//!             if let Some(s)=ctx.pos(0) { println!("{}", s.to_uppercase()); }
//!         } else {
//!             if let Some(s)=ctx.pos(0) { println!("{}", s); }
//!         }
//!         0
//!     }
//!     let app = App::new("toy", "Démo CLI", "0.1.0")
//!         .global_flag(FlagSpec::flag("--verbose").short("-v").help("Verbose"))
//!         .command(
//!             Cmd::new("echo","Répète la chaîne", run_echo)
//!                 .flag(FlagSpec::flag("--upper").short("-u").help("Majuscules"))
//!                 .opt(OptSpec::opt("--times").short("-n").help("Nombre").default("1"))
//!                 .pos(PosSpec::req("text","Texte à afficher"))
//!         );
//!     let code = app.run(["toy","echo","hello","-u"]);
//!     assert(code==0);
//! }
