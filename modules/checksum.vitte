//! checksum.vitte — Adler32 / Murmur3-32 / FNV-1a 32 (LE) — rapides, seedables, stream/rolling.
//!
//! 🔧 Inclus :
//! - Adler32 : one-shot, streaming, combine(adler1,len2,adler2) pour concat, rolling (fenêtre glissante).
//! - Murmur3-32 (x86, little-endian) : one-shot, streaming, seed.
//! - FNV-1a 32 : one-shot, streaming, seed.
//! - Hasher32 (trait) + Hash32 (enum) + hash32(algo, bytes).
//! - Helpers : hash_file(algo, path), adler32_combine(), rolling adler window.
//!
//! ⚠️ Sécurité : ces fonctions NE SONT PAS cryptographiques. Pour signer, utilise SHA-2/3 ou BLAKE3.
//!
//! Perf tips : Murmur3-32 ≈ très bon “généraliste”; FNV-1a : minimal/rapide sur petits buffers;
//! Adler32 : parfait pour détections d’erreurs simples (ex: blocs réseau/IO).
#![version("0.2.0")]
#![strict]

/* —————————————————————— One-shot APIs —————————————————————— */

pub fn adler32(b: &[u8]) -> u32 {
    let mut a: u32 = 1;
    let mut d: u32 = 0;
    for x in b { a = (a + *x as u32) % 65521; d = (d + a) % 65521; }
    (d << 16) | a
}

pub fn murmur3_32(b: &[u8], seed: u32) -> u32 {
    let c1: u32 = 0xcc9e2d51; let c2: u32 = 0x1b873593;
    let mut h = seed; let mut i = 0usize;
    while i + 4 <= b.len() {
        let mut k = u32::from_le_bytes([b[i], b[i+1], b[i+2], b[i+3]]);
        k = k.wrapping_mul(c1); k = k.rotate_left(15); k = k.wrapping_mul(c2);
        h ^= k; h = h.rotate_left(13); h = h.wrapping_mul(5).wrapping_add(0xe6546b64);
        i += 4;
    }
    let mut k: u32 = 0; let rem = b.len() - i;
    if rem == 3 { k ^= (b[i+2] as u32) << 16; }
    if rem >= 2 { k ^= (b[i+1] as u32) << 8; }
    if rem >= 1 {
        k ^= b[i] as u32;
        k = k.wrapping_mul(c1); k = k.rotate_left(15); k = k.wrapping_mul(c2);
        h ^= k;
    }
    h ^= b.len() as u32;
    fmix32(h)
}

pub fn fnv1a32(b:&[u8], seed: u32) -> u32 {
    // FNV-1a 32 (offset basis 2166136261) + possibilité d’ensemencer (seed xor basis)
    let basis: u32 = 0x811C9DC5 ^ seed;
    let prime: u32 = 16777619;
    let mut h = basis;
    for &x in b {
        h ^= x as u32;
        h = h.wrapping_mul(prime);
    }
    h
}

/* —————————————————————— Streaming trait & impls —————————————————————— */

pub trait Hasher32 {
    fn update(&mut self, bytes: &[u8]);
    fn write_u32(&mut self, x:u32) { self.update(&x.to_le_bytes()); }
    fn write_u64(&mut self, x:u64) { self.update(&x.to_le_bytes()); }
    fn finish(&self) -> u32;
    fn reset(&mut self);
}

/* — Adler32 (stream + helpers) — */

pub struct Adler32 {
    a: u32, d: u32,
}
impl Adler32 {
    pub fn new() -> Self { Self { a:1, d:0 } }
    pub fn value(&self) -> u32 { (self.d << 16) | self.a }

    /// Combine la somme Adler de [part1] (adler1) avec celle de [part2] (adler2) connaissant len2.
    /// Utile pour concaténer des segments pré-hashés sans rebalayer les octets.
    pub fn combine(adler1: u32, len2: usize, adler2: u32) -> u32 {
        const BASE: u32 = 65521;
        let a1 = adler1 & 0xFFFF; let d1 = adler1 >> 16;
        let a2 = adler2 & 0xFFFF; let d2 = adler2 >> 16;
        let len2m = (len2 as u32) % BASE;
        let a = (a1 + a2 + BASE - 1) % BASE;
        let d = (d1 + d2 + len2m.wrapping_mul(a1)) % BASE;
        (d << 16) | a
    }
}
impl Hasher32 for Adler32 {
    fn update(&mut self, bytes: &[u8]) {
        for &x in bytes {
            self.a = (self.a + x as u32) % 65521;
            self.d = (self.d + self.a) % 65521;
        }
    }
    fn finish(&self) -> u32 { (self.d << 16) | self.a }
    fn reset(&mut self) { self.a = 1; self.d = 0; }
}

/* — Murmur3-32 (stream) — */

pub struct Murmur3_32 {
    seed: u32,
    h: u32,
    len: u32,
    tail: [u8; 3], // buffer des <4 octets en attente
    tail_len: usize,
}
impl Murmur3_32 {
    pub fn new(seed: u32) -> Self {
        Self { seed, h: seed, len: 0, tail: [0;3], tail_len: 0 }
    }
}
impl Hasher32 for Murmur3_32 {
    fn update(&mut self, mut b: &[u8]) {
        let c1: u32 = 0xcc9e2d51; let c2: u32 = 0x1b873593;

        // compléter le tail si on peut former un bloc de 4
        if self.tail_len > 0 {
            let need = 4 - self.tail_len;
            if b.len() >= need {
                let mut block = [0u8; 4];
                // tail existant
                let mut i = 0; while i < self.tail_len { block[i] = self.tail[i]; i += 1; }
                // compléter depuis b
                let mut j = 0; while j < need { block[self.tail_len + j] = b[j]; j += 1; }
                b = &b[need..];
                self.tail_len = 0;

                let mut k = u32::from_le_bytes(block);
                k = k.wrapping_mul(c1); k = k.rotate_left(15); k = k.wrapping_mul(c2);
                self.h ^= k; self.h = self.h.rotate_left(13);
                self.h = self.h.wrapping_mul(5).wrapping_add(0xe6546b64);
                self.len = self.len.wrapping_add(4);
            } else {
                // pas assez : juste stocker
                let mut j = 0; while j < b.len() { self.tail[self.tail_len + j] = b[j]; j += 1; }
                self.tail_len += b.len();
                return;
            }
        }

        // blocs de 4
        let mut i = 0usize;
        while i + 4 <= b.len() {
            let mut k = u32::from_le_bytes([b[i], b[i+1], b[i+2], b[i+3]]);
            k = k.wrapping_mul(c1); k = k.rotate_left(15); k = k.wrapping_mul(c2);
            self.h ^= k; self.h = self.h.rotate_left(13);
            self.h = self.h.wrapping_mul(5).wrapping_add(0xe6546b64);
            self.len = self.len.wrapping_add(4);
            i += 4;
        }
        // tail restant
        let rem = &b[i..];
        let rlen = rem.len().min(3);
        let mut j = 0; while j < rlen { self.tail[j] = rem[j]; j += 1; }
        self.tail_len = rlen;
    }

    fn finish(&self) -> u32 {
        let c1: u32 = 0xcc9e2d51; let c2: u32 = 0x1b873593;
        let mut h = self.h;

        // traiter le tail
        let mut k: u32 = 0;
        if self.tail_len >= 3 { k ^= (self.tail[2] as u32) << 16; }
        if self.tail_len >= 2 { k ^= (self.tail[1] as u32) << 8; }
        if self.tail_len >= 1 {
            k ^= self.tail[0] as u32;
            k = k.wrapping_mul(c1); k = k.rotate_left(15); k = k.wrapping_mul(c2);
            h ^= k;
        }

        h ^= (self.len as u32) + (self.tail_len as u32);
        fmix32(h)
    }

    fn reset(&mut self) {
        self.h = self.seed;
        self.len = 0;
        self.tail = [0;3];
        self.tail_len = 0;
    }
}

/* — FNV-1a 32 (stream) — */

pub struct Fnv1a32 {
    prime: u32,
    h: u32,
    seed: u32,
}
impl Fnv1a32 {
    pub fn new(seed: u32) -> Self {
        let basis = 0x811C9DC5 ^ seed;
        Self { prime: 16777619, h: basis, seed }
    }
}
impl Hasher32 for Fnv1a32 {
    fn update(&mut self, bytes: &[u8]) {
        for &x in bytes {
            self.h ^= x as u32;
            self.h = self.h.wrapping_mul(self.prime);
        }
    }
    fn finish(&self) -> u32 { self.h }
    fn reset(&mut self) { self.h = 0x811C9DC5 ^ self.seed; }
}

/* —————————————————————— API unifiée —————————————————————— */

pub enum Hash32 {
    Adler32,
    Murmur3_32 { seed: u32 },
    Fnv1a32   { seed: u32 },
}

/// One-shot : calcule directement un hash 32 bits d’un buffer.
pub fn hash32(algo: Hash32, data: &[u8]) -> u32 {
    match algo {
        Hash32::Adler32 => adler32(data),
        Hash32::Murmur3_32 { seed } => murmur3_32(data, seed),
        Hash32::Fnv1a32   { seed } => fnv1a32(data, seed),
    }
}

/// Hash d’un fichier (lecture en blocs).
pub fn hash_file(algo: Hash32, path: &str) -> Result<u32, str> {
    let bytes = std::fs::read(path).map_err(|e| format!("{}", e))?;
    Ok(hash32(algo, &bytes))
}

/* —————————————————————— Rolling Adler32 —————————————————————— */

/// RollingAdler32 — checksum glissant sur fenêtre de taille fixe.
/// Utilité : détecter des différences chunk par chunk (sync, dédoublonnage basique, etc.).
pub struct RollingAdler32 {
    s1: u32, s2: u32, win: std::collections::VecDeque<u8>, cap: usize,
}
impl RollingAdler32 {
    pub fn new(cap: usize) -> Self { Self{ s1:1, s2:0, win: std::collections::VecDeque::new(), cap: cap.max(1) } }

    /// Ajoute un octet en enlevant le plus ancien si la fenêtre est pleine.
    pub fn roll(&mut self, b: u8) {
        const BASE: u32 = 65521;
        if self.win.len() == self.cap {
            let out = self.win.pop_front().unwrap();
            // enlever out : s1 = s1 - out ; s2 = s2 - (window_len * out)
            self.s1 = (self.s1 + BASE - (out as u32 % BASE)) % BASE;
            self.s2 = (self.s2 + BASE - ((self.win.len() as u32 + 1) * (out as u32 % BASE)) % BASE) % BASE;
        }
        self.win.push_back(b);
        self.s1 = (self.s1 + (b as u32)) % BASE;
        self.s2 = (self.s2 + self.s1) % BASE;
    }
    pub fn value(&self) -> u32 { (self.s2 << 16) | self.s1 }
    pub fn len(&self) -> usize { self.win.len() }
}

/* —————————————————————— Utilitaires —————————————————————— */

fn fmix32(mut h: u32) -> u32 {
    h ^= h >> 16; h = h.wrapping_mul(0x85ebca6b);
    h ^= h >> 13; h = h.wrapping_mul(0xc2b2ae35);
    h ^= h >> 16; h
}

/* —————————————————————— Mini auto-tests (doc) —————————————————————— */
//! fn _doc_test() {
//!     let data = b"The quick brown fox jumps over the lazy dog";
//!
//!     // One-shot vs streaming (Murmur3)
//!     let one = murmur3_32(data, 0);
//!     let mut st = Murmur3_32::new(0);
//!     st.update(data);
//!     let two = st.finish();
//!     assert(one == two);
//!
//!     // One-shot vs streaming (Adler)
//!     let a1 = adler32(data);
//!     let mut a = Adler32::new();
//!     a.update(data);
//!     assert(a1 == a.finish());
//!
//!     // Combine : [left || right] == combine(hash(left), len(right), hash(right))
//!     let left = &data[..20]; let right = &data[20..];
//!     let adl = adler32(left); let adr = adler32(right);
//!     let combined = Adler32::combine(adl, right.len(), adr);
//!     let full = adler32(data);
//!     assert(combined == full);
//! }
