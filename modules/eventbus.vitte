//! eventbus.vitte — bus pub/sub en mémoire, wildcard, groupes, sticky/replay, request/reply.
//!
//! ✨ Features
//! - `publish(topic, payload)` diffuse aux abonnés dont le pattern matche (exact ou préfixe+"*").
//! - `subscribe(pattern, SubOptions)` → `Subscription` avec `recv/recv_timeout/try_recv/close`.
//! - Groupes : `opts.group=Some("workers")` → un seul abonné du groupe reçoit chaque event (RR).
//! - Sticky & Replay : `opts.sticky=true` (dernier event du topic), `opts.replay=n` (N derniers).
//! - Files d’abonnés bornées (capacité) + politique `DropOldest`/`DropNewest` (par défaut: oldest).
//! - `once=true` : se désinscrit après le premier event reçu.
//! - `filter` : fn(&Event)->bool côté abonnement.
//! - `request(topic,payload,timeout_ms)` : RPC léger via topic de réponse éphémère.
//! - Retain global : `retain(n)` conserve N derniers events par topic (pour replay).
//!
//! ⚠ Non-crypto, non-durable (mémoire). Conçu pour process unique.

#![version("0.2.0")]
#![strict]

use std::collections::{Map, Set, VecDeque};
use std::sync::{Mutex, Condvar, AtomicBool};
use std::cell::RefCell;
use std::rc::Rc;

/* ———————————————————— Modèles ———————————————————— */

pub struct Event {
    pub topic: str,
    pub data: std::json::Value,
    pub ts_ms: u64,
    pub meta: Map<str,str>,          // ex: reply_to, key, headers…
}
impl Clone for Event {
    fn clone(&self)->Self{
        Self{ topic:self.topic.clone(), data:self.data.clone(), ts_ms:self.ts_ms, meta:self.meta.clone() }
    }
}

pub enum DropPolicy { DropOldest, DropNewest }

/* ———————————————————— Boîte aux lettres d’un abonné ———————————————————— */

struct Mailbox<T> {
    q: VecDeque<T>,
    cap: usize,
    drop: DropPolicy,
    mu: Mutex<()>,
    cv: Condvar,
    closed: AtomicBool,
}
impl<T> Mailbox<T> {
    fn new(cap:usize, drop:DropPolicy)->Self{
        Self{ q:VecDeque::new(), cap:cap.max(1), drop, mu:Mutex::new(()), cv:Condvar::new(), closed:AtomicBool::new(false) }
    }
    fn push(&self, v:T)->bool{
        if self.closed.load(){ return false; }
        let _g=self.mu.lock();
        if self.q.len()>=self.cap {
            match self.drop {
                DropPolicy::DropOldest => { let _=self.q.pop_front(); }
                DropPolicy::DropNewest => { return true; } // on jette le nouveau
            }
        }
        self.q.push_back(v); self.cv.notify_one(); true
    }
    fn try_pop(&self)->Option<T>{
        let _g=self.mu.lock();
        self.q.pop_front()
    }
    fn pop_timeout(&self, timeout_ms:u64)->Option<T>{
        let g=self.mu.lock(); let mut g=g;
        let start=std::time::now().unix_millis() as u64;
        loop{
            if let Some(v)=self.q.pop_front(){ return Some(v); }
            if self.closed.load(){ return None; }
            let now=std::time::now().unix_millis() as u64;
            let remain=if now>start { timeout_ms.saturating_sub(now-start) } else { timeout_ms };
            if remain==0 { return None; }
            g=self.cv.wait_timeout(&g, remain as i64);
        }
    }
    fn close(&self){ self.closed.store(true); self.cv.notify_all(); }
    fn len(&self)->usize{ let _g=self.mu.lock(); self.q.len() }
}

/* ———————————————————— Abonnement & options ———————————————————— */

pub struct SubOptions {
    pub group: Option<str>,                 // load-balancing au sein d’un groupe
    pub sticky: bool,                       // rejouer le dernier event (si exact topic)
    pub replay: usize,                      // rejouer N derniers (global retain doit être >0)
    pub once: bool,                         // auto-unsubscribe après 1 event livré
    pub capacity: usize,                    // file interne
    pub drop: DropPolicy,                   // politique en overflow
    pub filter: Option<fn(&Event)->bool>,   // filtre additionnel
}
impl SubOptions {
    pub fn default()->Self{
        Self{ group:None, sticky:false, replay:0, once:false, capacity:1024, drop:DropPolicy::DropOldest, filter:None }
    }
}

pub struct Subscription {
    id: u64,
    mb: Rc<Mailbox<Event>>,
    bus: Rc<RefCell<Inner>>,
}
impl Subscription {
    pub fn try_recv(&self)->Option<Event>{ self.mb.try_pop() }
    pub fn recv_timeout(&self, timeout_ms:u64)->Option<Event>{ self.mb.pop_timeout(timeout_ms) }
    pub fn close(&self){ self.mb.close(); self.bus.borrow_mut().unsubscribe(self.id); }
    pub fn len(&self)->usize{ self.mb.len() }
}
impl Drop for Subscription {
    fn drop(&mut self){ self.mb.close(); self.bus.borrow_mut().unsubscribe(self.id); }
}

/* ———————————————————— EventBus ———————————————————— */

pub struct EventBus {
    inner: Rc<RefCell<Inner>>,
}
struct Inner {
    next_id: u64,
    subs: Map<u64, SubEntry>,             // id -> SubEntry
    retain_n: usize,
    last: Map<str, Event>,                // dernier par topic
    history: Map<str, VecDeque<Event>>,   // N derniers par topic
    rr: Map<str, u64>,                    // round-robin index par nom de groupe
}
struct SubEntry {
    id: u64,
    pattern: str,                         // "topic" exact ou "prefix.*"
    wildcard: bool,                       // vrai si pattern termine par '*'
    group: Option<str>,
    once: bool,
    filter: Option<fn(&Event)->bool>,
    mb: Rc<Mailbox<Event>>,
}

impl EventBus {
    pub fn new()->Self{
        Self{ inner: Rc::new(RefCell::new(Inner{
            next_id:1, subs:Map::new(), retain_n:0, last:Map::new(), history:Map::new(), rr:Map::new()
        })) }
    }

    /// Définit la profondeur de rétention globale (pour replay). 0 = off
    pub fn retain(&self, n:usize)->&Self{ self.inner.borrow_mut().retain_n=n; self }

    /// Abonne sur un pattern ("topic" ou "prefix.*") avec options. Retourne un handle `Subscription`.
    pub fn subscribe(&self, pattern: str, opts: SubOptions)->Subscription{
        let wildcard = pattern.ends_with('*');
        let mut inn = self.inner.borrow_mut();
        let id = inn.next_id; inn.next_id+=1;
        let mb = Rc::new(Mailbox::<Event>::new(opts.capacity, opts.drop));
        let se = SubEntry{
            id, pattern:pattern.clone(), wildcard,
            group:opts.group.clone(), once:opts.once,
            filter:opts.filter, mb:mb.clone(),
        };
        inn.subs.insert(id, se);

        // Sticky: si pattern exact → renvoyer le dernier éventuel
        if opts.sticky && !wildcard {
            if let Some(ev)=inn.last.get(&pattern).cloned() { let _=mb.push(ev); }
        }
        // Replay N: si demandé, rejouer les N derniers (si retain_n>0)
        if opts.replay>0 && inn.retain_n>0 {
            let topic = if wildcard { pattern[..pattern.len()-1].to_string() } else { pattern.clone() };
            // pour wildcard, on rejoue par topic qui matche le préfixe
            let mut pushed=0usize;
            for (t, buf) in inn.history.iter() {
                if matches(&pattern, t) {
                    // du plus ancien au plus récent
                    let start = if buf.len()>opts.replay { buf.len()-opts.replay } else { 0 };
                    let mut i=start;
                    while i<buf.len() { let _=mb.push(buf[i].clone()); i+=1; pushed+=1; }
                }
            }
        }

        Subscription{ id, mb, bus:self.inner.clone() }
    }

    /// Publication. Renvoie le nombre d’abonnés effectivement servis.
    pub fn publish(&self, topic: str, data: std::json::Value)->u32{
        self.publish_meta(topic, data, Map::new())
    }

    /// Publication avec meta (ex: reply_to).
    pub fn publish_meta(&self, topic: str, data: std::json::Value, meta: Map<str,str>)->u32{
        let mut inn = self.inner.borrow_mut();
        let ev = Event{ topic: topic.clone(), data, ts_ms: std::time::now().unix_millis() as u64, meta };
        // Retain
        inn.last.insert(topic.clone(), ev.clone());
        if inn.retain_n>0 {
            let buf = inn.history.entry(topic.clone()).or_insert(VecDeque::new());
            buf.push_back(ev.clone());
            while buf.len()>inn.retain_n { let _=buf.pop_front(); }
        }

        // Répartition
        // 1) collecter subs matching
        let mut direct:Vec<&SubEntry> = Vec::new();
        let mut grouped: Map<str, Vec<&SubEntry>> = Map::new();

        for (_, s) in inn.subs.iter() {
            if matches(&s.pattern, &topic) {
                if let Some(f)=s.filter { if !f(&ev) { continue; } }
                if let Some(g)=&s.group {
                    grouped.entry(g.clone()).or_insert(Vec::new()).push(s);
                } else {
                    direct.push(s);
                }
            }
        }

        let mut served=0u32;

        // 2) diffuser aux non groupés
        for s in direct.iter() {
            if s.mb.push(ev.clone()) { served+=1; }
        }

        // 3) diffuser aux groupes (RR)
        for (g, vecs) in grouped.iter() {
            if vecs.is_empty(){ continue; }
            let idx = (inn.rr.get(g).cloned().unwrap_or(0) as usize) % vecs.len();
            inn.rr.insert(g.clone(), (idx as u64 + 1));
            let target = vecs[idx];
            if target.mb.push(ev.clone()) { served+=1; }
        }

        // 4) gérer `once`: collecter ceux servis à désinscrire
        let mut to_drop:Vec<u64> = Vec::new();
        for s in direct.iter() {
            if s.once { to_drop.push(s.id); }
        }
        for (_, vecs) in grouped.iter() {
            for s in vecs.iter() {
                if s.once { to_drop.push(s.id); }
            }
        }
        for id in to_drop { inn.unsubscribe(id); }

        served
    }

    /// RPC léger : envoie une requête et attend une réponse via topic éphémère.
    pub fn request(&self, topic: str, data: std::json::Value, timeout_ms:u64) -> Option<Event> {
        let rep = format!("_reply.{}", std::rand::u32());
        let mut meta = Map::new(); meta.insert("reply_to".into(), rep.clone());
        // sub one-shot
        let sub = self.subscribe(rep.clone(), SubOptions::default().once(true).capacity(16));
        let _ = self.publish_meta(topic, data, meta);
        sub.recv_timeout(timeout_ms)
    }

    pub fn close(&self){
        let mut inn=self.inner.borrow_mut();
        let ids:Vec<u64> = inn.subs.keys().cloned().collect();
        for id in ids { if let Some(s)=inn.subs.get(&id){ s.mb.close(); } }
        inn.subs.clear();
    }
}

/* ———————————————————— Impl internes ———————————————————— */

impl Inner {
    fn unsubscribe(&mut self, id:u64){
        if let Some(se)=self.subs.remove(&id) {
            se.mb.close();
        }
    }
}

/* ———————————————————— Match pattern ———————————————————— */

fn matches(pattern:&str, topic:&str)->bool{
    if pattern.ends_with('*') {
        let p=&pattern[..pattern.len()-1];
        topic.starts_with(p)
    } else { pattern==topic }
}

/* ———————————————————— Doc-test / smoke ———————————————————— */
//! fn _smoke_bus() {
//!     let bus = EventBus::new().retain(8);
//!     // Subscriber direct
//!     let sub = bus.subscribe("users.created".into(), SubOptions::default().sticky(false));
//!     // Groupe : 2 workers, un seul recevra chaque event
//!     let w1 = bus.subscribe("jobs.*".into(), SubOptions::default().group(Some("workers")).capacity(32));
//!     let w2 = bus.subscribe("jobs.*".into(), SubOptions::default().group(Some("workers")).capacity(32));
//!
//!     // Publish
//!     let mut meta = std::collections::Map::new(); meta.insert("key".into(),"u123".into());
//!     let n = bus.publish_meta("users.created".into(), std::json::Value::String("Ada".into()), meta);
//!     assert(n>=1);
//!
//!     // One-shot request/reply
//!     let ans = bus.request("ping".into(), std::json::Value::String("hello".into()), 200);
//!     assert(ans.is_none()); // sauf si quelqu'un répond au topic "ping"
//!
//!     // Lecture
//!     let evt = sub.recv_timeout(10).unwrap();
//!     assert(evt.topic=="users.created");
//!
//!     // Workers RR
//!     let _ = bus.publish("jobs.queue".into(), std::json::Value::Null);
//!     let a = w1.try_recv().is_some() as i32 + w2.try_recv().is_some() as i32;
//!     assert(a==1);
//! }
