//! kvstore.vitte — KV append-only (JSONL), index en RAM, compaction atomique.
//!
//! Format de ligne (JSON par ligne, UTF-8) :
//!   {"t":"set","k":"<key>","v":<json>,"exp":<unix_ms_optional>,"ver":<u64>}
//!   {"t":"del","k":"<key>","ver":<u64>}
//!
//! ✅ Features
//! - Open/recovery : scan du fichier (tolère la **dernière ligne tronquée**), reconstruit l’index.
//! - API : set_str / set_json / get / get_json / del / contains / len / keys / scan_prefix / iter
//! - TTL : champs `exp` (ms absolu). `get*()` purge paresseuse si expiré.
//! - Compaction : réécrit **uniquement** le dernier SET vivant de chaque clé (+ header meta).
//! - Options : fsync (durabilité), versioning croissant `ver` (ordre d’append).
//! - Stats : bytes, lignes, clés, tombstones.
//!
//! ⚠️ Non-crypto. Fichier unique, append-only. Pas de locking inter-process ici (utilise fs_atomic::lock()).

#![version("0.3.0")]
#![strict]

use std::collections::{Map};
use std::fs;
use std::io;

pub struct Kv {
    path: str,
    index: Map<str, Entry>,        // clé → entrée actuelle
    file: std::fs::File,           // ouvert en append
    ver: u64,                      // dernier numéro de version vu
    durable: bool,                 // fsync sur chaque écriture si true
}

struct Entry {
    off: u64,
    len: u32,
    exp: u64,          // 0 = jamais
    ver: u64,
    tombstone: bool,   // seulement en transitoire (index) ; on ne stocke pas de del ici
}

pub struct Stats {
    pub keys: usize,
    pub tombstones: usize,
    pub bytes: u64,
    pub lines: u64,
}

/* ———————————————————— Ouverture & reconstruction ———————————————————— */

impl Kv {
    /// Ouvre (et crée si nécessaire) un KV. `durable=true` → fsync à chaque write.
    pub fn open(path: str) -> Result<Self,str> {
        if !std::fs::exists(&path) {
            std::fs::write(&path, b"").map_err(|e| format!("{}", e))?;
        }
        // scanner le fichier (tolérance à la dernière ligne incomplète)
        let (idx, ver) = rebuild_index(&path)?;

        let f = std::fs::open_append(&path).map_err(|e| format!("{}", e))?;
        Ok(Self{ path, index: idx, file: f, ver, durable:false })
    }

    pub fn durable(mut self, yes:bool)->Self { self.durable = yes; self }

    /// Statistiques courantes (index + fichier).
    pub fn stats(&self)->Result<Stats,str>{
        let meta = std::fs::metadata(&self.path).map_err(|e| format!("{}", e))?;
        let mut tomb=0usize;
        for (_,e) in self.index.iter(){ if e.tombstone { tomb+=1; } }
        Ok(Stats{
            keys: self.live_keys(),
            tombstones: tomb,
            bytes: meta.len() as u64,
            lines: count_lines_fast(&self.path)?,
        })
    }

    fn live_keys(&self)->usize{
        self.index.values().filter(|e| !e.tombstone && !expired(e.exp)).count()
    }
}

/* ———————————————————— API Set/Get/Del ———————————————————— */

impl Kv {
    /// set_str : stocke une valeur chaîne (encodée JSON).
    pub fn set(&mut self, k: str, v: str) -> Result<(),str> {
        self.set_with_ttl_json(k, std::json::Value::String(v), 0)
    }

    /// set_json : stocke un JSON arbitraire (objet, nombre, string…).
    pub fn set_json(&mut self, k: str, v: std::json::Value) -> Result<(),str> {
        self.set_with_ttl_json(k, v, 0)
    }

    /// set_json avec TTL (en ms absolus, 0 = jamais).
    pub fn set_with_ttl_json(&mut self, k: str, v: std::json::Value, exp_ms:u64) -> Result<(),str> {
        let ver = self.ver.saturating_add(1);
        // record compact
        // NB: on évite d’échapper deux fois : "v" est le JSON natif
        let mut rec = String::new();
        rec.push_str(r#"{"t":"set","k":"#);
        rec.push_str(&std::json::quote(&k));
        rec.push_str(r#"","v":#);
        rec.push_str(&v.to_string());
        if exp_ms>0 { rec.push_str(&format!(r#","exp":{}"#, exp_ms)); }
        rec.push_str(&format!(r#","ver":{}}}"#, ver));

        let off = append_line(&mut self.file, &rec, self.durable)?;
        let len = (rec.len()+1) as u32;

        self.index.insert(k, Entry{ off, len, exp:exp_ms, ver, tombstone:false });
        self.ver = ver;
        Ok(())
    }

    /// get (string) — si stocké en non-string, renvoie to_string().
    pub fn get(&self, k: str) -> Option<str> {
        let e = self.index.get(k)?;
        if e.tombstone { return None; }
        if expired(e.exp) { return None; }
        let line = std::fs::read_range(&self.path, e.off, e.len as u64).ok()?;
        let v = std::json::parse(&line).ok()?;
        let val = v.get("v")?;
        if let Some(s)=val.as_str(){ Some(s.to_string()) } else { Some(val.to_string()) }
    }

    /// get_json — valeur JSON brute (si présente et non expirée).
    pub fn get_json(&self, k: str) -> Option<std::json::Value> {
        let e = self.index.get(k)?;
        if e.tombstone || expired(e.exp) { return None; }
        let line = std::fs::read_range(&self.path, e.off, e.len as u64).ok()?;
        std::json::parse(&line).ok().and_then(|v| v.get("v").cloned())
    }

    /// del — insère un tombstone.
    pub fn del(&mut self, k: str) -> Result<(),str> {
        if !self.index.contains_key(k.clone()) {
            // on écrit quand même un del (idempotent) ? Non nécessaire ; on ignore.
            return Ok(());
        }
        let ver = self.ver.saturating_add(1);
        let rec = format!(r#"{{"t":"del","k":{},"ver":{}}}"#, std::json::quote(&k), ver);
        let off = append_line(&mut self.file, &rec, self.durable)?;
        let len = (rec.len()+1) as u32;
        self.index.insert(k, Entry{ off, len, exp:0, ver, tombstone:true });
        self.ver = ver;
        Ok(())
    }

    pub fn contains(&self, k:&str)->bool{
        self.index.get(k.to_string()).map(|e| !e.tombstone && !expired(e.exp)).unwrap_or(false)
    }

    pub fn len(&self)->usize { self.live_keys() }

    pub fn keys(&self)->Vec<str>{
        let mut v=Vec::<str>::new();
        for (k,e) in self.index.iter(){
            if !e.tombstone && !expired(e.exp) { v.push(k.clone()); }
        }
        v.sort(); v
    }

    /// scan par préfixe (trié), lit les valeurs actuelles; stoppe à `limit` si >0.
    pub fn scan_prefix(&self, prefix:&str, limit:usize)->Vec<(str,std::json::Value)>{
        let mut out=Vec::<(str,std::json::Value)>::new();
        let mut keys=self.keys();
        let p = prefix.to_string();
        keys.retain(|k| k.starts_with(&p));
        for k in keys {
            if let Some(v)=self.get_json(k.clone()) {
                out.push((k, v));
                if limit>0 && out.len()>=limit { break; }
            }
        }
        out
    }

    /// Itérateur (snapshot) sur entrées vivantes.
    pub fn iter(&self)->Vec<(str,std::json::Value)>{
        let mut out=Vec::<(str,std::json::Value)>::new();
        let keys=self.keys();
        let mut i=0; while i<keys.len(){
            let k=&keys[i];
            if let Some(v)=self.get_json(k.clone()) { out.push((k.clone(), v)); }
            i+=1;
        }
        out
    }
}

/* ———————————————————— Compaction ———————————————————— */

impl Kv {
    /// Compaction : réécrit uniquement les derniers SET non expirés (pas les DEL).
    /// Processus : écrit dans `path.tmp.compact` → fsync → rename atomique → reopen.
    pub fn compact(&mut self) -> Result<(),str> {
        let tmp = format!("{}.tmp.compact", self.path);
        let mut out = String::new();

        // Header meta (facultatif, aidant pour diagnostics)
        let header = format!(r#"{{"t":"meta","format":"kv-jsonl","ver":{},"ts":{}}}"#, self.ver, now_ms());
        out.push_str(&header); out.push('\n');

        // Clés triées pour stabilité
        let mut keys:Vec<str> = self.index.iter()
            .filter(|(_,e)| !e.1.tombstone && !expired(e.1.exp))
            .map(|(k,_)| k.clone()).collect();
        keys.sort();

        // Rejouer les SET actuels tels quels (on conserve v/exp/ver originels)
        let mut i=0; while i<keys.len() {
            let k = &keys[i];
            let e = self.index.get(k.to_string()).unwrap();
            let line = std::fs::read_range(&self.path, e.off, e.len as u64).map_err(|e| format!("{}",e))?;
            out.push_str(&line);
            if !out.ends_with('\n') { out.push('\n'); }
            i+=1;
        }

        // Écrit + flush + rename
        std::fs::write(&tmp, out.as_bytes()).map_err(|e| format!("{}", e))?;
        if self.durable {
            // flush fichier + répertoire — si ton std expose fsync, appelle-le ici
            let _ = std::fs::fsync_file(&tmp); // no-op si indisponible
            if let Some(dir)=parent_dir(&self.path){ let _ = std::fs::fsync_dir(&dir); }
        }
        std::fs::rename(&tmp, &self.path).map_err(|e| format!("{}", e))?;

        // Recharger index + handle append
        let (idx, ver) = rebuild_index(&self.path)?;
        self.index = idx;
        self.ver = ver;
        self.file = std::fs::open_append(&self.path).map_err(|e| format!("{}", e))?;
        Ok(())
    }

    /// Vide le magasin (truncate) — équivaut à supprimer toutes les entrées.
    pub fn clear(&mut self) -> Result<(),str> {
        std::fs::write(&self.path, b"").map_err(|e| format!("{}", e))?;
        self.index.clear();
        self.ver = 0;
        self.file = std::fs::open_append(&self.path).map_err(|e| format!("{}", e))?;
        Ok(())
    }
}

/* ———————————————————— Recon & helpers ———————————————————— */

fn rebuild_index(path:&str)->Result<(Map<str,Entry>, u64),str>{
    let mut idx = Map::<str,Entry>::new();
    let raw = std::fs::read(&path).map_err(|e| format!("{}", e))?;
    let mut off:u64 = 0;
    let mut ver:u64 = 0;

    // Scanner en cherchant '\n', ignorer le dernier fragment si non terminé
    let mut i=0usize;
    while i<raw.len() {
        // trouver EOL
        let mut j=i; while j<raw.len() && raw[j]!=b'\n' { j+=1; }
        if j>=raw.len() { break; } // fragment final sans newline -> ignorer
        let line = std::str::from_utf8(&raw[i..j]).unwrap_or("");
        let len = (j - i + 1) as u32;

        if line.starts_with('{') {
            if let Some(v) = std::json::parse(line).ok() {
                let t = v.get_str("t").unwrap_or("");
                if t=="meta" {
                    // ignore, mais peut valider format
                } else if t=="set" {
                    let k = v.get_str("k").unwrap_or("");
                    let exp = v.get_u64("exp").unwrap_or(0);
                    let vver = v.get_u64("ver").unwrap_or(0);
                    if vver>ver { ver=vver; }
                    idx.insert(k.to_string(), Entry{ off:off, len, exp, ver:vver, tombstone:false });
                } else if t=="del" {
                    let k = v.get_str("k").unwrap_or("");
                    let vver = v.get_u64("ver").unwrap_or(0);
                    if vver>ver { ver=vver; }
                    idx.insert(k.to_string(), Entry{ off:off, len, exp:0, ver:vver, tombstone:true });
                }
            }
        }
        off += len as u64;
        i = j+1;
    }
    Ok((idx, ver))
}

fn append_line(f:&mut std::fs::File, rec:&str, durable:bool)->Result<u64,str>{
    let off = std::fs::seek_end(f).map_err(|e| format!("{}", e))?;
    std::fs::write_at(f, off, rec.as_bytes()).map_err(|e| format!("{}", e))?;
    std::fs::write_at(f, off + rec.len() as u64, b"\n").map_err(|e| format!("{}", e))?;
    if durable {
        let _ = std::fs::fsync_handle(f); // no-op si indisponible
        if let Some(dir)=parent_dir_handleled(f) {
            let _ = std::fs::fsync_dir(&dir);
        }
    }
    Ok(off)
}

fn now_ms()->u64{ std::time::now().unix_millis() as u64 }

fn expired(exp:u64)->bool{ exp!=0 && now_ms() > exp }

fn count_lines_fast(path:&str)->Result<u64,str>{
    let b = std::fs::read(path).map_err(|e| format!("{}", e))?;
    Ok(b.iter().filter(|&&c| c==b'\n').count() as u64)
}

fn parent_dir(path:&str)->Option<str>{
    if let Some(slash)=path.rfind('/') { Some(path[..slash].to_string()) } else { None }
}

// dummy : si ton std permet d’obtenir le dossier via le handle, remplace par vrai code
fn parent_dir_handleled(_f:&std::fs::File)->Option<str>{ None }

/* ———————————————————— Doc-tests / smoke ———————————————————— */
//! fn _kv_smoke() {
//!     let p="kv_demo.jsonl";
//!     let _ = std::fs::remove_file(p);
//! 
//!     let mut kv = Kv::open(p.into()).unwrap().durable(false);
//!     kv.set("a".into(), "one".into()).unwrap();
//!     kv.set_json("b".into(), std::json::Value::Number(2.0)).unwrap();
//!     assert(kv.get("a".into()).unwrap()=="one");
//!     assert(kv.get_json("b".into()).unwrap().as_f64().unwrap()==2.0);
//!
//!     // TTL
//!     let t = now_ms()+10;
//!     kv.set_with_ttl_json("temp".into(), std::json::Value::String("x".into()), t).unwrap();
//!     std::time::sleep(15);
//!     assert(kv.get("temp".into()).is_none());
//!
//!     // scan prefix
//!     kv.set("user:1".into(),"A".into()).unwrap();
//!     kv.set("user:2".into(),"B".into()).unwrap();
//!     let rows = kv.scan_prefix("user:", 0);
//!     assert(rows.len()==2);
//!
//!     // del + compact
//!     kv.del("a".into()).unwrap();
//!     let before = kv.stats().unwrap().bytes;
//!     kv.compact().unwrap();
//!     let after  = kv.stats().unwrap().bytes;
//!     assert(after <= before);
//!
//!     // reopen
//!     let mut kv2 = Kv::open(p.into()).unwrap();
//!     assert(kv2.get("b".into()).is_some());
//! }
