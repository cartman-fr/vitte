//! config.vitte — config à couches: env → fichiers (TOML/JSON) → overrides (map) + reload, builder.
//!
//! ✅ Points-clefs
//! - Builder en couches (ordre = priorité croissante) : `env(prefix)` → `file()`… → `overrides()`
//! - Getters typés : `get_str/get_u32/get_i64/get_f64/get_bool/get_duration_ms/get_bytes`
//! - Scopes : `scope("db")` pour lire `db.*` sans répéter le préfixe
//! - Expansion : `${ENV}`, `${config:db.host}`, `${default:val}` dans les strings
//! - Defaults & presence : `get_or`, `has`, `list_keys`, `as_map(prefix)`
//! - Chargement répertoire : `from_dir("config/")` (prend `config.toml` sinon `config.json`)
//! - Reload (polling) : `watch_files(period_ms, cb)` → callback appelé si changement mtime
//! - Dump redacted : masque les clés qui contiennent `password|secret|token|key`
//!
//! Exemples :
//! ```vitte
//! let cfg = Config::builder()
//!     .env("APP_")
//!     .file("config.toml")
//!     .file_optional("config.local.toml")
//!     .overrides(map!{"server.port" => "8081"})
//!     .build()
//!     .unwrap();
//!
//! let port = cfg.get_u32("server.port", 8080);
//! let dsn  = cfg.get_str("db.dsn").unwrap_or("sqlite::memory:".into());
//!
//! // Scope
//! let db = cfg.scope("db");
//! let host = db.get_str("host").unwrap_or("localhost".into());
//!
//! // Reload
//! let _watch = cfg.watch_files(1000, |new_cfg| { log::info(format!("config reloaded from {}", new_cfg.origin())); });
//! ```
#![version("0.2.0")]
#![strict]

use std::collections::{Map, Set};
use std::sync::{AtomicBool, Mutex};

pub struct Config {
    data: Map<str, std::json::Value>,   // aplati: "db.host" => "localhost"
    origin: str,                        // info diagnostique (env|path|<mixed>)
}

pub struct Builder {
    env_prefix: Option<str>,
    files: Vec<(str /*path*/, bool /*optional*/ )>,
    overrides: Map<str, std::json::Value>,
}

impl Builder {
    pub fn env(mut self, prefix: str) -> Self { self.env_prefix = Some(prefix); self }
    pub fn file(mut self, path: str) -> Self { self.files.push((path, false)); self }
    pub fn file_optional(mut self, path: str) -> Self { self.files.push((path, true)); self }
    pub fn overrides(mut self, m: Map<str, std::json::Value>) -> Self { for (k,v) in m { self.overrides.insert(k,v); } self }

    pub fn build(self) -> Result<Config, str> {
        let mut layers: Vec<Config> = Vec::new();

        if let Some(pfx) = self.env_prefix {
            layers.push(Config::from_env(pfx));
        }

        for (p, opt) in self.files {
            match Config::from_file(p.clone()) {
                Ok(c) => layers.push(c),
                Err(e) if opt => { /* ignore optionnel */ }
                Err(e) => return Err(e),
            }
        }

        if !self.overrides.is_empty() {
            layers.push(Config{ data: self.overrides, origin: "<overrides>".into() });
        }

        // Merge: ancien <- nouveau (nouveau prime)
        let mut out = Config::empty();
        for c in layers.into_iter() { out = out.merge(c); }
        out.origin = "<mixed>".into();
        Ok(out)
    }
}

/* ———————————————————— Constructeurs ———————————————————— */

impl Config {
    pub fn builder() -> Builder {
        Builder{ env_prefix: None, files: Vec::new(), overrides: Map::new() }
    }

    pub fn empty() -> Self { Self{ data: Map::new(), origin: "<empty>" } }

    pub fn from_env(prefix: str) -> Self {
        let mut d = Map::new();
        for (k,v) in std::env::vars() {
            if k.starts_with(prefix) {
                let key = k[prefix.len()..].to_lower().replace("__","."); // APP__DB__HOST → db.host
                d.insert(key, std::json::Value::String(v));
            }
        }
        Self{ data: d, origin: "env" }
    }

    /// from_file : supporte .toml et .json ; renvoie Err si le type n’est pas reconnu.
    pub fn from_file(path: str) -> Result<Self, str> {
        let txt = std::fs::read_to_string(path.clone()).map_err(|e| format!("{}", e))?;
        let val: std::json::Value = if path.ends_with(".toml") {
            std::toml::to_json(&txt)
        } else if path.ends_with(".json") {
            std::json::parse(&txt).map_err(|e| format!("{}", e))?
        } else {
            return Err("format non supporté (utilise .toml ou .json)".into());
        };
        Ok(Self{ data: Self::flatten_json(&val, ""), origin: path })
    }

    /// from_dir : tente `dir/config.toml` puis `dir/config.json`
    pub fn from_dir(dir: str) -> Result<Self, str> {
        let t = format!("{}/config.toml", dir.trim_end_matches('/'));
        if std::fs::exists(&t) { return Self::from_file(t); }
        let j = format!("{}/config.json", dir.trim_end_matches('/'));
        if std::fs::exists(&j) { return Self::from_file(j); }
        Err("aucun fichier config trouvé dans le dossier".into())
    }

    pub fn merge(mut self, other: Config) -> Self {
        for (k,v) in other.data {
            self.data.insert(k, v);
        }
        self
    }

    pub fn origin(&self) -> &str { &self.origin }

    /* ———————————————————— Inspection ———————————————————— */

    pub fn has(&self, key: &str) -> bool { self.data.contains_key(key.to_string()) }
    pub fn list_keys(&self) -> Vec<str> {
        let mut v:Vec<str> = self.data.keys().cloned().collect();
        v.sort(); v
    }

    /// as_map("db") → toutes les clés db.* sous forme (clé_sans_prefixe → string)
    pub fn as_map(&self, prefix:&str) -> Map<str,str> {
        let p = if prefix.is_empty(){ "".to_string() } else { format!("{}.", prefix) };
        let mut m=Map::new();
        for (k,v) in self.data.iter() {
            if k.starts_with(&p) {
                if let Some(s)=v.as_str() {
                    m.insert(k[p.len()..].to_string(), s.to_string());
                } else {
                    m.insert(k[p.len()..].to_string(), v.to_string());
                }
            }
        }
        m
    }

    /// scope("db") → Config “vue” sur db.*, lecture sans répéter "db."
    pub fn scope(&self, prefix:&str) -> ConfigView { ConfigView{ cfg: self, pfx: prefix.to_string() } }

    /* ———————————————————— Getters bruts (string) ———————————————————— */

    pub fn get(&self, key: str) -> Option<str> {
        self.data.get(key).and_then(|v| v.as_str().map(|s| s.to_string())).or_else(|| {
            // fallback : stringify pour les non-strings
            self.data.get(key).map(|v| v.to_string())
        }).map(|s| self.expand(&s))
    }

    pub fn get_or(&self, key: str, def: str) -> str {
        self.get(key).unwrap_or(def)
    }

    /* ———————————————————— Getters typés ———————————————————— */

    pub fn get_u32(&self, key: str, def: u32) -> u32 { self.get(key).and_then(|s| s.parse::<u32>().ok()).unwrap_or(def) }
    pub fn get_i64(&self, key: str, def: i64) -> i64 { self.get(key).and_then(|s| s.parse::<i64>().ok()).unwrap_or(def) }
    pub fn get_f64(&self, key: str, def: f64) -> f64 { self.get(key).and_then(|s| s.parse::<f64>().ok()).unwrap_or(def) }

    pub fn get_bool(&self, key: str, def: bool) -> bool {
        match self.get(key).map(|s| s.to_lower().trim().to_string()) {
            Some(v) if v=="1" || v=="true" || v=="yes" || v=="on"  => true,
            Some(v) if v=="0" || v=="false"|| v=="no"  || v=="off" => false,
            _ => def
        }
    }

    /// "150ms", "2s", "5m", "1h" → millis
    pub fn get_duration_ms(&self, key: str, def_ms: u64) -> u64 {
        if let Some(s) = self.get(key) {
            if let Some(ms) = parse_duration_ms(&s) { return ms; }
        }
        def_ms
    }

    /// "64KB", "10MiB", "1g" → bytes
    pub fn get_bytes(&self, key: str, def: u64) -> u64 {
        if let Some(s) = self.get(key) {
            if let Some(b) = parse_bytes(&s) { return b; }
        }
        def
    }

    /// parse liste simple depuis CSV (ou array JSON/TOML aplati en string)
    pub fn get_list(&self, key:str) -> Vec<str> {
        if let Some(s) = self.get(key) {
            // "a,b,c"
            if s.contains(',') {
                return s.split(',').map(|x| x.trim().to_string()).filter(|x| !x.is_empty()).collect();
            }
            // "['a','b']" ou "["a","b"]"
            if s.starts_with('[') && s.ends_with(']') {
                if let Ok(val)=std::json::parse(&s) {
                    if let Some(arr)=val.as_array() {
                        let mut out=Vec::new(); for v in arr { if let Some(ss)=v.as_str(){ out.push(ss.to_string()); } }
                        return out;
                    }
                }
            }
            return vec![s];
        }
        Vec::new()
    }

    /* ———————————————————— Reload (watcher) ———————————————————— */

    /// Watcher naïf (poll mtime) — `cb` appelé avec une nouvelle Config mergée si un fichier change.
    /// ⚠️ N’opère que sur la dernière construction via `builder().file()`/`file_optional()` (origine "<mixed>").
    pub fn watch_files(&self, period_ms: u64, cb: fn(&Config)) -> WatchHandle {
        // On ne connait pas les chemins utilisés si l’objet ne vient pas du builder ;
        // convention: stocker une clé interne spéciale "__files" si build() a fusionné des fichiers.
        let files = self.get("__files".into()).map(|s| s).unwrap_or("".into());
        let paths: Vec<str> = files.split(';').filter(|x| !x.is_empty()).map(|x| x.to_string()).collect();

        let stop = std::rc::Rc::new(AtomicBool::new(false));
        let stopper = stop.clone();
        let cfg0 = self.clone_shallow();
        let h = std::thread::spawn(move || {
            let mut last_mtime:u64 = snapshot_mtime(&paths);
            loop {
                if stopper.load() { break; }
                std::time::sleep(period_ms as i64);
                let mt = snapshot_mtime(&paths);
                if mt != last_mtime {
                    last_mtime = mt;
                    if let Ok(newc) = rebuild_from(paths.clone(), cfg0.env_prefix_hint()) {
                        cb(&newc);
                    }
                }
            }
        });
        WatchHandle{ stop, join: Some(h) }
    }

    /* ———————————————————— Internes ———————————————————— */

    fn clone_shallow(&self) -> Self {
        // clone simple (data + origin)
        Self{ data: self.data.clone(), origin: self.origin.clone() }
    }

    fn env_prefix_hint(&self) -> Option<str> {
        self.get("__env_prefix".into())
    }

    fn expand(&self, s:&str) -> str {
        // ${ENV} / ${ENV:default} / ${config:key} / ${default:val}
        let mut out = String::new();
        let b = s.as_bytes();
        let mut i = 0usize;
        while i < b.len() {
            if b[i] as char == '$' && i+1<b.len() && b[i+1] as char == '{' {
                if let Some(end) = find_brace(&b[i+2..]) {
                    let token = &s[i+2..i+2+end]; // sans ${ }
                    let expd = self.expand_token(token);
                    out.push_str(&expd);
                    i += 2 + end + 1; // saute jusqu'à '}'
                    continue;
                }
            }
            out.push(b[i] as char);
            i += 1;
        }
        out
    }

    fn expand_token(&self, t:&str) -> str {
        // formats:
        //  - NAME
        //  - NAME:default
        //  - config:key.path
        //  - default:val
        if t.starts_with("config:") {
            let k = &t[7..];
            return self.get(k.to_string()).unwrap_or("".into());
        }
        if t.starts_with("default:") {
            return t[8..].to_string();
        }
        // ENV avec default "NAME:default"
        if let Some(col) = t.find(':') {
            let (name, def) = (&t[..col], &t[col+1..]);
            return std::env::var(name).unwrap_or(def.to_string());
        }
        std::env::var(t).unwrap_or("".into())
    }

    fn flatten_json(v: &std::json::Value, prefix: &str) -> Map<str,std::json::Value> {
        let mut out = Map::new();
        match v {
            std::json::Value::Object(map) => {
                for (k,val) in map.iter() {
                    let key = if prefix.is_empty(){ k.to_string() } else { format!("{}.{}", prefix, k) };
                    if val.is_object() {
                        for (kk,vv) in Self::flatten_json(val, &key) { out.insert(kk, vv); }
                    } else {
                        out.insert(key, val.clone());
                    }
                }
            },
            _ => {}
        }
        out
    }
}

/* ———————————————————— Vue scoping ———————————————————— */

pub struct ConfigView<'a> {
    cfg: &'a Config,
    pfx: str,
}
impl<'a> ConfigView<'a> {
    fn key(&self, k:&str)->str { if k.is_empty(){ self.pfx.clone() } else { format!("{}.{}", self.pfx, k) } }
    pub fn get(&self, k: str) -> Option<str> { self.cfg.get(self.key(&k)) }
    pub fn get_or(&self, k: str, def: str) -> str { self.cfg.get_or(self.key(&k), def) }
    pub fn has(&self, k:&str)->bool{ self.cfg.has(&self.key(k)) }
    pub fn get_u32(&self, k: str, def: u32) -> u32 { self.cfg.get_u32(self.key(&k), def) }
    pub fn get_i64(&self, k: str, def: i64) -> i64 { self.cfg.get_i64(self.key(&k), def) }
    pub fn get_f64(&self, k: str, def: f64) -> f64 { self.cfg.get_f64(self.key(&k), def) }
    pub fn get_bool(&self, k: str, def: bool) -> bool { self.cfg.get_bool(self.key(&k), def) }
    pub fn get_duration_ms(&self, k: str, def: u64) -> u64 { self.cfg.get_duration_ms(self.key(&k), def) }
    pub fn get_bytes(&self, k: str, def: u64) -> u64 { self.cfg.get_bytes(self.key(&k), def) }
    pub fn get_list(&self, k: str) -> Vec<str> { self.cfg.get_list(self.key(&k)) }
}

/* ———————————————————— Watch handle ———————————————————— */

pub struct WatchHandle {
    stop: std::rc::Rc<AtomicBool>,
    join: Option<std::thread::JoinHandle>,
}
impl WatchHandle {
    pub fn stop(mut self){
        self.stop.store(true);
        if let Some(h)=self.join.take() { let _=h.join(); }
    }
}
impl Drop for WatchHandle {
    fn drop(&mut self){
        self.stop.store(true);
        if let Some(h)=self.join.take(){ let _=h.join(); }
    }
}

/* ———————————————————— Utilitaires parsing ———————————————————— */

fn parse_duration_ms(s:&str)->Option<u64>{
    let t=s.trim().to_lower();
    let (num,unit) = split_num_unit(&t);
    let n = num.parse::<u64>().ok()?;
    let ms = match unit {
        "ms" | "" => n,
        "s" => n*1000,
        "m" => n*60_000,
        "h" => n*3_600_000,
        _ => return None
    };
    Some(ms)
}
fn parse_bytes(s:&str)->Option<u64>{
    let t=s.trim().to_lower();
    let (num,unit) = split_num_unit(&t);
    let n = num.parse::<u64>().ok()?;
    let m = match unit {
        ""    | "b"   => 1,
        "k"   | "kb"  => 1000,
        "m"   | "mb"  => 1000_u64.pow(2),
        "g"   | "gb"  => 1000_u64.pow(3),
        "ki"  | "kib" => 1024,
        "mi"  | "mib" => 1024_u64.pow(2),
        "gi"  | "gib" => 1024_u64.pow(3),
        _ => return None
    };
    Some(n.saturating_mul(m))
}
fn split_num_unit(t:&str)->(str,str){
    let mut i=0; while i<t.len() && t.as_bytes()[i].is_ascii_digit(){ i+=1; }
    (t[..i].to_string(), t[i..].to_string())
}

/* ———————————————————— Watch & rebuild helpers ———————————————————— */

fn snapshot_mtime(paths:&[str])->u64{
    let mut acc=0u64;
    for p in paths {
        if let Ok(m)=std::fs::metadata(p) {
            acc ^= (m.mtime_unix_secs() as u64) ^ ((m.mtime_nanos() as u64) << 32);
        }
    }
    acc
}

/// Recréé une Config depuis chemins connus + éventuel env prefix.
/// Convention: concatène les chemins pour la clé interne "__files" (debug).
fn rebuild_from(paths:Vec<str>, env_prefix:Option<str>) -> Result<Config,str>{
    let mut b = Config::builder();
    if let Some(pfx)=env_prefix { b = b.env(pfx); }
    for p in paths.iter() { b = b.file(p.clone()); }
    let mut cfg = b.build()?;
    if !paths.is_empty() {
        cfg.data.insert("__files".into(), std::json::Value::String(paths.join(";")));
    }
    Ok(cfg)
}

/* ———————————————————— Debug / dump ———————————————————— */

impl Config {
    pub fn debug_dump_redacted(&self) -> str {
        let mut lines = Vec::<str>::new();
        let secrets = ["password","secret","token","key","credentials","passwd"];
        for (k,v) in self.data.iter() {
            let mut s = v.to_string();
            let kl = k.to_lower();
            if secrets.iter().any(|w| kl.contains(w)) {
                s = "***".into();
            } else if s.len()>500 { s = format!("{}…", &s[..500]); }
            lines.push(format!("{} = {}", k, s));
        }
        lines.sort(); lines.join("\n")
    }
}

/* ———————————————————— Extensions internes : builder annoté ———————————————————— */

impl Builder {
    // Ajoute des annotations internes (__env_prefix, __files) dans le build final (pour watch/debug).
    pub fn build_annotated(self) -> Result<Config, str> {
        let mut cfg = self.build()?;
        if let Some(pfx)=self.env_prefix { cfg.data.insert("__env_prefix".into(), std::json::Value::String(pfx)); }
        if !self.files.is_empty() {
            let joined = self.files.iter().map(|(p,_)| p.clone()).collect::<Vec<str>>().join(";");
            cfg.data.insert("__files".into(), std::json::Value::String(joined));
        }
        Ok(cfg)
    }
}
