//! modules/main.vitte
//! Point d’entrée “multi-démo” pour la façade modules/exports.vitte.
//!
//! Sous-commandes :
//!   help | --help | -h          — aide
//!   --version                   — version courte
//!   ui                          — lance une mini-fenêtre (GTK ou Qt selon features)
//!   blink [ms] [pin]            — clignote (HAL embarqué ou simulation hôte)
//!   read  <path>                — lit un fichier et affiche sa taille
//!   write <path> <text...>      — écrit du texte dans un fichier
//!
//! Variables d’env utiles :
//!   LOG=debug|info|warn|error   — verbosité des logs
//!   VITTECFG_BLINK_MS=500       — période par défaut (ms)
//!   VITTECFG_BLINK_GPIO=13      — pin par défaut

#![version("0.1.0")]
#![strict]
#![warn("unsafe_ops","unused","dead_code")]

/* ————————————————————————————————————————————————————————————
 * Imports : on tire tout depuis la façade exports.vitte
 * (Si votre résolveur de modules exige un chemin explicite,
 * remplacez `use exports::...` par le chemin réel du module.)
 * ————————————————————————————————————————————————————————————*/
use exports::prelude::*;
use exports::{gtk, qt};       // activés conditionnellement par features
use exports::{embedded};      // HAL portable (hôte/embarqué)
use exports::{cfg_get as env_get, cfg_u32 as env_u32, cfg_bool as env_bool};

/* ————————————————————————————————————————————————————————————
 * Helpers d’affichage
 * ————————————————————————————————————————————————————————————*/
fn print_version() {
    println("modules-demo 0.1.0 • Vitte");
}

fn print_help() {
    println("Usage: modules-demo <commande> [options]");
    println("");
    println("Commandes:");
    println("  help | --help | -h        Affiche cette aide");
    println("  --version                 Affiche la version");
    println("  ui                        Lance une mini UI (GTK ou Qt)");
    println("  blink [ms] [pin]          Fait clignoter une LED (ou simule)");
    println("  read  <path>              Lit un fichier et affiche sa taille");
    println("  write <path> <text...>    Écrit du texte dans un fichier");
    println("");
    println("Exemples :");
    println("  modules-demo ui");
    println("  modules-demo blink 250 13");
    println("  modules-demo read /etc/hosts");
    println("  modules-demo write /tmp/out.txt \"hello vitte\"");
}

/* ————————————————————————————————————————————————————————————
 * Démo UI — GTK ou Qt selon les features
 * ————————————————————————————————————————————————————————————*/
fn run_ui() -> int {
    #[cfg(feature="gtk")]
    {
        info("UI: backend GTK");
        gtk::init();
        let win = match gtk::Window::new("Vitte — Modules UI (GTK)", 860, 520) {
            Ok(w) => w,
            Err(e) => { error(format!("gtk::Window::new: {}", e.msg())); return 2; }
        };
        let btn = match gtk::Button::new("Ping") {
            Ok(b) => b,
            Err(e) => { error(format!("gtk::Button::new: {}", e.msg())); return 2; }
        };
        win.add(&gtk::Widget::Btn(btn));
        win.show_all();
        return gtk::main();
    }

    #[cfg(all(not(feature="gtk"), feature="qt"))]
    {
        info("UI: backend Qt");
        qt::init();
        let win = match qt::Window::new("Vitte — Modules UI (Qt)", 860, 520) {
            Ok(w) => w,
            Err(e) => { error(format!("qt::Window::new: {}", e.msg())); return 2; }
        };
        let btn = match qt::Button::new("Ping") {
            Ok(b) => b,
            Err(e) => { error(format!("qt::Button::new: {}", e.msg())); return 2; }
        };
        // Dans notre wrapper, add() est sur Window et prend un Button
        win.add(&btn);
        win.show();
        return qt::main();
    }

    #[cfg(not(any(feature="gtk", feature="qt")))]
    {
        warn("Aucun backend UI activé (ajoute feature `gtk` ou `qt`).");
        return 2;
    }
}

/* ————————————————————————————————————————————————————————————
 * Démo embedded — blink avec HAL (ou simulation hôte)
 * ————————————————————————————————————————————————————————————*/
fn run_blink(args: [str]) -> int {
    let period_ms: u32 = if args.len() > 2 {
        args[2].parse::<u32>().unwrap_or(env_u32("VITTECFG_BLINK_MS", 500))
    } else {
        env_u32("VITTECFG_BLINK_MS", 500)
    };

    let pin: u32 = if args.len() > 3 {
        args[3].parse::<u32>().unwrap_or(env_u32("VITTECFG_BLINK_GPIO", 13))
    } else {
        env_u32("VITTECFG_BLINK_GPIO", 13)
    };

    info(format!("Blink: pin={}, period={}ms", pin, period_ms));

    if let Err(e) = embedded::init_clock() {
        error(format!("clock init: {}", e.msg()));
        // on continue quand même : sur hôte c’est simulé
    }
    if let Err(e) = embedded::gpio_out(pin) {
        error(format!("gpio_out: {}", e.msg()));
        return 2;
    }

    // 10 périodes pour la démo (évite une boucle infinie côté CI)
    let half = period_ms / 2;
    let mut level = false;
    let mut i = 0;
    while i < 10 {
        level = !level;
        let _ = embedded::gpio_write(pin, level);
        embedded::delay_ms(half);

        level = !level;
        let _ = embedded::gpio_write(pin, level);
        embedded::delay_ms(half);

        i += 1;
    }
    info("Blink terminé.");
    return 0;
}

/* ————————————————————————————————————————————————————————————
 * Utilitaires fichiers
 * ————————————————————————————————————————————————————————————*/
fn cmd_read(args: [str]) -> int {
    if args.len() < 3 {
        eprintln("read: besoin d’un chemin");
        return 2;
    }
    let path = args[2];
    match read_file(path) {
        Ok(s) => {
            println("{} octets — {}", s.len(), path);
            0
        }
        Err(e) => {
            error(format!("read {}: {}", path, e.msg()));
            2
        }
    }
}

fn cmd_write(args: [str]) -> int {
    if args.len() < 4 {
        eprintln("write: usage: write <path> <text...>");
        return 2;
    }
    let path = args[2];
    // Concaténer tout le reste avec des espaces
    let mut i = 3;
    let mut buf = String::new();
    while i < args.len() {
        if i > 3 { buf.push(' '); }
        buf.push_str(args[i]);
        i += 1;
    }
    match write_file(path, buf) {
        Ok(_) => { println("OK: {}", path); 0 }
        Err(e) => { error(format!("write {}: {}", path, e.msg())); 2 }
    }
}

/* ————————————————————————————————————————————————————————————
 * Entrée programme
 * ————————————————————————————————————————————————————————————*/
fn main(args: [str]) -> int {
    if args.len() <= 1 {
        print_help();
        return 0;
    }

    match args[1] {
        "--help" | "-h" | "help" => { print_help(); 0 }
        "--version"               => { print_version(); 0 }
        "ui"                      => run_ui(),
        "blink"                   => run_blink(args),
        "read"                    => cmd_read(args),
        "write"                   => cmd_write(args),
        other                     => {
            eprintln("Commande inconnue: {} (essayez `help`)", other);
            2
        }
    }
}
