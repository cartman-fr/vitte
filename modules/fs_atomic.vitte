//! fs_atomic.vitte — write_atomic() & lockfile exclusif (tokenisé, timeout, TTL).
//!
//! ✨ Inclus
//! - write_atomic(path, bytes)         : écrit via fichier temporaire + rename (remplace).
//! - write_atomic_string / _json       : helpers pratiques.
//! - Lock exclusif : try_lock / lock_timeout / break_stale / is_locked / with_lock().
//! - Token dans le lockfile pour ne retirer à la sortie **que son propre** verrou.
//!
//! ⚠ Remarques
//! - Le `rename()` est atomique sur les FS POSIX; sur certains FS exotiques/Windows, le
//!   remplacement peut échouer si la cible est ouverte : on réessaie brièvement.
//! - Pas de `fsync()` portable ici (API Vitte simplifiée). Si tu as `std::fs::fsync_*`,
//!   tu peux les appeler après l’écriture et après le `rename()` pour durabilité stricte.

#![version("0.2.0")]
#![strict]

/* ———————————————————— Écriture atomique ———————————————————— */

pub fn write_atomic(path:&str, bytes:&[u8]) -> Result<(),str>{
    let tmp = tmp_path(path);
    // 1) écrire dans un fichier temporaire situé **dans le même dossier**
    std::fs::write(&tmp, bytes).map_err(|e| format!("{}",e))?;
    // 2) tenter rename() atomique → remplace la cible
    if let Err(e) = std::fs::rename(&tmp, path) {
        // Cas Windows/FS récalcitrant : petite retry-window
        let mut ok=false;
        let mut i=0;
        while i<5 {
            std::time::sleep(10);
            if std::fs::rename(&tmp, path).is_ok() { ok=true; break; }
            i+=1;
        }
        if !ok {
            // best-effort cleanup
            let _ = std::fs::remove_file(&tmp);
            return Err(format!("{}", e));
        }
    }
    Ok(())
}

/// Écrit une chaîne de caractères de façon atomique.
pub fn write_atomic_string(path:&str, s:&str)->Result<(),str>{
    write_atomic(path, s.as_bytes())
}

/// Écrit un JSON (Value → string) de façon atomique.
pub fn write_atomic_json(path:&str, v:&std::json::Value)->Result<(),str>{
    write_atomic_string(path, &v.to_string())
}

fn tmp_path(path:&str)->str{
    let ts = std::time::now().unix_millis();
    let rnd = std::rand::u32();
    format!("{}.tmp.{}.{}", path, ts, rnd)
}

/* ———————————————————— Lockfile exclusif ———————————————————— */

pub struct Lock {
    path: str,           // chemin du .lock
    token: str,          // jeton aléatoire ; on ne supprime que si on le retrouve
}

impl Lock {
    pub fn path(&self)->&str { &self.path }
}

/// Crée un .lock exclusif à côté de `path` (ou d’un nom déjà .lock). Non bloquant.
/// Erreurs: "locked" si déjà présent.
pub fn try_lock(path:&str)->Result<Lock,str>{
    let lf = ensure_lock_path(path);
    if std::fs::exists(&lf){ return Err("locked".into()); }
    let token = lock_token();
    let content = lockfile_content(&token);
    // Tentative d’écriture ; si une autre instance écrit au même moment, on peut
    // se battre avec exists(); on assume que write échouera rarement juste ici.
    std::fs::write(&lf, content.as_bytes()).map_err(|e| format!("{}",e))?;
    Ok(Lock{ path: lf, token })
}

/// Tente d’acquérir le lock en attendant jusqu’à `timeout_ms`.
/// `poll_ms` cadence la vérification. Retourne Err("timeout") si non acquis.
pub fn lock_timeout(path:&str, timeout_ms:u64, poll_ms:u64)->Result<Lock,str>{
    let start = now_ms();
    loop {
        match try_lock(path) {
            Ok(l) => return Ok(l),
            Err(e) if e=="locked" => {
                if now_ms().saturating_sub(start) >= timeout_ms { return Err("timeout".into()); }
                std::time::sleep(poll_ms as i64);
            }
            Err(e) => return Err(e),
        }
    }
}

/// Supprime un lock **périmé** si son âge dépasse `ttl_ms`.
/// Retourne true si un lock périmé a été supprimé.
pub fn break_stale(path:&str, ttl_ms:u64)->bool{
    let lf = ensure_lock_path(path);
    if !std::fs::exists(&lf){ return false; }
    if let Ok(m)=std::fs::metadata(&lf) {
        let age = file_age_ms(&m);
        if age >= ttl_ms {
            let _ = std::fs::remove_file(&lf);
            return true;
        }
    }
    false
}

/// Test: le lock est-il présent **et** valide (contenu parsable) ?
pub fn is_locked(path:&str)->bool{
    let lf = ensure_lock_path(path);
    if !std::fs::exists(&lf){ return false; }
    if let Ok(s)=std::fs::read_to_string(&lf) {
        return s.starts_with("token=");
    }
    true
}

/// Execute `f()` sous lock (avec attente). Relâche automatiquement.
/// - `timeout_ms`= délai max pour obtenir le lock
/// - `poll_ms`= intervalle de réessai
pub fn with_lock<R, F:FnOnce()->R>(path:&str, timeout_ms:u64, poll_ms:u64, f:F)->Result<R,str>{
    let l = lock_timeout(path, timeout_ms, poll_ms)?;
    let out = f();
    drop(l);
    Ok(out)
}

/* ———————————————————— Utilitaires lock ———————————————————— */

fn ensure_lock_path(path:&str)->str{
    if path.ends_with(".lock"){ path.to_string() } else { format!("{}.lock", path) }
}
fn lock_token()->str{
    // 128 bits (hex) minimal
    let a = std::rand::u64(); let b = std::rand::u64();
    format!("{:016x}{:016x}", a, b)
}
fn lockfile_content(token:&str)->str{
    format!("token={}\ncreated_at_ms={}\npid={}\n", token, now_ms(), std::process::id())
}
fn now_ms()->u64{ std::time::now().unix_millis() as u64 }

fn file_age_ms(meta:&std::fs::Metadata)->u64{
    let secs = meta.mtime_unix_secs() as u64;
    let ns   = meta.mtime_nanos() as u64;
    let mt = secs.saturating_mul(1000) + ns/1_000_000;
    now_ms().saturating_sub(mt)
}

impl Drop for Lock {
    fn drop(&mut self){
        // Retirer le lock **uniquement** si le token correspond
        if let Ok(s)=std::fs::read_to_string(&self.path) {
            if s.starts_with(&format!("token={}", self.token)) {
                let _ = std::fs::remove_file(&self.path);
            }
        } else {
            // si on ne peut pas lire (déjà supprimé ?), on ignore
        }
    }
}

/* ———————————————————— Mini doc-tests ———————————————————— */
//! fn _smoke_fs_atomic() {
//!     let p = "tmp.dat";
//!     let _ = std::fs::remove_file(p);
//!     let _ = std::fs::remove_file(&format!("{}.lock", p));
//!
//!     // write_atomic
//!     assert(write_atomic(p, b"hello").is_ok());
//!     assert(std::fs::read_to_string(p).unwrap()=="hello");
//!
//!     // lock try + timeout
//!     let l1 = try_lock(p).unwrap();
//!     assert(is_locked(p));
//!     assert(try_lock(p).is_err()); // déjà locké
//!
//!     // timeout court → timeout
//!     assert(lock_timeout(p, 50, 10).unwrap_err()=="timeout");
//!
//!     // break_stale (simulé en ajustant TTL à 0)
//!     assert(break_stale(p, 0));
//!
//!     // with_lock
//!     let r = with_lock(p, 200, 20, || 41+1).unwrap();
//!     assert(r==42);
//! }
