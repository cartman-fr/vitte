//! http_client.vitte — HTTP/1.1 minimal costaud : GET/POST, JSON helpers, timeouts, redirects.
//!
//! ✨ Features
//! - Méthodes : GET / POST / HEAD / PUT / DELETE (et builder `Request` arbitraire).
//! - Header management : headers globaux (Client) + spécifiques (Request), UA custom.
//! - Timeouts (connect/read/write) & limite de redirections configurable.
//! - Redirects : 301/302 (POST→GET par défaut), 303 (force GET), 307/308 (préservent méthode+corps).
//! - Bodies : bytes, string, JSON, form `application/x-www-form-urlencoded`.
//! - Parsing robuste : status line, headers **case-insensitive**, **chunked** decoding, **Content-Length**,
//!   **gzip/deflate** (si `Content-Encoding`), et `Connection: close` par défaut.
//! - Helpers : `.text()` (UTF-8/charset= fallback), `.json()`, `.ok()`.
//!
//! ⚠️ TLS : `https://` utilise `std::net::TlsStream` si dispo. Cert-check minimal (dépend de ton runtime).
//! ⚠️ Ce client est volontairement simple : pas de keep-alive/pipelining/cookies/proxy intégrés.

#![version("0.3.0")]
#![strict]

use std::collections::{Map};
use std::io;

pub struct Client {
    ua: str,
    timeout_ms: u64,
    max_redirects: u8,
    default_headers: Map<str,str>,
}

pub struct Resp {
    pub url: str,                           // URL finale (après redirects)
    pub status:int,
    pub headers: Map<str,str>,              // noms en minuscule
    pub body: Vec<u8>,
}
impl Resp {
    pub fn ok(&self)->bool { self.status>=200 && self.status<300 }
    pub fn header(&self, name:&str)->Option<&str> { self.headers.get(name.to_lower()).map(|s| &**s) }
    pub fn text(&self)->str{
        // charset rudimentaire depuis Content-Type; fallback utf-8
        let ct = self.header("content-type").unwrap_or("");
        let cs = parse_charset(ct).unwrap_or("utf-8".into());
        if cs=="utf-8" { std::str::from_utf8(&self.body).unwrap_or("").to_string() }
        else { // fallback un-safe : on suppose utf-8 quand inconnu
            std::str::from_utf8(&self.body).unwrap_or("").to_string()
        }
    }
    pub fn json(&self)->Result<std::json::Value,str>{
        std::json::parse(&self.text()).map_err(|e| format!("{}", e))
    }
}

pub struct Request {
    method: str,
    url: str,
    headers: Map<str,str>,       // lowercased keys
    body: Option<Vec<u8>>,
}
impl Request {
    pub fn new(method:&str, url:&str)->Self{
        Self{ method:method.to_string(), url:url.to_string(), headers:Map::new(), body:None }
    }
    pub fn header(mut self, k:&str, v:&str)->Self{ self.headers.insert(k.to_lower(), v.to_string()); self }
    pub fn basic_auth(mut self, user:&str, pass:&str)->Self{
        let token = std::base64::encode(format!("{}:{}", user, pass).as_bytes());
        self.headers.insert("authorization".into(), format!("Basic {}", token)); self
    }
    pub fn body_bytes(mut self, b:Vec<u8>, ct:&str)->Self{
        self.headers.insert("content-type".into(), ct.to_string());
        self.body = Some(b); self
    }
    pub fn body_str(self, s:&str, ct:&str)->Self{ self.body_bytes(s.as_bytes().to_vec(), ct) }
    pub fn json(mut self, v:&std::json::Value)->Self{
        self.headers.insert("content-type".into(), "application/json".into());
        self.body = Some(v.to_string().as_bytes().to_vec()); self
    }
    pub fn form(mut self, fields:&Map<str,str>)->Self{
        let mut parts=Vec::<str>::new();
        for (k,v) in fields.iter(){
            parts.push(format!("{}={}", url_encode(k), url_encode(v)));
        }
        let s = parts.join("&");
        self.headers.insert("content-type".into(), "application/x-www-form-urlencoded".into());
        self.body = Some(s.as_bytes().to_vec()); self
    }
}

/* ———————————————————— Client ———————————————————— */

impl Client {
    pub fn new() -> Self {
        let mut h = Map::new();
        h.insert("accept".into(), "*/*".into());
        Self{ ua: "vitte-http/0.3".into(), timeout_ms: 5000, max_redirects: 4, default_headers: h }
    }
    pub fn timeout_ms(mut self, t:u64)->Self{ self.timeout_ms=t; self }
    pub fn user_agent(mut self, ua:str)->Self{ self.ua=ua; self }
    pub fn redirects(mut self, n:u8)->Self{ self.max_redirects=n; self }
    pub fn default_header(mut self, k:&str, v:&str)->Self{ self.default_headers.insert(k.to_lower(), v.to_string()); self }

    /* ——— Convenience ——— */
    pub fn get(&self, url: str) -> Result<Resp,str> { self.send(Request::new("GET",&url)) }
    pub fn head(&self, url: str) -> Result<Resp,str> { self.send(Request::new("HEAD",&url)) }
    pub fn delete(&self, url: str) -> Result<Resp,str> { self.send(Request::new("DELETE",&url)) }
    pub fn post(&self, url: str, ct: str, body: Vec<u8>) -> Result<Resp,str> {
        self.send(Request::new("POST",&url).body_bytes(body, &ct))
    }
    pub fn post_json(&self, url:str, v:&std::json::Value)->Result<Resp,str>{
        self.send(Request::new("POST",&url).json(v))
    }
    pub fn get_json(&self, url:str) -> Result<std::json::Value,str> {
        let r = self.get(url)?;
        if !r.ok() { return Err(format!("status {}", r.status)); }
        r.json()
    }

    /* ——— Bas niveau : envoie une Request (gère redirects) ——— */
    pub fn send(&self, req: Request) -> Result<Resp,str> { self.send_inner(req, self.max_redirects) }

    fn send_inner(&self, mut req: Request, mut redirects:u8) -> Result<Resp,str> {
        let mut cur_url = req.url.clone();
        let orig_method = req.method.clone();
        let orig_body   = req.body.clone();

        loop {
            let (scheme, host, port, path_query, tls) = parse_url(&cur_url)?;
            let mut s = if tls {
                // TLS : dépend du runtime Vitte ; on suppose une API miroir à TcpStream
                let st = std::net::TlsStream::connect_timeout(host.clone(), port, self.timeout_ms)
                    .map_err(|e| format!("{}", e))?;
                st
            } else {
                let st = std::net::TcpStream::connect_timeout(host.clone(), port, self.timeout_ms)
                    .map_err(|e| format!("{}", e))?;
                st
            };
            s.set_read_timeout(self.timeout_ms)?;
            s.set_write_timeout(self.timeout_ms)?;

            // ——— construire la requête ———
            let mut head = String::new();
            head.push_str(&format!("{} {} HTTP/1.1\r\n", req.method, path_query));
            head.push_str(&format!("Host: {}\r\n", host));
            head.push_str(&format!("User-Agent: {}\r\n", self.ua));
            head.push_str("Connection: close\r\n");

            // Headers par défaut (client)
            for (k,v) in self.default_headers.iter() {
                if !req.headers.contains_key(k.to_string()) {
                    head.push_str(&format!("{}: {}\r\n", canonical(k), v));
                }
            }
            // Headers spécifiques à la requête
            for (k,v) in req.headers.iter() {
                head.push_str(&format!("{}: {}\r\n", canonical(k), v));
            }
            // Body (le cas échéant)
            if let Some(b) = &req.body {
                if !req.headers.contains_key("content-length".into()) {
                    head.push_str(&format!("Content-Length: {}\r\n", b.len()));
                }
            }
            head.push_str("\r\n");

            // ——— envoi ———
            io::write_all(&s, head.as_bytes()).map_err(|e| format!("{}", e))?;
            if let Some(b) = &req.body { io::write_all(&s, b).map_err(|e| format!("{}", e))?; }

            // ——— lecture ——— (jusqu’à fermeture ; on a "Connection: close")
            let mut buf = Vec::<u8>::new();
            io::read_to_end(&s, &mut buf).map_err(|e| format!("{}", e))?;

            // ——— parsing réponse ———
            let (status, mut headers, mut body) = parse_http_response(&buf)?;

            // Décodages éventuels
            if let Some(te)=headers.get("transfer-encoding") {
                if te.to_lower()=="chunked" {
                    body = decode_chunked(&body)?;
                    headers.remove("transfer-encoding".into());
                    headers.insert("content-length".into(), format!("{}", body.len()));
                }
            }
            if let Some(ce)=headers.get("content-encoding") {
                let low = ce.to_lower();
                if low.contains("gzip") {
                    if let Ok(unz) = std::compress::gunzip(&body) {
                        body = unz;
                        headers.remove("content-encoding".into());
                    }
                } else if low.contains("deflate") {
                    if let Ok(unz) = std::compress::inflate(&body) {
                        body = unz;
                        headers.remove("content-encoding".into());
                    }
                }
            }

            // ——— redirections ———
            if status>=300 && status<400 {
                let loc = headers.get("location").cloned().unwrap_or("".into());
                if loc.is_empty() { return Ok(Resp{ url:cur_url, status, headers, body }); }
                if redirects==0 { return Err("too many redirects".into()); }
                redirects -= 1;

                let next = absolutize(&cur_url, &loc)?;
                let code = status;
                // RFC-ish : 303 -> GET ; 307/308 -> conserver ; 301/302 -> GET si POST/has body (comportement pragmatique)
                match code {
                    303 => { req.method = "GET".into(); req.body = None; req.headers.remove("content-type".into()); }
                    307 | 308 => { /* keep method+body */ }
                    301 | 302 => {
                        if req.method=="POST" || orig_method=="POST" || req.body.is_some() {
                            req.method = "GET".into(); req.body=None; req.headers.remove("content-type".into());
                        }
                    }
                    _ => {}
                }
                cur_url = next;
                continue;
            }

            return Ok(Resp{ url:cur_url, status, headers, body });
        }
    }
}

/* ———————————————————— Parsing HTTP ———————————————————— */

fn parse_http_response(bytes:&[u8])->Result<(int,Map<str,str>,Vec<u8>),str>{
    // chercher double CRLF
    let mut i=0usize;
    let mut split=None;
    while i+3<bytes.len() {
        if bytes[i]==b'\r' && bytes[i+1]==b'\n' && bytes[i+2]==b'\r' && bytes[i+3]==b'\n' {
            split=Some(i+4); break;
        }
        i+=1;
    }
    let pos = split.ok_or("http: en-têtes non terminés")?;
    let head = std::str::from_utf8(&bytes[..pos]).unwrap_or("");
    let mut lines = head.split("\r\n");
    let status_line = lines.next().unwrap_or("HTTP/1.1 500");
    let status = status_line.split_whitespace().nth(1).unwrap_or("500").parse::<int>().unwrap_or(500);
    let mut headers = Map::<str,str>::new();
    for l in lines {
        if l.is_empty() { continue; }
        if let Some(col)=l.find(':') {
            let k = l[..col].to_lower();
            let v = l[col+1..].trim();
            headers.insert(k, v.to_string());
        }
    }
    let body = bytes[pos..].to_vec();
    Ok((status, headers, body))
}

/* ———————————————————— Chunked decoding ———————————————————— */

fn decode_chunked(b:&[u8])->Result<Vec<u8>,str>{
    let mut out = Vec::<u8>::new();
    let mut i=0usize;
    loop {
        // lire taille hexa jusqu'à CRLF
        let mut j=i;
        while j+1<b.len() && !(b[j]==b'\r' && b[j+1]==b'\n') { j+=1; }
        if j+1>=b.len(){ return Err("chunked: taille incomplète".into()); }
        let size_hex = std::str::from_utf8(&b[i..j]).unwrap_or("0").trim();
        let size = u64::from_str_radix(size_hex, 16).map_err(|_| "chunked: taille invalide".to_string())? as usize;
        i = j+2; // saute CRLF
        if size==0 {
            // trailer headers (optionnels) jusqu'à CRLFCRLF
            // on les ignore
            break;
        }
        if i+size+2 > b.len(){ return Err("chunked: données incomplètes".into()); }
        out.extend_from_slice(&b[i..i+size]);
        i += size;
        // CRLF après chunk
        if !(b[i]==b'\r' && b[i+1]==b'\n'){ return Err("chunked: CRLF manquant après chunk".into()); }
        i += 2;
    }
    Ok(out)
}

/* ———————————————————— URL & utilitaires ———————————————————— */

fn parse_url(u:&str) -> Result<(str, str,u16, str,bool),str> {
    if u.starts_with("http://") { let (h,pth,port) = split_host_path(&u[7..], 80); return Ok(("http".into(), h, port, pth, false)); }
    if u.starts_with("https://"){ let (h,pth,port) = split_host_path(&u[8..], 443); return Ok(("https".into(),h, port, pth, true)); }
    Err("unsupported scheme (use http:// or https://)".into())
}
fn split_host_path(rest:&str, def_port:u16)->(str,str,u16){
    let (host_port, pathq) = match rest.find('/') {
        Some(i) => (rest[..i].to_string(), rest[i..].to_string()),
        None    => (rest.to_string(), "/".into()),
    };
    let (host, port) = match host_port.find(':') {
        Some(i) => (host_port[..i].to_string(), host_port[i+1..].parse::<u16>().unwrap_or(def_port)),
        None    => (host_port, def_port),
    };
    (host, pathq, port)
}
fn absolutize(base:&str, loc:&str)->Result<str,str>{
    if loc.starts_with("http://") || loc.starts_with("https://") { return Ok(loc.to_string()); }
    if loc.starts_with("//") {
        // scheme-relative
        let scheme = if base.starts_with("https://") { "https:" } else { "http:" };
        return Ok(format!("{}{}", scheme, loc));
    }
    let (scheme, host, port, pathq, _tls) = parse_url(base)?;
    if loc.starts_with('/') {
        Ok(format!("{}://{}:{}{}", scheme, host, port, loc))
    } else {
        // relative path : remonter au dossier
        let (dir, _) = split_dir_file(&pathq);
        Ok(format!("{}://{}:{}{}/{}", scheme, host, port, dir, loc))
    }
}
fn split_dir_file(path:&str)->(str,str){
    if let Some(i)=path.rfind('/') {
        let dir = if i==0 { "".into() } else { path[..i].to_string() };
        let file = path[i+1..].to_string();
        (dir, file)
    } else {
        ("".into(), path.to_string())
    }
}

fn canonical(k:&str)->str{
    // minuscule → Capitalize-Style (simple) pour l’envoi
    let mut out=String::new();
    let mut up=true;
    for ch in k.chars() {
        if ch=='-' { out.push('-'); up=true; continue; }
        if up { out.push(ch.to_uppercase()); up=false; } else { out.push(ch); }
    }
    out
}

fn parse_charset(ct:&str)->Option<str>{
    // "text/html; charset=UTF-8"
    if let Some(i)=ct.to_lower().find("charset=") {
        let cs = &ct[i+8..].trim();
        let semi = cs.find(';').unwrap_or(cs.len());
        return Some(cs[..semi].trim().to_lower());
    }
    None
}

fn url_encode(s:&str)->str{
    let bytes = s.as_bytes();
    let mut out=String::new();
    let mut i=0; while i<bytes.len() {
        let b = bytes[i];
        let c = b as char;
        let unres = (c.is_alphanumeric() || c=='-' || c=='_' || c=='.' || c=='~');
        if unres { out.push(c); }
        else { out.push_str(&format!("%{:02X}", b)); }
        i+=1;
    }
    out
}

/* ———————————————————— Traits IO stubs (compat Vitte std) ———————————————————— */
//! Note : ces signatures reflètent l’API “std” de Vitte déjà utilisée dans d’autres modules.
//! - TcpStream/TlsStream exposent connect_timeout + set_*_timeout + Read/Write de base.
//! - io::{write_all,read_to_end} propagent des Err affichables via format!("{}", e).

/* ———————————————————— Doc-tests ———————————————————— */
//! fn _http_smoke() {
//!     let cli = Client::new().timeout_ms(4000).redirects(3);
//!     // GET text
//!     let r = cli.get("http://example.org/".into()).unwrap();
//!     assert(r.status>=200);
//!     // JSON helper (si endpoint JSON)
//!     // let j = cli.get_json("https://httpbin.org/json".into()).unwrap();
//!
//!     // POST form
//!     let mut form = std::collections::Map::new();
//!     form.insert("q".into(),"vitte".into());
//!     let r2 = cli.send(
//!         Request::new("POST","https://httpbin.org/post")
//!             .form(&form)
//!             .header("x-req-id","test-123")
//!     ).unwrap();
//!     assert(r2.status>=200);
//! }
