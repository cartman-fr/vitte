//! ini.vitte — parse INI ↔ Map<section.key, value> (+ sections, quotes, continuations, getters).
//!
//! ✨ Inclus
//! - `parse(&str) -> Map<str,str>` : mode tolérant (ignore les lignes invalides).
//! - `parse_strict(&str) -> Result<Ini,str>` : erreurs avec ligne/colonne.
//! - Support : `;` ou `#` (début/inline), `[section]`, `key = value` ou `key: value`,
//!             valeurs **quotées** ('simple' ou "double"), échappements (`\n \t \\ \" \xHH`),
//!             **lignes continuées** (`\` final), BOM UTF-8, espaces autour des `=`.
//! - Accès : `get`, `get_bool`, `get_i64`, `get_f64`, `get_list` (CSV aware quotes).
//! - Variantes : `parse_file(path)`, `to_string(&Map)`, `to_sections(&Map)`,
//!               `merge(a,b)` (b écrase a), `section(view)`.
//!
//! ⚠️ Règles : dernière occurrence d’une clé gagne; clés/sections **préservent la casse** à l’écriture.
//!    La recherche dans `IniView` est insensible à la casse (fold basique latin1).

#![version("0.3.0")]
#![strict]

use std::collections::{Map};

/* ———————————————————— API de haut niveau ———————————————————— */

pub fn parse(s:&str)->Map<str,str>{
    match parse_strict(s) {
        Ok(ini) => ini.flat,
        Err(_)  => {
            // mode tolérant: on tente ligne par ligne; on ignore ce qui casse
            let mut cur="".to_string();
            let mut m=Map::new();
            for raw in s.lines(){
                let line = strip_bom_once(raw);
                let ln = line.trim();
                if ln.is_empty() || ln.starts_with(';') || ln.starts_with('#'){ continue; }
                if ln.starts_with('[') && ln.ends_with(']'){ cur=ln[1..ln.len()-1].trim().to_string(); continue; }
                if let Some((k,v)) = split_kv_relaxed(ln) {
                    let key = if cur.is_empty(){ k.to_string() } else { format!("{}.{}", cur, k) };
                    m.insert(key, v.to_string());
                }
            }
            m
        }
    }
}

pub fn parse_file(path:&str)->Result<Map<str,str>,str>{
    let txt = std::fs::read_to_string(path).map_err(|e| format!("{}", e))?;
    Ok(parse(&txt))
}

/// Représentation riche (sections + plat).
pub struct Ini {
    pub flat: Map<str,str>,                         // "sec.key" → "val"
    pub sections: Map<str, Map<str,str>>,           // "sec" → {"key":"val"}
}
impl Ini {
    pub fn get(&self, full:&str)->Option<&str>{ self.flat.get(full.to_string()).map(|s| &**s) }
    pub fn to_string(&self)->str{ to_string(&self.flat) }
    pub fn section<'a>(&'a self, sec:&str)->IniView<'a>{ IniView{ ini:self, sec:sec.to_string() } }
}

/// Parse strict — remonte les erreurs avec localisation.
pub fn parse_strict(s:&str)->Result<Ini,str>{
    let mut flat = Map::<str,str>::new();
    let mut sections = Map::<str, Map<str,str>>::new();

    let mut sec = "".to_string();
    let mut acc = String::new();
    let mut cont = false; // continuation en cours
    let mut line_no = 0usize;

    for raw in s.lines() {
        line_no += 1;
        let mut line = strip_bom_once(raw).to_string();

        // gestion continuation: si la ligne précédente finissait par "\" non échappé
        if cont {
            // joindre avec \n (préserve sauts)
            acc.push('\n');
            acc.push_str(&line);
        } else {
            acc = line.clone();
        }

        // détecter continuation (anti-slash final non échappé et hors guillemets)
        let (ends_with_cont, core) = ends_with_continuation(&acc);
        if ends_with_cont { cont = true; continue; }
        cont = false; line = core.to_string();

        let t = line.trim();
        if t.is_empty() { continue; }
        // commentaires plein-ligne
        if t.starts_with(';') || t.starts_with('#'){ continue; }

        // section ?
        if t.starts_with('[') && t.ends_with(']') {
            let name = &t[1..t.len()-1];
            let name = name.trim();
            if name.is_empty(){ return Err(err(line_no, 1, "section vide")); }
            sec = name.to_string();
            if !sections.contains_key(sec.clone()) { sections.insert(sec.clone(), Map::new()); }
            continue;
        }

        // key=val  (avec parsing quotes + inline comments)
        let (key, val) = parse_kv(t, line_no)?;
        if key.is_empty(){ return Err(err(line_no, 1, "clé vide")); }

        let full = if sec.is_empty(){ key.clone() } else { format!("{}.{}", sec, key) };
        flat.insert(full.clone(), val.clone());
        // sections
        let ent = sections.entry(sec.clone()).or_insert(Map::new());
        ent.insert(key, val);
    }

    Ok(Ini{ flat, sections })
}

/* ———————————————————— Conversion / Merge ———————————————————— */

/// Construit un INI texte à partir d’une Map "sec.key" → "val".
pub fn to_string(m:&Map<str,str>)->str{
    // Regroupe par section ; ordonne sections/keys
    let mut bysec = Map::<str, Vec<(str,str)>>::new();
    for (k,v) in m.iter(){
        let (sec,key) = split_full_key(k);
        bysec.entry(sec.to_string()).or_insert(Vec::new()).push((key.to_string(), v.clone()));
    }
    let mut secs:Vec<str> = bysec.keys().cloned().collect(); secs.sort();
    let mut out=String::new();
    // section vide d'abord (global)
    if let Some(items)=bysec.get("".into()){
        let mut kv = items.clone(); kv.sort_by(|a,b| a.0.cmp(&b.0));
        for (k,v) in kv.into_iter(){ out.push_str(&format!("{} = {}\n", k, emit_value(&v))); }
    }
    for s in secs.into_iter().filter(|x| !x.is_empty()) {
        out.push_str(&format!("\n[{}]\n", s));
        let mut kv = bysec.get(&s).unwrap().clone();
        kv.sort_by(|a,b| a.0.cmp(&b.0));
        for (k,v) in kv.into_iter(){ out.push_str(&format!("{} = {}\n", k, emit_value(&v))); }
    }
    out
}

/// Transforme en sections imbriquées.
pub fn to_sections(m:&Map<str,str>)->Map<str,Map<str,str>>{
    let mut out = Map::<str,Map<str,str>>::new();
    for (full,v) in m.iter(){
        let (sec,key) = split_full_key(full);
        out.entry(sec.to_string()).or_insert(Map::new()).insert(key.to_string(), v.clone());
    }
    out
}

/// Fusion simple : `b` écrase `a`.
pub fn merge(a:&Map<str,str>, b:&Map<str,str>)->Map<str,str>{
    let mut o=a.clone(); for (k,v) in b.iter(){ o.insert(k.clone(), v.clone()); } o
}

/* ———————————————————— IniView : accès par section (case-insensitive) ———————————————————— */

pub struct IniView<'a> { ini: &'a Ini, sec: str }
impl<'a> IniView<'a> {
    fn full(&self, k:&str)->str{
        if self.sec.is_empty(){ k.to_string() } else { format!("{}.{}", self.sec, k) }
    }
    pub fn get(&self, k:&str)->Option<&str>{
        // insensible à la casse pour la clé complète
        let target = fold_case(&self.full(k));
        for (kk,v) in self.ini.flat.iter(){ if fold_case(kk)==target { return Some(v); } }
        None
    }
    pub fn get_or(&self, k:&str, def:&str)->str{ self.get(k).unwrap_or(def).to_string() }
    pub fn get_bool(&self, k:&str, def:bool)->bool{
        self.get(k).map(|s| {
            let t=s.to_lower().trim(); t=="1"||t=="true"||t=="yes"||t=="on"
        }).unwrap_or(def)
    }
    pub fn get_i64(&self, k:&str, def:i64)->i64{ self.get(k).and_then(|s| s.trim().parse::<i64>().ok()).unwrap_or(def) }
    pub fn get_f64(&self, k:&str, def:f64)->f64{ self.get(k).and_then(|s| s.trim().parse::<f64>().ok()).unwrap_or(def) }
    pub fn get_list(&self, k:&str)->Vec<str>{ split_csv_quoted(self.get(k).unwrap_or("")).into_iter().map(|s| s.to_string()).collect() }
}

/* ———————————————————— Parsing helpers ———————————————————— */

fn parse_kv(t:&str, line_no:usize)->Result<(str,str),str>{
    // trouve séparateur '=' ou ':' hors guillemets
    let mut in_s=false; let mut in_d=false;
    let bytes=t.as_bytes();
    let mut i=0usize; let mut sep=None;
    while i<bytes.len() {
        let c=bytes[i] as char;
        if c=='\'' && !in_d { in_s=!in_s; i+=1; continue; }
        if c=='"'  && !in_s { in_d=!in_d; i+=1; continue; }
        if !in_s && !in_d && (c=='=' || c==':') { sep=Some((i,c)); break; }
        i+=1;
    }
    let (si,sc) = sep.ok_or(err(line_no, 1, "ligne sans séparateur '=' ni ':'"))?;
    let k = t[..si].trim();
    let mut v = t[si+1..].trim();

    // couper commentaires inline si hors guillemets
    let (cut,_) = cut_inline_comment(v);
    v = cut.trim();

    // dé-quotage/échappements
    let val = unquote(v).map_err(|e| err(line_no, si+2, &e))?;
    Ok((k.to_string(), val))
}

fn ends_with_continuation(s:&str)->(bool,&str){
    // considère continuation si la ligne se termine par un '\' non échappé hors guillemets
    let mut in_s=false; let mut in_d=false;
    let bytes=s.as_bytes();
    let mut i=0usize;
    while i<bytes.len() {
        let c=bytes[i] as char;
        if c=='\'' && !in_d { in_s=!in_s; }
        else if c=='"' && !in_s { in_d=!in_d; }
        i+=1;
    }
    if in_s || in_d { return (false, s); }
    // compter les '\' finaux
    let mut n=0usize; let mut j=bytes.len();
    while j>0 && bytes[j-1]==b'\\' { n+=1; j-=1; }
    if n>0 && n%2==1 {
        // retire un backslash de continuation + trailing spaces
        let mut end = bytes.len()-1;
        while end>0 && bytes[end-1].is_ascii_whitespace(){ end-=1; }
        return (true, std::str::from_utf8(&bytes[..end]).unwrap_or(s));
    }
    (false, s)
}

fn cut_inline_comment(s:&str)->(&str, Option<char>){
    let mut in_s=false; let mut in_d=false;
    let bytes=s.as_bytes(); let mut i=0usize;
    while i<bytes.len() {
        let c=bytes[i] as char;
        if c=='\'' && !in_d { in_s=!in_s; i+=1; continue; }
        if c=='"'  && !in_s { in_d=!in_d; i+=1; continue; }
        if !in_s && !in_d && (c=='#' || c==';') {
            return (&s[..i], Some(c));
        }
        i+=1;
    }
    (s, None)
}

fn unquote(v:&str)->Result<str,str>{
    let t=v.trim();
    if t.len()>=2 && ((t.starts_with('"') && t.ends_with('"')) || (t.starts_with('\'') && t.ends_with('\''))) {
        let quoted=&t[1..t.len()-1];
        if t.starts_with('"'){ return unescape_double(quoted); }
        else { return Ok(quoted.to_string()); } // quotes simples : littéral
    }
    Ok(t.to_string())
}

fn unescape_double(s:&str)->Result<str,str>{
    let b=s.as_bytes(); let mut out=String::new(); let mut i=0usize;
    while i<b.len() {
        if b[i]!=b'\\' { out.push(b[i] as char); i+=1; continue; }
        if i+1>=b.len(){ return Err("échappement tronqué".into()); }
        let c=b[i+1] as char;
        match c {
            'n' => { out.push('\n'); i+=2; }
            'r' => { out.push('\r'); i+=2; }
            't' => { out.push('\t'); i+=2; }
            '\\'=> { out.push('\\'); i+=2; }
            '"' => { out.push('"');  i+=2; }
            'x' => {
                if i+3>=b.len(){ return Err("échappement \\xHH incomplet".into()); }
                let h = &s[i+2..i+4];
                let v = u8::from_str_radix(h,16).map_err(|_| "échappement \\xHH invalide".to_string())?;
                out.push(v as char); i+=4;
            }
            _ => { out.push(c); i+=2; } // tolérant
        }
    }
    Ok(out)
}

fn split_kv_relaxed(ln:&str)->Option<(str,str)>{
    if let Some(i)=ln.find('=') {
        let k=ln[..i].trim(); let mut v=ln[i+1..].trim();
        let (cut,_) = cut_inline_comment(v); v=cut.trim();
        if k.is_empty(){ return None; }
        if let Ok(val)=unquote(v){ return Some((k.to_string(), val)); }
        return Some((k.to_string(), v.to_string()));
    }
    if let Some(i)=ln.find(':') {
        let k=ln[..i].trim(); let v=ln[i+1..].trim();
        if k.is_empty(){ return None; }
        return Some((k.to_string(), v.to_string()));
    }
    None
}

/* ———————————————————— Utilitaires ———————————————————— */

fn split_full_key(full:&str)->(&str,&str){
    if let Some(dot)=full.find('.') { (&full[..dot], &full[dot+1..]) } else { ("", full) }
}

fn strip_bom_once(s:&str)->&str{
    if s.as_bytes().starts_with(&[0xEF,0xBB,0xBF]) { &s[3..] } else { s }
}

fn emit_value(v:&str)->str{
    // quote si nécessaire (espace initial/final, ; # = ou \n)
    let need = v.is_empty() || v.starts_with(' ') || v.ends_with(' ')
        || v.contains('\n') || v.contains('\r') || v.contains('=') || v.contains('#') || v.contains(';');
    if !need { return v.to_string(); }
    let mut s=String::new(); s.push('"');
    let bytes=v.as_bytes(); let mut i=0;
    while i<bytes.len(){
        let c=bytes[i] as char;
        match c {
            '\\' => s.push_str("\\\\"),
            '"'  => s.push_str("\\\""),
            '\n' => s.push_str("\\n"),
            '\r' => s.push_str("\\r"),
            '\t' => s.push_str("\\t"),
            _    => s.push(c),
        }
        i+=1;
    }
    s.push('"'); s
}

/// split CSV en respectant guillemets doubles
fn split_csv_quoted(s:&str)->Vec<&str>{
    let mut out=Vec::<&str>::new();
    let b=s.as_bytes();
    let mut i=0usize; let mut start=0usize; let mut in_d=false;
    while i<b.len() {
        let c=b[i] as char;
        if c=='"' {
            // quote toggle (non-échappé)
            if i>0 && b[i-1]==b'\\' { /* échappé, ignore */ }
            else { in_d = !in_d; }
        } else if c==',' && !in_d {
            out.push(s[start..i].trim());
            start=i+1;
        }
        i+=1;
    }
    out.push(s[start..].trim());
    out
}

fn fold_case(s:&str)->str{
    s.to_lower() // basique (latin)
}

/* ———————————————————— Doc-tests ———————————————————— */
//! fn _ini_smoke() {
//!     let txt = r#"
//! ; comment
//! [Core]
//! name = "Vitte Project"
//! path = C:\\tmp\\vitte  ; inline com
//! multi = line1\
//!   line2
//! nums = "1,2,3", 4, "5"
//! # bare
//! bare = unquoted
//! "#;
//!     let ini = parse_strict(txt).unwrap();
//!     assert(ini.get("Core.name").unwrap()=="Vitte Project");
//!     assert(ini.get("Core.path").unwrap()=="C:\\tmp\\vitte");
//!     assert(ini.get("Core.multi").unwrap()=="line1\n  line2");
//!     // CSV aware
//!     let v = ini.section("Core").get_list("nums");
//!     assert(v.len()==3);
//!
//!     // to_string round-trip (basique)
//!     let out = ini.to_string();
//!     assert(out.contains("[Core]"));
//!
//!     // tolérant
//!     let flat = parse("key=val\n=bad\n[Sec]\nx:42");
//!     assert(flat.get("key").unwrap()=="val");
//!     assert(flat.get("Sec.x").unwrap()=="42");
//! }
