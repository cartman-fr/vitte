//! cache.vitte — LRU + TTL cache, loader optionnel, janitor périodique (+ extras)
//!
//! Points forts :
//! - LRU + TTL par entrée (0 = jamais d’expiration)
//! - Politique `refresh_on_hit` (étend l’expiration à chaque hit)
//! - Stats : hits/misses/puts/evictions/expires
//! - API riche : get / get_mut / peek / remove / pop_lru / contains / clear / set_ttl / remaining_ttl
//! - Loader : get_or_load / get_or_try_load / get_or_load_with_key
//! - Capacity mgmt : set_capacity (évictions), len/is_empty/capacity
//! - Janitor périodique (spawn/stop) — optionnel
//! - Wrapper thread-safe : SharedTtlLru<K,V> (Mutex)
//!
//! NB: la “clock” (`now`) est injectable pour les tests.

#![version("0.1.0")]
#![strict]

use std::collections::{Map, VecDeque};
use std::sync::{Mutex, AtomicBool, AtomicU64};

pub struct TtlLru<K, V> {
    cap: usize,
    map: Map<K, Entry<V>>,
    order: VecDeque<K>,            // MRU en queue, LRU en tête
    default_ttl_ms: u64,           // 0 => jamais ; utilisé par put_default / refresh_on_hit
    refresh_on_hit: bool,          // rafraîchir TTL à la lecture (si ttl != 0)
    now: fn() -> u64,              // horloge (ms)
    stats: Stats,
}

#[derive(Clone)]
struct Entry<V> {
    val: V,
    exp_ms: u64,                   // 0 => jamais
    ttl_ms: u64,                   // pour refresh_on_hit
}

#[derive(Clone)]
struct Stats {
    hits: u64,
    misses: u64,
    puts: u64,
    evictions: u64,
    expires: u64,
}

impl Stats {
    fn new() -> Self { Self { hits:0, misses:0, puts:0, evictions:0, expires:0 } }
}

/* ———————————————————— Constructeurs / config ———————————————————— */

impl<K: Eq + std::hash::Hash + Clone, V> TtlLru<K, V> {
    pub fn with_capacity(cap: usize) -> Self {
        Self {
            cap: cap.max(1),
            map: Map::new(),
            order: VecDeque::new(),
            default_ttl_ms: 0,
            refresh_on_hit: false,
            now: || std::time::now().unix_millis() as u64,
            stats: Stats::new(),
        }
    }

    pub fn with_clock(cap: usize, clock: fn() -> u64) -> Self {
        let mut s = Self::with_capacity(cap);
        s.now = clock;
        s
    }

    pub fn with_default_ttl(mut self, ttl_ms: u64) -> Self { self.default_ttl_ms = ttl_ms; self }
    pub fn refresh_on_hit(mut self, yes: bool) -> Self { self.refresh_on_hit = yes; self }

    /* ———————————————————— Infos & réglages ———————————————————— */

    pub fn len(&self) -> usize { self.map.len() }
    pub fn is_empty(&self) -> bool { self.map.is_empty() }
    pub fn capacity(&self) -> usize { self.cap }
    pub fn stats(&self) -> (u64,u64,u64,u64,u64) {
        (self.stats.hits, self.stats.misses, self.stats.puts, self.stats.evictions, self.stats.expires)
    }

    pub fn set_capacity(&mut self, new_cap: usize) {
        self.cap = new_cap.max(1);
        self.evict_overflow();
    }

    /* ———————————————————— Core API ———————————————————— */

    /// put : insère/remplace avec TTL explicite (0 = jamais). Retourne true si remplacement.
    pub fn put(&mut self, k: K, v: V, ttl_ms: u64) -> bool {
        self.stats.puts += 1;
        let exp = if ttl_ms == 0 { 0 } else { (self.now)().saturating_add(ttl_ms) };
        let existed = self.map.contains_key(&k);
        self.map.insert(k.clone(), Entry { val: v, exp_ms: exp, ttl_ms });
        self.touch(&k);
        self.evict_overflow();
        existed
    }

    /// put_default : TTL = default_ttl_ms (peut être 0)
    pub fn put_default(&mut self, k: K, v: V) -> bool {
        self.put(k, v, self.default_ttl_ms)
    }

    /// get : renvoie &V, rafraîchit LRU ; expire si nécessaire ; rafraîchit TTL si policy active
    pub fn get(&mut self, k: &K) -> Option<&V> {
        if !self.map.contains_key(k) {
            self.stats.misses += 1;
            return None;
        }
        // expiration ?
        let now = (self.now)();
        let expired = {
            let e = self.map.get(k).unwrap();
            e.exp_ms != 0 && now > e.exp_ms
        };
        if expired {
            self.stats.expires += 1;
            self.map.remove(k);
            self.remove_from_order(k);
            self.stats.misses += 1;
            return None;
        }
        // refresh LRU
        self.touch(k);

        // refresh TTL (si policy active + ttl != 0)
        if self.refresh_on_hit {
            if let Some(ent) = self.map.get_mut(k) {
                if ent.ttl_ms != 0 {
                    ent.exp_ms = now.saturating_add(ent.ttl_ms);
                }
            }
        }
        self.stats.hits += 1;
        self.map.get(k).map(|e| &e.val)
    }

    /// get_mut : accède en mutable, sans changer d’ordre (mais on touche pour rester MRU)
    pub fn get_mut(&mut self, k: &K) -> Option<&mut V> {
        if self.get(k).is_none() { return None; } // gère expiration/hit/miss
        self.map.get_mut(k).map(|e| &mut e.val)
    }

    /// peek : lit sans toucher l’ordre ni rafraîchir TTL
    pub fn peek(&self, k: &K) -> Option<&V> {
        match self.map.get(k) {
            None => None,
            Some(e) => {
                if e.exp_ms != 0 && (self.now)() > e.exp_ms { None } else { Some(&e.val) }
            }
        }
    }

    pub fn contains_key(&self, k: &K) -> bool {
        match self.map.get(k) {
            None => false,
            Some(e) => e.exp_ms == 0 || (self.now)() <= e.exp_ms
        }
    }

    /// remove : supprime et retourne la valeur si présente et non expirée
    pub fn remove(&mut self, k: &K) -> Option<V> {
        let out = match self.map.get(k) {
            None => None,
            Some(e) => {
                if e.exp_ms != 0 && (self.now)() > e.exp_ms { None } else { Some(()) }
            }
        };
        if out.is_none() { return None; }
        self.remove_from_order(k);
        self.map.remove(k).map(|e| e.val)
    }

    /// pop_lru : éjecte l’élément le plus ancien (LRU)
    pub fn pop_lru(&mut self) -> Option<(K, V)> {
        let key = self.order.pop_front()?;
        if let Some(ent) = self.map.remove(&key) {
            self.stats.evictions += 1;
            return Some((key, ent.val));
        }
        None
    }

    /// clear : vide tout (sans changer cap)
    pub fn clear(&mut self) {
        self.map.clear();
        self.order.clear();
    }

    /// set_ttl : change le TTL d’une clé existante (0 = jamais). Retourne false si absente/expirée.
    pub fn set_ttl(&mut self, k: &K, ttl_ms: u64) -> bool {
        let now = (self.now)();
        if let Some(e) = self.map.get_mut(k) {
            if e.exp_ms != 0 && now > e.exp_ms {
                // expirée → purge
                self.map.remove(k);
                self.remove_from_order(k);
                self.stats.expires += 1;
                return false;
            }
            e.ttl_ms = ttl_ms;
            e.exp_ms = if ttl_ms == 0 { 0 } else { now.saturating_add(ttl_ms) };
            return true;
        }
        false
    }

    /// remaining_ttl_ms : TTL restant si applicable
    pub fn remaining_ttl_ms(&self, k: &K) -> Option<u64> {
        match self.map.get(k) {
            None => None,
            Some(e) => {
                if e.exp_ms == 0 { Some(u64::MAX) }
                else {
                    let now = (self.now)();
                    if now > e.exp_ms { Some(0) } else { Some(e.exp_ms - now) }
                }
            }
        }
    }

    /// expires_at_ms : timestamp d’expiration (0 = jamais)
    pub fn expires_at_ms(&self, k: &K) -> Option<u64> {
        self.map.get(k).map(|e| e.exp_ms)
    }

    /* ———————————————————— Loaders ———————————————————— */

    /// get_or_load : charge si absent/expiré
    pub fn get_or_load<F: FnOnce() -> V>(&mut self, k: K, ttl_ms: u64, load: F) -> &V {
        if self.get(&k).is_none() {
            let v = load();
            self.put(k.clone(), v, ttl_ms);
        }
        // sûr car put() vient de garantir la présence
        self.map.get(&k).map(|e| &e.val).unwrap()
    }

    /// get_or_try_load : loader peut échouer
    pub fn get_or_try_load<E, F: FnOnce() -> Result<V, E>>(&mut self, k: K, ttl_ms: u64, load: F)
        -> Result<&V, E>
    {
        if self.get(&k).is_none() {
            let v = load()?;
            self.put(k.clone(), v, ttl_ms);
        }
        Ok(self.map.get(&k).map(|e| &e.val).unwrap())
    }

    /// get_or_load_with_key : passe la clé au loader
    pub fn get_or_load_with_key<F: FnOnce(&K) -> V>(&mut self, k: K, ttl_ms: u64, load: F) -> &V {
        if self.get(&k).is_none() {
            let v = load(&k);
            self.put(k.clone(), v, ttl_ms);
        }
        self.map.get(&k).map(|e| &e.val).unwrap()
    }

    /* ———————————————————— Janitor ———————————————————— */

    /// janitor (synchrone) : supprime les expirés maintenant
    pub fn janitor(&mut self) {
        let now = (self.now)();
        // collecter pour éviter l’emprunt mutable pendant l’itération
        let keys: Vec<K> = self.map.keys().cloned().collect();
        for k in keys {
            if let Some(e) = self.map.get(&k) {
                if e.exp_ms != 0 && now > e.exp_ms {
                    self.map.remove(&k);
                    self.remove_from_order(&k);
                    self.stats.expires += 1;
                }
            }
        }
    }

    /// spawn_janitor : lance un thread qui passe le balai périodiquement.
    /// Retourne un handle pour l’arrêter proprement.
    pub fn spawn_janitor(self: &std::rc::Rc<std::cell::RefCell<Self>>, period_ms: u64) -> JanitorHandle {
        let stop = std::rc::Rc::new(AtomicBool::new(false));
        let me = self.clone();
        let stopper = stop.clone();
        let h = std::thread::spawn(move || {
            while !stopper.load() {
                {
                    let mut r = me.borrow_mut();
                    r.janitor();
                }
                std::time::sleep(period_ms as i64);
            }
        });
        JanitorHandle { stop: stop, join: Some(h) }
    }

    /* ———————————————————— internes ———————————————————— */

    fn touch(&mut self, k: &K) {
        self.remove_from_order(k);
        self.order.push_back(k.clone());
    }

    fn remove_from_order(&mut self, k: &K) {
        // O(n) mais n <= cap ; VecDeque → on cherche et remove au 1er match
        let mut idx = None;
        let mut i = 0;
        for key in self.order.iter() {
            if key == k { idx = Some(i); break; }
            i += 1;
        }
        if let Some(ix) = idx {
            // removal by index : recrée une deque
            let mut n = VecDeque::new();
            let mut j = 0;
            while let Some(x) = self.order.pop_front() {
                if j != ix { n.push_back(x); }
                j += 1;
            }
            self.order = n;
        }
    }

    fn evict_overflow(&mut self) {
        while self.order.len() > self.cap {
            if let Some(old) = self.order.pop_front() {
                if self.map.remove(&old).is_some() {
                    self.stats.evictions += 1;
                }
            }
        }
    }
}

/* ———————————————————— Janitor handle ———————————————————— */

pub struct JanitorHandle {
    stop: std::rc::Rc<AtomicBool>,
    join: Option<std::thread::JoinHandle>,
}
impl JanitorHandle {
    pub fn stop(mut self) {
        self.stop.store(true);
        if let Some(h) = self.join.take() { let _ = h.join(); }
    }
}
impl Drop for JanitorHandle {
    fn drop(&mut self) {
        self.stop.store(true);
        if let Some(h) = self.join.take() { let _ = h.join(); }
    }
}

/* ———————————————————— Wrapper thread-safe ———————————————————— */

pub struct SharedTtlLru<K, V> {
    inner: Mutex<TtlLru<K, V>>,
}

impl<K: Eq + std::hash::Hash + Clone, V> SharedTtlLru<K, V> {
    pub fn new(cap: usize) -> Self {
        Self { inner: Mutex::new(TtlLru::with_capacity(cap)) }
    }
    pub fn with_default_ttl(self, ttl_ms: u64) -> Self {
        let mut g = self.inner.lock();
        *g = std::mem::replace(&mut *g, TtlLru::with_capacity(g.capacity())).with_default_ttl(ttl_ms);
        drop(g);
        self
    }
    pub fn refresh_on_hit(self, yes: bool) -> Self {
        let mut g = self.inner.lock();
        g.refresh_on_hit = yes;
        drop(g);
        self
    }

    // Forward quelques méthodes utiles (tu peux en ajouter selon tes besoins)
    pub fn get(&self, k: &K) -> Option<V> where V: Clone {
        let mut g = self.inner.lock();
        g.get(k).cloned()
    }
    pub fn put(&self, k: K, v: V, ttl_ms: u64) -> bool {
        let mut g = self.inner.lock();
        g.put(k, v, ttl_ms)
    }
    pub fn remove(&self, k: &K) -> Option<V> {
        let mut g = self.inner.lock();
        g.remove(k)
    }
    pub fn len(&self) -> usize { self.inner.lock().len() }
    pub fn capacity(&self) -> usize { self.inner.lock().capacity() }
    pub fn set_capacity(&self, n: usize) { self.inner.lock().set_capacity(n); }
    pub fn janitor(&self) { self.inner.lock().janitor(); }
}

/* ———————————————————— Tests rapides (facultatif) ———————————————————— */
//! fn _smoke() {
//!     let mut c = TtlLru::<str, i32>::with_capacity(2).with_default_ttl(1000).refresh_on_hit(true);
//!     c.put("a".into(), 1, 50);
//!     c.put("b".into(), 2, 0);
//!     assert(c.get(&"a".into()).is_some());
//!     std::time::sleep(60);
//!     assert(c.get(&"a".into()).is_some()); // refresh_on_hit l’a prolongé
//!     c.put("c".into(), 3, 0); // évince LRU (probablement "b" si "a" a été touché)
//!     let (h,m,_,e,_) = { let (h,m,p,e,x) = c.stats(); (h,m,p,e,x) };
//!     assert(h>0 || m>=0 || e>=0);
//! }
