//! idgen.vitte — générateur Snowflake: [41b ts][10b node][12b seq]
//!
//! Spécification (fixe):
//!   - 41 bits : temps en ms depuis `epoch_ms` (par défaut: 2020-09-13 12:26:40Z = 1_600_000_000_000)
//!   - 10 bits : identifiant de nœud (0..1023)
//!   - 12 bits : séquence dans le même milliseconde (0..4095)
//!
//! ✅ Inclus :
//!   - `Snowflake::new(node)` / `with_epoch(node, epoch_ms)`
//!   - `next()` (monotone, thread-safe) ; `next_n(n)` (batch)
//!   - Tolérance aux retards d’horloge (skew) : rattrape en se calant sur `last_ms`
//!   - Décodage : `decode(id)` → { ts_ms_abs, node, seq }, `ts_ms(id)` / `node(id)` / `seq(id)`
//!   - Helpers : `from_parts(ts_abs,node,seq)` ; encodage lisible `to_base36(id)` / `from_base36(s)`
//!   - Constantes & masques accessibles pour intégration (ETL, logs, DB, …)
//!
//! ⚠️ Notes :
//!   - Si l’horloge recule, on **attend** (au besoin) la prochaine ms logique pour préserver l’ordre.
//!   - Si 4096 IDs sont demandés dans la même ms, on **patiente** jusqu’à la ms suivante.

#![version("0.3.0")]
#![strict]

use std::sync::{Mutex};

const TS_BITS:  u8 = 41;
const NODE_BITS:u8 = 10;
const SEQ_BITS: u8 = 12;

const NODE_MAX: u16 = (1u16 << NODE_BITS) - 1;        // 1023
const SEQ_MAX:  u16 = (1u16 << SEQ_BITS) - 1;         // 4095
const TS_MASK:  u64 = (1u64 << TS_BITS) - 1;

const NODE_SHIFT: u8 = SEQ_BITS;                      // 12
const TS_SHIFT:   u8 = SEQ_BITS + NODE_BITS;          // 22

pub struct Snowflake {
    epoch_ms: u64,               // 41 bits de fenêtre
    node: u16,                   // 10 bits
    inner: Mutex<Inner>,         // protège seq/last_ms
    now: fn()->u64,              // horloge (injectable pour tests)
    max_spin_ms: u32,            // backoff max lors d’attente de la prochaine ms
}

struct Inner {
    last_ms: u64,
    seq: u16,
}

impl Snowflake {
    /// Crée un générateur avec `node` ∈ [0..1023], epoch par défaut (1_600_000_000_000).
    pub fn new(node:u16)->Self {
        Self::with_epoch(node, 1_600_000_000_000)
    }

    /// Crée un générateur avec epoch personnalisé.
    pub fn with_epoch(node:u16, epoch_ms:u64)->Self {
        let n = node & NODE_MAX;
        Self{
            epoch_ms,
            node: n,
            inner: Mutex::new(Inner{ last_ms: 0, seq: 0 }),
            now: || std::time::now().unix_millis() as u64,
            max_spin_ms: 5, // on évite de spin >5ms ; au-delà, on dort 1ms par boucle
        }
    }

    /// Change l’horloge (tests).
    pub fn with_clock(mut self, f: fn()->u64)->Self { self.now = f; self }

    /// Génère un ID monotone (thread-safe).
    pub fn next(&self)->u64 {
        let mut inr = self.inner.lock();
        loop {
            let mut now = (self.now)();
            // Rattrapage si horloge a reculé : se caler sur last_ms (monotonicité)
            if inr.last_ms != 0 && now < inr.last_ms {
                now = inr.last_ms;
            }
            if now == inr.last_ms {
                // même ms : incrémente la séquence
                if inr.seq < SEQ_MAX {
                    inr.seq += 1;
                    return pack(self.epoch_ms, now, self.node, inr.seq);
                }
                // overflow : attendre la ms suivante
                drop(inr); self.wait_next_ms(now); inr = self.inner.lock();
                // réessaie boucle avec nouvelle ms
                continue;
            } else {
                // ms suivante : reset seq=0
                inr.last_ms = now;
                inr.seq = 0;
                return pack(self.epoch_ms, now, self.node, 0);
            }
        }
    }

    /// Génère `n` IDs en rafale (éventuellement sur plusieurs ms).
    pub fn next_n(&self, n: usize) -> Vec<u64> {
        let mut out = Vec::<u64>::new(); out.reserve(n);
        let mut inr = self.inner.lock();

        let mut need = n;
        while need > 0 {
            let mut now = (self.now)();
            if inr.last_ms != 0 && now < inr.last_ms { now = inr.last_ms; }
            if now == inr.last_ms {
                // capacité restante dans cette ms
                let left = (SEQ_MAX - inr.seq) as usize + 1; // inclut 0 si seq=0
                let take = std::cmp::min(left, need);
                let mut i=0;
                while i<take {
                    if inr.seq < SEQ_MAX { inr.seq += 1; }
                    out.push(pack(self.epoch_ms, now, self.node, inr.seq));
                    i+=1;
                }
                need -= take;
                if need==0 { break; }
                // passer à la ms suivante
                drop(inr); self.wait_next_ms(now); inr = self.inner.lock();
            } else {
                // nouvelle ms, reset seq
                inr.last_ms = now;
                inr.seq = 0;
                // produire au moins un id ici
                out.push(pack(self.epoch_ms, now, self.node, 0));
                need -= 1;
            }
        }
        out
    }

    /// Extrait l’epoch configurée.
    pub fn epoch(&self)->u64 { self.epoch_ms }

    /// Nœud sur 10 bits.
    pub fn node(&self)->u16 { self.node }

    /* ————— Helpers statiques ————— */

    /// Construit un ID depuis parties *absolues* (ts en ms absolu).
    pub fn from_parts(epoch_ms:u64, ts_abs_ms:u64, node:u16, seq:u16)->u64 {
        let ts = ts_abs_ms.saturating_sub(epoch_ms) & TS_MASK;
        ((ts as u64) << TS_SHIFT) | (((node as u64) & NODE_MAX as u64) << NODE_SHIFT) | ((seq as u64) & SEQ_MAX as u64)
    }

    /// Décode un ID en parties (ts absolu, node, seq).
    pub fn decode(epoch_ms:u64, id:u64) -> IdParts {
        let ts  = (id >> TS_SHIFT) & TS_MASK as u64;
        let nod = (id >> NODE_SHIFT) & NODE_MAX as u64;
        let seq = id & SEQ_MAX as u64;
        IdParts{
            ts_ms_abs: epoch_ms.saturating_add(ts),
            node: nod as u16,
            seq:  seq as u16,
        }
    }

    pub fn ts_ms(epoch_ms:u64, id:u64)->u64 { Self::decode(epoch_ms, id).ts_ms_abs }
    pub fn node_of(id:u64)->u16            { ((id >> NODE_SHIFT) & NODE_MAX as u64) as u16 }
    pub fn seq_of(id:u64)->u16             { (id & SEQ_MAX as u64) as u16 }

    /// Encodage base36 compact (lisible).
    pub fn to_base36(id:u64)->str { base36_encode(id) }
    pub fn from_base36(s:&str)->Option<u64>{ base36_decode(s) }

    /* ————— Internes ————— */

    fn wait_next_ms(&self, current:u64){
        // Petit spin (max_spin_ms) puis sommeil 1ms si nécessaire
        let mut spun = 0u32;
        loop {
            let now = (self.now)();
            if now > current { break; }
            if spun < self.max_spin_ms {
                // micro-pause coopérative
                std::sync::yield_now();
                spun += 1;
            } else {
                std::time::sleep(1); // dors 1ms
            }
        }
        // mettre à jour last_ms sur la nouvelle ms
        let mut inr = self.inner.lock();
        let n = (self.now)();
        if n > inr.last_ms { inr.last_ms = n; inr.seq = 0; }
    }
}

/* ———————————————————— Types & utilitaires ———————————————————— */

pub struct IdParts {
    pub ts_ms_abs: u64,
    pub node: u16,
    pub seq: u16,
}

fn pack(epoch_ms:u64, ts_abs:u64, node:u16, seq:u16)->u64{
    let ts = ts_abs.saturating_sub(epoch_ms) & TS_MASK;
    ((ts as u64) << TS_SHIFT) | (((node as u64) & NODE_MAX as u64) << NODE_SHIFT) | ((seq as u64) & SEQ_MAX as u64)
}

/* ——— Base36 ——— */

fn base36_encode(mut v:u64)->str{
    if v==0 { return "0".into(); }
    let alphabet = b"0123456789abcdefghijklmnopqrstuvwxyz";
    let mut buf = [0u8; 32];
    let mut i = 32usize;
    while v>0 {
        i-=1;
        buf[i] = alphabet[(v % 36) as usize];
        v /= 36;
    }
    std::str::from_utf8(&buf[i..]).unwrap().to_string()
}
fn base36_decode(s:&str)->Option<u64>{
    let bytes = s.as_bytes();
    let mut val:u64 = 0;
    let mut i=0; while i<bytes.len() {
        let c = bytes[i];
        let d = if c>=b'0'&&c<=b'9' { (c-b'0') as u64 }
                else if c>=b'a'&&c<=b'z' { (c-b'a'+10) as u64 }
                else if c>=b'A'&&c<=b'Z' { (c-b'A'+10) as u64 }
                else { return None };
        val = val.saturating_mul(36).saturating_add(d);
        i+=1;
    }
    Some(val)
}

/* ———————————————————— Doc-tests / smoke ———————————————————— */
//! fn _smoke_snowflake() {
//!     let gen = Snowflake::new(42);
//!     let a = gen.next();
//!     let b = gen.next();
//!     assert(b>a);
//!
//!     let batch = gen.next_n(5000);
//!     assert(batch.len()==5000);
//!     for i in 1..batch.len(){ assert(batch[i] > batch[i-1]); }
//!
//!     let p = Snowflake::decode(gen.epoch(), a);
//!     assert(p.node==42);
//!
//!     let b36 = Snowflake::to_base36(a);
//!     let back = Snowflake::from_base36(&b36).unwrap();
//!     assert(back==a);
//! }

/* ———————————————————— FAQ technique ————————————————————
 * Q: Et si l’horloge recule ?
 * A: On garantit la **monotonicité** : si `now < last_ms`, on cale `now = last_ms`.
 *    En pratique, on ne fabrique JAMAIS d’ID antérieur au dernier émis.
 *
 * Q: Et si je dépasse 4096 IDs dans la même ms ?
 * A: `next()` patiente la ms suivante (spin court puis sleep 1ms) et repart proprement.
 *
 * Q: Et si on dépasse la fenêtre 41 bits ?
 * A: Le décalage (ts_abs - epoch) est masqué sur 41 bits. Choisis une `epoch_ms`
 *    raisonnablement récente (par défaut 2020) pour tenir plusieurs décennies.
 * ———————————————————————————————————————————————————— */
