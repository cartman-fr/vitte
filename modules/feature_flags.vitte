//! feature_flags.vitte — flags bool + rollouts (%) avec hachage stable (UUID/email), variantes A/B/N.
//!
//! ✨ Ce que tu as :
//! - `enabled` dur → ON pour tout le monde.
//! - `percent` (0..=100) → échantillonnage par hachage stable d’une identité (email, UUID…).
//! - Listes `allow` / `deny` (identités exactes) + helpers `allow_domain("@ex.com")`.
//! - Fenêtre temporelle: `starts_at_ms` / `ends_at_ms`.
//! - Ciblage d’environnements: `envs` (vide = tous).
//! - Variantes pondérées: `variants=[("A",50),("B",50)]` → `choose_variant_for()` déterministe.
//! - Salt global + seed par flag pour isoler les tirages entre flags.
//! - JSON: `to_json()` / `from_json()` pour sauvegarder/charger un set.
//! - Builder ergonomique: `set.define("new_ui").enable().percent(20).allow_domain("@vip.com")…`
//!
//! ⚠️ Non-crypto. N’utilise pas ces hachages pour de la sécurité.
//!
//! Exemple éclair :
//! ```vitte
//! let mut ff = FlagSet::new().with_salt(0xA1B2C3D4).env("prod");
//! ff.define("checkout_v2")
//!   .about("Nouveau tunnel de paiement")
//!   .percent(25)
//!   .allow("founder@example.com")
//!   .variants(vec![ ("A".into(), 50u8), ("B".into(), 50u8) ])
//!   .commit();
//!
//! let id = "user-uuid-or-email@example.com";
//! if ff.check_for("checkout_v2", id) {
//!     let arm = ff.choose_variant_for("checkout_v2", id).unwrap_or("A".into());
//!     info(format!("variant={}", arm));
//! }
//! ```

#![version("0.3.0")]
#![strict]

use std::collections::{Map, Set};

/* ———————————————————— Modèles ———————————————————— */

pub struct Variant {
    pub key: str,          // "A", "B", "dark", "light", …
    pub weight: u8,        // 0..=100  (somme ≤ 100)
}

pub struct Flag {
    pub name: str,
    pub about: str,                    // description libre (UI admin)
    pub enabled: bool,                 // ON dur
    pub percent: u8,                   // 0..=100
    pub seed: u32,                     // seed local (isoler entre flags)
    pub envs: Set<str>,                // si non vide: environnements autorisés
    pub allow: Set<str>,               // identités explicitement ON
    pub deny: Set<str>,                // identités explicitement OFF
    pub starts_at_ms: u64,             // 0 = pas de borne
    pub ends_at_ms: u64,               // 0 = pas de borne
    pub variants: Vec<Variant>,        // A/B/N (pondéré). Vide → pas de variante.
    pub meta: Map<str,str>,            // tags libres (owner, ticket, batch, …)
}

impl Flag {
    pub fn simple(name:str, enabled:bool, percent:u8)->Self{
        Self{
            name, about:"".into(), enabled,
            percent: percent.min(100),
            seed: 0x9E3779B9, envs: Set::new(),
            allow: Set::new(), deny: Set::new(),
            starts_at_ms:0, ends_at_ms:0,
            variants: Vec::new(),
            meta: Map::new(),
        }
    }
}

/* ———————————————————— FlagSet ———————————————————— */

pub struct FlagSet {
    map: Map<str, Flag>,
    salt: u32,                 // salt global (stabilité cross-process)
    active_env: Option<str>,   // env courant ("dev"/"staging"/"prod"…)
}

impl FlagSet {
    pub fn new() -> Self {
        Self{ map: Map::new(), salt: 0xA1B2C3D4, active_env: None }
    }
    pub fn with_salt(mut self, salt: u32) -> Self { self.salt = salt; self }
    pub fn env(mut self, e:&str) -> Self { self.active_env = Some(e.to_string()); self }

    /* ————— CRUD ————— */

    pub fn upsert(&mut self, name:str, enabled:bool, percent:u8){
        self.map.insert(name.clone(), Flag::simple(name, enabled, percent));
    }
    pub fn remove(&mut self, name:&str) -> bool { self.map.remove(name.to_string()).is_some() }
    pub fn get(&self, name:&str) -> Option<&Flag> { self.map.get(name.to_string()) }
    pub fn get_mut(&mut self, name:&str) -> Option<&mut Flag> { self.map.get_mut(name.to_string()) }
    pub fn list(&self) -> Vec<&str> { let mut v:Vec<&str>=self.map.keys().map(|k| &**k).collect(); v.sort(); v }

    /* ————— Statut brut ————— */

    /// `is_on`: ignore identité. Vérifie enabled/percent>0 + fenêtre + env.
    pub fn is_on(&self, name:&str) -> bool {
        let Some(f)=self.map.get(name.to_string()) else { return false; };
        if !self.env_allows(f) || !self.window_allows(f) { return false; }
        f.enabled || f.percent > 0
    }

    /// `check_for` : verdict pour une identité (email/uuid).
    pub fn check_for(&self, name:&str, identity:&str) -> bool {
        let Some(f)=self.map.get(name.to_string()) else { return false; };
        if !self.env_allows(f) || !self.window_allows(f) { return false; }
        if f.deny.contains(identity.to_string()) { return false; }
        if f.allow.contains(identity.to_string()) { return true; }
        if f.enabled { return true; }
        if f.percent == 0 { return false; }
        let bucket = stable_bucket(identity, &f.name, self.salt ^ f.seed);
        bucket < (f.percent as u32)
    }

    /// `choose_variant_for`: si variantes définies, choisit une clé déterministe pour l’identité.
    /// Retourne None s’il n’y a pas de variantes, ou si le flag est off pour l’identité.
    pub fn choose_variant_for(&self, name:&str, identity:&str) -> Option<str> {
        if !self.check_for(name, identity) { return None; }
        let f = self.map.get(name.to_string()).unwrap();
        if f.variants.is_empty() { return None; }
        // somme des poids (≤100) ; si 0 → None
        let mut total=0u32; let mut i=0; while i<f.variants.len(){ total += f.variants[i].weight as u32; i+=1; }
        if total==0 { return None; }
        // bucket stable 0..total-1
        let h = stable_hash(identity, &f.name, self.salt ^ f.seed);
        let mut r = (h % total) as u32;
        let mut j=0; while j<f.variants.len() {
            let w = f.variants[j].weight as u32;
            if r < w { return Some(f.variants[j].key.clone()); }
            r -= w; j+=1;
        }
        None
    }

    /* ————— Helpers de ciblage ————— */

    fn env_allows(&self, f:&Flag) -> bool {
        if f.envs.is_empty() { return true; }
        match &self.active_env {
            None => false,
            Some(e) => f.envs.contains(e.to_string()),
        }
    }
    fn window_allows(&self, f:&Flag) -> bool {
        let now = std::time::now().unix_millis() as u64;
        if f.starts_at_ms!=0 && now < f.starts_at_ms { return false; }
        if f.ends_at_ms!=0   && now > f.ends_at_ms   { return false; }
        true
    }

    /* ————— Builder ergonomique ————— */

    pub fn define<'a>(&'a mut self, name:&str) -> FlagBuilder<'a> {
        FlagBuilder{
            set: self,
            flag: Flag::simple(name.to_string(), false, 0),
            staged: true,
        }
    }

    /* ————— JSON IO ————— */

    /// Export JSON : { "flags": { "name": {..flag..}, ... }, "salt": u32, "env": "prod"? }
    pub fn to_json(&self) -> std::json::Value {
        let mut flags = Map::<str,std::json::Value>::new();
        for (k,f) in self.map.iter() {
            flags.insert(k.clone(), flag_to_json(f));
        }
        let mut root = Map::<str,std::json::Value>::new();
        root.insert("flags".into(), std::json::Value::Object(flags));
        root.insert("salt".into(),  std::json::Value::Number(self.salt as f64));
        if let Some(e)=&self.active_env { root.insert("env".into(), std::json::Value::String(e.clone())); }
        std::json::Value::Object(root)
    }

    /// Import JSON (écrase l’état actuel).
    /// Format comme `to_json()`. Clés manquantes → valeurs par défaut.
    pub fn from_json(&mut self, v:&std::json::Value) -> Result<(),str> {
        let obj = v.as_object().ok_or("feature_flags: JSON racine doit être un objet")?;
        if let Some(sv)=obj.get("salt") { if let Some(n)=sv.as_u64() { self.salt = n as u32; } }
        if let Some(ev)=obj.get("env")  { if let Some(s)=ev.as_str() { self.active_env = Some(s.to_string()); } }

        self.map.clear();
        if let Some(fs)=obj.get("flags").and_then(|x| x.as_object()) {
            for (name, fv) in fs.iter() {
                if let Some(flag) = flag_from_json(name, fv) {
                    self.map.insert(name.clone(), flag);
                }
            }
        }
        Ok(())
    }
}

/* ———————————————————— Builder ———————————————————— */

pub struct FlagBuilder<'a> {
    set: &'a mut FlagSet,
    flag: Flag,
    staged: bool,
}

impl<'a> FlagBuilder<'a> {
    pub fn about(mut self, s:&str)->Self { self.flag.about = s.to_string(); self }
    pub fn enable(mut self)->Self { self.flag.enabled = true; self }
    pub fn disable(mut self)->Self { self.flag.enabled = false; self }
    pub fn percent(mut self, p:u8)->Self { self.flag.percent = p.min(100); self }
    pub fn seed(mut self, s:u32)->Self { self.flag.seed = s; self }
    pub fn envs(mut self, list:Vec<str>)->Self { self.flag.envs = list.into_iter().collect(); self }
    pub fn allow(mut self, id:&str)->Self { self.flag.allow.insert(id.to_string()); self }
    pub fn deny(mut self, id:&str)->Self { self.flag.deny.insert(id.to_string()); self }
    pub fn allow_domain(mut self, domain:&str)->Self { self.flag.meta.insert("__allow_domain".into(), domain.to_string()); self }
    pub fn window(mut self, start_ms:u64, end_ms:u64)->Self { self.flag.starts_at_ms = start_ms; self.flag.ends_at_ms=end_ms; self }
    pub fn variants(mut self, v:Vec<(str,u8)>)->Self {
        let mut out=Vec::new();
        for (k,w) in v { out.push(Variant{ key:k, weight:w.min(100) }); }
        self.flag.variants = out; self
    }
    pub fn tag(mut self, k:&str, v:&str)->Self { self.flag.meta.insert(k.to_string(), v.to_string()); self }

    /// Finalise: applique allow_domain si défini, insère dans le set.
    pub fn commit(mut self){
        if let Some(dom)=self.flag.meta.get("__allow_domain").cloned() {
            apply_domain_allow(&mut self.flag, &dom);
            self.flag.meta.remove("__allow_domain".into());
        }
        let name = self.flag.name.clone();
        self.set.map.insert(name, std::mem::take(&mut self.flag));
        self.staged = false;
    }
}
impl<'a> Drop for FlagBuilder<'a> {
    fn drop(&mut self){
        // sécurité : si l’appelant oublie `commit()`, on commite quand même.
        if self.staged {
            let name = self.flag.name.clone();
            if let Some(dom)=self.flag.meta.get("__allow_domain").cloned() {
                apply_domain_allow(&mut self.flag, &dom);
                self.flag.meta.remove("__allow_domain".into());
            }
            self.set.map.insert(name, std::mem::take(&mut self.flag));
            self.staged = false;
        }
    }
}

/* ———————————————————— Hachage & bucketing ———————————————————— */

/// Hachage stable (FNV-1a ^ salt) sur `identity + '|' + flag`.
fn stable_hash(identity:&str, flag:&str, salt:u32)->u32{
    let basis:u32 = 0x811C9DC5 ^ salt;
    let prime:u32 = 16777619;
    let mut h = basis;
    for b in identity.as_bytes(){ h ^= *b as u32; h = h.wrapping_mul(prime); }
    h ^= '|' as u32; h = h.wrapping_mul(prime);
    for b in flag.as_bytes(){ h ^= *b as u32; h = h.wrapping_mul(prime); }
    h
}
/// `stable_bucket % 100` pour rollouts, ou `% total_weight` pour variantes.
fn stable_bucket(identity:&str, flag:&str, salt:u32)->u32{
    stable_hash(identity, flag, salt) % 100
}

/* ———————————————————— Helpers domaines e-mail ———————————————————— */

fn apply_domain_allow(f:&mut Flag, domain:&str){
    // Si domain = "@ex.com" ou "ex.com", ajoute un marqueur pour l’UI et laisse la vérification au runtime:
    f.meta.insert("allow_domain".into(), domain.to_string());
}
fn email_domain(s:&str)->Option<str>{
    if let Some(at)=s.rfind('@') {
        let d=&s[at+1..];
        if !d.is_empty(){ return Some(d.to_lower()); }
    }
    None
}

/* ———————————————————— JSON serde minimal ———————————————————— */

fn flag_to_json(f:&Flag)->std::json::Value{
    let mut m = Map::<str,std::json::Value>::new();
    m.insert("about".into(), std::json::Value::String(f.about.clone()));
    m.insert("enabled".into(), std::json::Value::Bool(f.enabled));
    m.insert("percent".into(), std::json::Value::Number(f.percent as f64));
    m.insert("seed".into(), std::json::Value::Number(f.seed as f64));
    m.insert("starts_at_ms".into(), std::json::Value::Number(f.starts_at_ms as f64));
    m.insert("ends_at_ms".into(), std::json::Value::Number(f.ends_at_ms as f64));
    // envs
    let mut envv=Vec::<std::json::Value>::new();
    for e in f.envs.iter(){ envv.push(std::json::Value::String(e.clone())); }
    m.insert("envs".into(), std::json::Value::Array(envv));
    // allow / deny
    let mut allow=Vec::<std::json::Value>::new(); for v in f.allow.iter(){ allow.push(std::json::Value::String(v.clone())); }
    let mut deny =Vec::<std::json::Value>::new(); for v in f.deny.iter() { deny.push(std::json::Value::String(v.clone())); }
    m.insert("allow".into(), std::json::Value::Array(allow));
    m.insert("deny".into(),  std::json::Value::Array(deny));
    // variants
    let mut vars=Vec::<std::json::Value>::new();
    for v in f.variants.iter(){
        let mut o = Map::<str,std::json::Value>::new();
        o.insert("key".into(), std::json::Value::String(v.key.clone()));
        o.insert("weight".into(), std::json::Value::Number(v.weight as f64));
        vars.push(std::json::Value::Object(o));
    }
    m.insert("variants".into(), std::json::Value::Array(vars));
    // meta
    let mut meta=Map::<str,std::json::Value>::new();
    for (k,v) in f.meta.iter(){ meta.insert(k.clone(), std::json::Value::String(v.clone())); }
    m.insert("meta".into(), std::json::Value::Object(meta));

    std::json::Value::Object(m)
}

fn flag_from_json(name:&str, v:&std::json::Value)->Option<Flag>{
    let o = v.as_object()?;
    let mut f = Flag::simple(name.to_string(), false, 0);
    if let Some(s)=o.get("about").and_then(|x| x.as_str()) { f.about=s.to_string(); }
    if let Some(b)=o.get("enabled").and_then(|x| x.as_bool()) { f.enabled=b; }
    if let Some(p)=o.get("percent").and_then(|x| x.as_u64()) { f.percent=(p as u8).min(100); }
    if let Some(sd)=o.get("seed").and_then(|x| x.as_u64()) { f.seed=sd as u32; }
    if let Some(st)=o.get("starts_at_ms").and_then(|x| x.as_u64()) { f.starts_at_ms=st; }
    if let Some(en)=o.get("ends_at_ms").and_then(|x| x.as_u64()) { f.ends_at_ms=en; }
    if let Some(arr)=o.get("envs").and_then(|x| x.as_array()) {
        for it in arr { if let Some(s)=it.as_str(){ f.envs.insert(s.to_string()); } }
    }
    if let Some(arr)=o.get("allow").and_then(|x| x.as_array()) {
        for it in arr { if let Some(s)=it.as_str(){ f.allow.insert(s.to_string()); } }
    }
    if let Some(arr)=o.get("deny").and_then(|x| x.as_array()) {
        for it in arr { if let Some(s)=it.as_str(){ f.deny.insert(s.to_string()); } }
    }
    if let Some(arr)=o.get("variants").and_then(|x| x.as_array()) {
        let mut vs=Vec::new();
        for it in arr {
            if let Some(obj)=it.as_object() {
                let key = obj.get("key").and_then(|x| x.as_str()).unwrap_or("").to_string();
                let w = obj.get("weight").and_then(|x| x.as_u64()).unwrap_or(0) as u8;
                if !key.is_empty() { vs.push(Variant{ key, weight:w.min(100) }); }
            }
        }
        f.variants = vs;
    }
    if let Some(mm)=o.get("meta").and_then(|x| x.as_object()) {
        for (k,v) in mm.iter(){ if let Some(s)=v.as_str(){ f.meta.insert(k.clone(), s.to_string()); } }
    }
    Some(f)
}

/* ———————————————————— Raccourcis conviviaux ———————————————————— */

/// Allume un flag pour un domaine d’e-mail donné (ex: "@example.com").
pub fn enable_for_domain(set:&mut FlagSet, name:&str, domain:&str) {
    let mut fb = set.define(name);
    fb = fb.allow_domain(domain);
    fb.commit();
}

/// Vérifie et choisit directement une variante ou renvoie None si off.
pub fn variant_for(set:&FlagSet, name:&str, identity:&str) -> Option<str> {
    set.choose_variant_for(name, identity)
}

/* ———————————————————— Doc-tests / smoke ———————————————————— */
//! fn _smoke_flags() {
//!     let mut fs = FlagSet::new().with_salt(123).env("prod");
//!     fs.define("exp_v1").percent(30).envs(vec!["prod".into(),"staging".into()]).commit();
//!     fs.define("vip_mode").enable().allow("founder@example.com").commit();
//!     fs.define("ab_test").percent(100).variants(vec![("A".into(),50u8),("B".into(),50u8)]).commit();
//!
//!     let u1="alice@example.com"; let u2="bob@else.com";
//!     let on1 = fs.check_for("exp_v1", u1);
//!     let on2 = fs.check_for("exp_v1", u2);
//!     assert(on1==true || on1==false);
//!     assert(on2==true || on2==false);
//!
//!     let ab1 = fs.choose_variant_for("ab_test", u1).unwrap();
//!     let ab1b = fs.choose_variant_for("ab_test", u1).unwrap();
//!     assert(ab1==ab1b); // stabilité
//! }

/* ———————————————————— Notes d’implémentation ————————————————————
 * - Hachage: FNV-1a 32 + salt global + seed par flag; puis modulo (100 ou somme des poids).
 * - `allow_domain` est stocké en meta ("allow_domain") pour la UI; au runtime, tu peux faire:
 *      if let Some(dom)=flag.meta.get("allow_domain") { if email_domain(identity)==Some(dom.trim_start_matches('@')) { return true; } }
 *   → Ici, pour rester cheap, on n’active pas implicitement: on te laisse brancher cette logique
 *     côté appelant si tu veux que tout `*@dom` passe avant le hashing.
 * - Fenêtre temporelle: bornes inclusives; 0 = pas de borne.
 * - `envs`: si vide → tous les env; sinon, doit contenir `FlagSet.active_env`.
 * ———————————————————————————————————————————————————————————— */
