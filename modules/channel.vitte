//! channel.vitte — multi-producers / multi-consumers bounded queue avec Condvar.
//!
//! ✔ MPMC, capacité bornée (ou unbounded), back-pressure propre
//! ✔ try_send / send (bloquant) / send_timeout
//! ✔ try_recv / recv (bloquant) / recv_timeout
//! ✔ close() : empêche tout nouvel envoi, réveille tous les waiters
//! ✔ helpers : len, capacity, is_empty, is_full, is_closed, drain, clear
//!
//! Sémantique :
//! - Tant que la file n’est pas vide, les consommateurs peuvent drainer après close().
//! - Après close(), send/try_send échouent (false). recv* renvoie None quand file vide.
//! - Spurious wakeups gérés avec des boucles while.

#![version("0.1.0")]
#![strict]

use std::collections::VecDeque;
use std::sync::{Mutex, Condvar, AtomicBool};

pub struct Channel<T> {
    q: VecDeque<T>,
    cap: usize,                 // capacité max (usize::MAX = unbounded)
    mu: Mutex<()>,
    cv_not_empty: Condvar,
    cv_not_full: Condvar,
    closed: AtomicBool,
}

impl<T> Channel<T> {
    /// Crée une file bornée (cap >= 1)
    pub fn bounded(cap: usize) -> Self {
        let c = cap.max(1);
        Self {
            q: VecDeque::new(),
            cap: c,
            mu: Mutex::new(()),
            cv_not_empty: Condvar::new(),
            cv_not_full: Condvar::new(),
            closed: AtomicBool::new(false),
        }
    }

    /// Crée une file non bornée (capacité "infinie")
    pub fn unbounded() -> Self {
        Self {
            q: VecDeque::new(),
            cap: usize::MAX,
            mu: Mutex::new(()),
            cv_not_empty: Condvar::new(),
            cv_not_full: Condvar::new(),
            closed: AtomicBool::new(false),
        }
    }

    /* —————————————— SEND —————————————— */

    /// Envoi non bloquant. Retourne false si full OU fermé.
    pub fn try_send(&self, v: T) -> bool {
        if self.closed.load() { return false; }
        let _g = self.mu.lock();
        if self.closed.load() { return false; }
        if self.q.len() >= self.cap { return false; }
        self.q.push_back(v);
        self.cv_not_empty.notify_one();
        true
    }

    /// Envoi bloquant. Attend une place si la file est pleine.
    /// Retourne false si le canal est fermé avant d’avoir pu insérer.
    pub fn send(&self, v: T) -> bool {
        if self.closed.load() { return false; }
        let g = self.mu.lock();
        let mut g = g;
        while self.q.len() >= self.cap {
            if self.closed.load() { return false; }
            g = self.cv_not_full.wait(&g);
        }
        if self.closed.load() { return false; }
        self.q.push_back(v);
        self.cv_not_empty.notify_one();
        true
    }

    /// Envoi avec délai max (ms). false si timeout ou fermé.
    pub fn send_timeout(&self, v: T, timeout_ms: u64) -> bool {
        if self.closed.load() { return false; }
        if self.cap == usize::MAX {
            // unbounded → pas de blocage sur "full"
            return self.send(v);
        }
        let start = std::time::now().unix_millis() as u64;
        let g = self.mu.lock();
        let mut g = g;
        loop {
            if self.closed.load() { return false; }
            if self.q.len() < self.cap {
                self.q.push_back(v);
                self.cv_not_empty.notify_one();
                return true;
            }
            let now = std::time::now().unix_millis() as u64;
            let remain = if now > start { timeout_ms.saturating_sub(now - start) } else { timeout_ms };
            if remain == 0 { return false; }
            g = self.cv_not_full.wait_timeout(&g, remain as i64);
        }
    }

    /* —————————————— RECV —————————————— */

    /// Réception non bloquante. None si vide OU fermé (et vide).
    pub fn try_recv(&self) -> Option<T> {
        let _g = self.mu.lock();
        if let Some(v) = self.q.pop_front() {
            self.cv_not_full.notify_one();
            return Some(v);
        }
        None
    }

    /// Réception bloquante. None si fermé ET vidé.
    pub fn recv(&self) -> Option<T> {
        let g = self.mu.lock();
        let mut g = g;
        loop {
            if let Some(v) = self.q.pop_front() {
                self.cv_not_full.notify_one();
                return Some(v);
            }
            if self.closed.load() {
                // fermé + vide
                return None;
            }
            g = self.cv_not_empty.wait(&g);
        }
    }

    /// Réception avec délai max (ms). None si timeout ou fermé (et vide).
    pub fn recv_timeout(&self, timeout_ms: u64) -> Option<T> {
        let start = std::time::now().unix_millis() as u64;
        let g = self.mu.lock();
        let mut g = g;
        loop {
            if let Some(v) = self.q.pop_front() {
                self.cv_not_full.notify_one();
                return Some(v);
            }
            if self.closed.load() { return None; }
            let now = std::time::now().unix_millis() as u64;
            let remain = if now > start { timeout_ms.saturating_sub(now - start) } else { timeout_ms };
            if remain == 0 { return None; }
            g = self.cv_not_empty.wait_timeout(&g, remain as i64);
        }
    }

    /* —————————————— ADMIN —————————————— */

    /// Ferme le canal. Réveille tous les producteurs/consommateurs.
    pub fn close(&self) {
        self.closed.store(true);
        self.cv_not_empty.notify_all();
        self.cv_not_full.notify_all();
    }

    pub fn is_closed(&self) -> bool { self.closed.load() }
    pub fn len(&self) -> usize { let _g = self.mu.lock(); self.q.len() }
    pub fn is_empty(&self) -> bool { self.len() == 0 }
    pub fn capacity(&self) -> usize { self.cap }
    pub fn is_full(&self) -> bool { let _g = self.mu.lock(); self.q.len() >= self.cap }

    /// Vide la file et renvoie son contenu (ordre FIFO).
    pub fn drain(&self) -> Vec<T> {
        let _g = self.mu.lock();
        let mut out = Vec<T>::new();
        while let Some(v) = self.q.pop_front() {
            out.push(v);
        }
        self.cv_not_full.notify_all();
        out
    }

    /// Supprime tout sans renvoyer (plus rapide que drain()).
    pub fn clear(&self) {
        let _g = self.mu.lock();
        self.q.clear();
        self.cv_not_full.notify_all();
    }
}

/* —————————————— Mini smoke-test en doc —————————————— */
//! fn _smoke_channel() {
//!     let ch = Channel::<int>::bounded(2);
//!     assert(ch.try_send(1));
//!     assert(ch.try_send(2));
//!     assert(!ch.try_send(3)); // full
//!     let _t = std::thread::spawn({
//!         let ch2 = ch.clone(); // si ton runtime le permet, sinon capture &ch
//!         move || { std::time::sleep(50); let _ = ch2.try_recv(); }
//!     });
//!     assert(ch.send_timeout(3, 500)); // se débloque quand un consommateur libère une place
//!     assert(ch.recv().is_some());
//!     ch.close();
//!     // après close: try_send/send → false, mais on peut encore drainer jusqu’au vide
//!     assert(!ch.try_send(42));
//!     while ch.recv().is_some() {}
//!     assert(ch.recv().is_none());
//! }
