<!doctype html>
<html lang="fr"><head><meta charset="utf-8">
<title>Vitte Docs</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root{--bg:#0b0c10;--fg:#e5e7eb;--muted:#94a3b8;--card:#111827;--accent:#22d3ee}
*{box-sizing:border-box}body{margin:0;font-family:Inter,system-ui,sans-serif;background:var(--bg);color:var(--fg)}
header{padding:24px;border-bottom:1px solid #111} main{max-width:1080px;margin:0 auto;padding:20px}
a{color:var(--accent)} .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
.card{background:var(--card);padding:14px;border-radius:14px;border:1px solid #1f2937}
pre{background:#0e131b;padding:12px;border-radius:10px;overflow:auto}
code{font-family:ui-monospace,Consolas,monospace}
h1,h2,h3{margin:10px 0}
nav ul{display:flex;gap:10px;flex-wrap:wrap;padding:0;list-style:none;margin:0}
nav a{display:inline-block;padding:8px 10px;background:#0e131b;border-radius:10px;border:1px solid #1f2937}
.footer{padding:20px;color:var(--muted);text-align:center}
</style>
</head><body>
<header><h1>Vitte-lang — Documentation</h1>
<nav><ul id="nav"></ul></nav></header>
<main>
<section id="content"><div class="card"><p>Sélectionnez un document ci-dessus.</p></div></section>
</main>
<div class="footer">© 2025 Vitte — v1.3 docs</div>
<script>
const files = [{"slug": "deepsyntax", "title": "Syntaxe", "html": "<h1>Vitte \u2014 Syntax v1.3 (Ultimate)</h1>\n<br/>\n<h2>Design tenets</h2>\n<p>- **Lisible**, **pr\u00e9visible**, **optimisable**. Z\u00e9ro magie cach\u00e9e, co\u00fbts visibles.</p>\n<p>- **Kernel-friendly** (no_std), **server-grade** (async), **embedded** (allocateurs opt-in).</p>\n<br/>\n<h2>Lexique</h2>\n<p>- UTF-8 obligatoire. Commentaires `//` & `/* */` nestables.</p>\n<p>- Ident = `[A-Za-z_][A-Za-z0-9_]*`</p>\n<p>- Literaux: `123u32`, `0xFFu8`, `1.0f32`, `'x'`, `\"str\"`, `b\"raw\\xFF\"`</p>\n<br/>\n<h2>Mots-cl\u00e9s (r\u00e9serv\u00e9s)</h2>\n<p>`fn let mut const static struct union enum trait impl type use mod pub extern return if else match for while loop break continue defer async await spawn try yield unsafe where macro consteval constexpr sizeof alignof typeof as in from cfg test bench doc inline cold no_mangle export repr pack align`</p>\n<br/>\n<h2>Modules & imports</h2>\n<pre><code>\nmod net::tcp\nuse net::tcp::{Server, Client}\nuse std::fmt as f\n</code></pre>\n<br/>\n<h2>D\u00e9clarations</h2>\n<pre><code>\nconst PI: f64 = 3.1415926535\nstatic mut COUNTER: u64 = 0   # unsafe pour mut global\n\nstruct Point { x: f64, y: f64 }\nunion U { i: i32, f: f32 }\n\nenum Color { Red, Green, Blue, Rgb{r:u8,g:u8,b:u8} }\n\ntype Millis = u64\n</code></pre>\n<br/>\n<h2>Fonctions</h2>\n<pre><code>\nfn add(a: i32, b: i32) -&gt; i32 { a + b }\n\nfn greet(name: string = \"you\") { print(\"hello \", name) }\n\nfn map&lt;T, U&gt;(xs: &amp;[T], f: fn(T)-&gt;U) -&gt; Vec&lt;U&gt; where T: Copy {\n  let mut out = Vec&lt;U&gt;::with_capacity(xs.len())\n  for x in xs { out.push(f(*x)) }\n  return out\n}\n\n#[inline] fn hot(x: i32)-&gt;i32 { x*2 }\n#[cold]   fn slow()-&gt;never { panic(\"unreachable\") }\n</code></pre>\n<p>- `defer { ... }` s\u2019ex\u00e9cute \u00e0 la sortie du scope, **sans allouer**.</p>\n<br/>\n<h2>Contr\u00f4le & patterns</h2>\n<pre><code>\nif cond { ... } else if alt { ... } else { ... }\n\nfor i in 0..n { ... }        # exclusif\nfor b in bytes.iter() { ... }\n\nwhile ready() { ... }\nloop { if done { break } }\n\nmatch p {\n  Point { x, y } if x==y =&gt; diag(x),\n  Point { x, y }         =&gt; plot(x, y),\n  _ =&gt; {}\n}\n</code></pre>\n<br/>\n<h2>Ownership & r\u00e9f\u00e9rences</h2>\n<p>- Mouvement par d\u00e9faut (`let y = x` bouge si non-Copy).</p>\n<p>- `&T` lecture, `&mut T` unique \u00e9criture; lifetimes **inf\u00e9r\u00e9s**.</p>\n<p>- `Box<T>`, `Rc<T>`, `Arc<T>` dispo dans std (features).</p>\n<br/>\n<h2>Traits & g\u00e9n\u00e9riques</h2>\n<pre><code>\ntrait Display { fn fmt(&amp;self) -&gt; string }\nimpl Display for Point { fn fmt(&amp;self)-&gt;string { f::format(\"{},{}\", self.x,self.y) } }\n\nfn max&lt;T: Ord&gt;(a:T,b:T)-&gt;T { if a&gt;b {a} else {b} }\n\nfn buf&lt;const N:usize&gt;() -&gt; [u8; N] { [0; N] }\n</code></pre>\n<p>- **Specialization** sous feature contr\u00f4l\u00e9e: `#[feature(specialization)]`</p>\n<br/>\n<h2>Async, tasks & g\u00e9n\u00e9rateurs</h2>\n<pre><code>\nasync fn fetch(url: string) -&gt; Result&lt;string, NetErr&gt; { ... }\nlet body = await fetch(u)?\n\nfn numbers()-&gt;impl Iterator&lt;i32&gt; { yield 1; yield 2; }\n</code></pre>\n<br/>\n<h2>Erreurs (sucre & z\u00e9ro co\u00fbt)</h2>\n<pre><code>\nfn open(path: string) -&gt; Result&lt;File, IoErr&gt; {\n  let f = fs::open(path)?\n  ensure!(f.size() &gt; 0, IoErr::Empty)\n  return Ok(f)\n}\n</code></pre>\n<p>- `?` = test + early-return, sans unwind.  </p>\n<p>- `ensure!/bail!` = sucre \u2192 `return Err(...)`</p>\n<br/>\n<h2>FFI & repr</h2>\n<pre><code>\n#[repr(c)] struct Foo { x:i32, y:i32 }\nextern(c) fn c_add(a:i32,b:i32)-&gt;i32\n#[no_mangle] export fn vitte_symbol(){}\n</code></pre>\n<br/>\n<h2>Attributs cl\u00e9s</h2>\n<p>- `#[cfg(target=\"windows\")]`, `#[repr(c|packed)]`, `#[align(64)]`  </p>\n<p>- `#[test]`, `#[bench]`, `#[doc = \"...\"]`</p>\n<br/>\n<h2>Op\u00e9rateurs \u2014 pr\u00e9c\u00e9dence</h2>\n<p>1. `() [] . ::`  </p>\n<p>2. `! ~ - * & &mut (unaires)`  </p>\n<p>3. `* / %`  </p>\n<p>4. `+ -`  </p>\n<p>5. `<< >>`  </p>\n<p>6. `< <= > >=`  </p>\n<p>7. `== !=`  </p>\n<p>8. `& ^ |`  </p>\n<p>9. `&& ||`  </p>\n<p>10. `= += -= *= /=`</p>\n<br/>\n<h2>EBNF (r\u00e9sum\u00e9)</h2>\n<p>Voir `docs/EBNF_FULL.md`.</p>"}, {"slug": "ebnf_full", "title": "Grammaire EBNF", "html": "<h1>Vitte \u2014 EBNF compl\u00e8te (v1.3)</h1>\n<br/>\n<p>program     = { item } ;</p>\n<p>item        = fn_decl | struct_decl | union_decl | enum_decl | const_decl | static_decl | use_decl | mod_decl | type_alias | macro_decl ;</p>\n<br/>\n<p>use_decl    = \"use\" path ( \"as\" ident )? \";\" ;</p>\n<p>mod_decl    = \"mod\" path \";\" ;</p>\n<br/>\n<p>type_alias  = \"type\" ident \"=\" ty \";\" ;</p>\n<br/>\n<p>fn_decl     = attrs? \"fn\" ident type_params? \"(\" params? \")\" ret_ty? where_clause? block ;</p>\n<p>type_params = \"<\" type_param { \",\" type_param } \">\" ;</p>\n<p>type_param  = ident ( \":\" trait_bounds )? ;</p>\n<p>trait_bounds= path { \"+\" path } ;</p>\n<p>params      = param { \",\" param } ;</p>\n<p>param       = ident \":\" ty ( \"=\" expr )? ;</p>\n<br/>\n<p>ret_ty      = \"->\" ty ;</p>\n<p>where_clause= \"where\" where_item { \",\" where_item } ;</p>\n<p>where_item  = ident \":\" trait_bounds ;</p>\n<br/>\n<p>struct_decl = attrs? \"struct\" ident \"{\" fields? \"}\" ;</p>\n<p>fields      = field { \",\" field } ;</p>\n<p>field       = ident \":\" ty ;</p>\n<br/>\n<p>union_decl  = attrs? \"union\" ident \"{\" fields? \"}\" ;</p>\n<br/>\n<p>enum_decl   = attrs? \"enum\" ident \"{\" variants? \"}\" ;</p>\n<p>variants    = variant { \",\" variant } ;</p>\n<p>variant     = ident | ident \"{\" fields? \"}\" | ident \"(\" ty { \",\" ty } \")\" ;</p>\n<br/>\n<p>const_decl  = \"const\" ident \":\" ty \"=\" expr \";\" ;</p>\n<p>static_decl = \"static\" \"mut\"? ident \":\" ty \"=\" expr \";\" ;</p>\n<br/>\n<p>trait_decl  = \"trait\" ident type_params? \"{\" trait_items? \"}\" ;</p>\n<p>impl_decl   = \"impl\" type_params? for_ty \"{\" impl_items? \"}\" ;</p>\n<p>for_ty      = ty \"for\" path | path ;</p>\n<p>trait_items = { fn_sig \";\" | const_sig \";\" | type_sig \";\" } ;</p>\n<p>impl_items  = { fn_decl | const_decl | type_alias } ;</p>\n<br/>\n<p>block       = \"{\" { stmt } \"}\" ;</p>\n<p>stmt        = let_stmt | expr_stmt | return_stmt | if_stmt | while_stmt | for_stmt | loop_stmt | match_stmt | defer_stmt ;</p>\n<p>let_stmt    = \"let\" \"mut\"? pat \":\"? ty? \"=\" expr \";\" ;</p>\n<p>expr_stmt   = expr \";\" ;</p>\n<p>return_stmt = \"return\" expr? \";\" ;</p>\n<p>defer_stmt  = \"defer\" block ;</p>\n<br/>\n<p>if_stmt     = \"if\" expr block ( \"else\" ( block | if_stmt ) )? ;</p>\n<p>while_stmt  = \"while\" expr block ;</p>\n<p>for_stmt    = \"for\" pat \"in\" expr block ;</p>\n<p>loop_stmt   = \"loop\" block ;</p>\n<p>match_stmt  = \"match\" expr \"{\" match_arm { \",\" match_arm } \"}\" ;</p>\n<p>match_arm   = pat guard? \"=>\" ( expr | block ) ;</p>\n<p>guard       = \"if\" expr ;</p>\n<br/>\n<p>pat         = \"_\" | ident | lit | tuple_pat | struct_pat | enum_pat ;</p>\n<p>tuple_pat   = \"(\" pat { \",\" pat } \")\" ;</p>\n<p>struct_pat  = path \"{\" field_pat { \",\" field_pat } \"}\" ;</p>\n<p>field_pat   = ident \":\" pat | ident ;</p>\n<p>enum_pat    = path \"(\" pat { \",\" pat } \")\" ;</p>\n<br/>\n<p>expr        = assign ;</p>\n<p>assign      = logic_or { assign_op logic_or } ;</p>\n<p>assign_op   = \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" ;</p>\n<p>logic_or    = logic_and { \"||\" logic_and } ;</p>\n<p>logic_and   = bit_or    { \"&&\" bit_or } ;</p>\n<p>bit_or      = bit_xor   { \"|\"  bit_xor } ;</p>\n<p>bit_xor     = bit_and   { \"^\"  bit_and } ;</p>\n<p>bit_and     = equality  { \"&\"  equality } ;</p>\n<p>equality    = relation  { ( \"==\" | \"!=\" ) relation } ;</p>\n<p>relation    = shift     { ( \"<\" | \">\" | \"<=\" | \">=\" ) shift } ;</p>\n<p>shift       = add       { ( \"<<\" | \">>\" ) add } ;</p>\n<p>add         = mul       { ( \"+\" | \"-\" ) mul } ;</p>\n<p>mul         = unary     { ( \"*\" | \"/\" | \"%\" ) unary } ;</p>\n<p>unary       = ( \"!\" | \"~\" | \"-\" | \"&\" | \"*\") unary | call ;</p>\n<p>call        = primary { \"(\" args? \")\" | \"[\" expr \"]\" | \".\" ident } ;</p>\n<p>args        = expr { \",\" expr } ;</p>\n<p>primary     = ident | lit | \"(\" expr \")\" | block ;</p>\n<br/>\n<p>ty          = path | \"&\" \"mut\"? ty | \"*\" ty | \"[\" ty \";\" expr \"]\" | \"(\" ty { \",\" ty } \")\" | \"fn\" \"(\" ty_list? \")\" \"->\" ty ;</p>\n<p>ty_list     = ty { \",\" ty } ;</p>\n<br/>\n<p>path        = ident { \"::\" ident } ;</p>\n<p>ident       = /* see lex */ ;</p>\n<p>lit         = int_lit | float_lit | char_lit | string_lit | bool_lit ;</p>"}, {"slug": "errors", "title": "Mod\u00e8le d'erreurs", "html": "<h1>Errors v1.3 \u2014 Zero-cost & Practical</h1>\n<br/>\n<p>- `Result<T,E>` partout (I/O, FFI, parsing).</p>\n<p>- `SmallErr` (<= 32 B) : code, tag, payload court. Aligne 2 words \u2192 cheap.</p>\n<p>- `RichErr` dev-only : message heap + backtrace (strip en release).</p>\n<p>- `?` se compile en test + jump (SSA), pas d\u2019unwind.</p>\n<p>- `ensure!(cond, E)`, `bail!(E)` = sucre \u2192 branches d\u00e9terministes.</p>\n<p>- `panic!` : abort en release ; debug `-Zeh_unwind` autorise backtrace.</p>\n<p>- Tables d\u2019erreurs (codes stables) pour ABI & logs parsables.</p>"}, {"slug": "memorymodel", "title": "Mod\u00e8le m\u00e9moire", "html": "<h1>Mod\u00e8le m\u00e9moire</h1>\n<p>\u00c0 compl\u00e9ter.</p>"}, {"slug": "abi_vitx", "title": "ABI r\u00e9sum\u00e9", "html": "<h1>.vitx format</h1>\n<p>- ELF/Mach-O/PE + section .vmeta (uuid,target,version), DWARF/PDB, strip/ICF.</p>"}, {"slug": "vitx_spec", "title": "Sp\u00e9cification VITX", "html": "<br/>\n<h1>VITX \u2014 Sp\u00e9cification binaire v1.0</h1>\n<br/>\n<h2>0. Objectif</h2>\n<p>Format d\u2019ex\u00e9cutable **natif** multi-OS (PE/COFF, Mach-O, ELF) avec **m\u00e9tadonn\u00e9es Vitte**</p>\n<p>standardis\u00e9es. `.vitx` est un **contenant** : le binaire est au format du syst\u00e8me cible,</p>\n<p>et une section `.vmeta` ajoute des infos cross-toolchain.</p>\n<br/>\n<h2>1. En-t\u00eate `.vmeta`</h2>\n<p>- Magic: `56 49 54 58` (\"VITX\") \u2014 4 octets</p>\n<p>- Version: `u16` (ex: 0x0100)</p>\n<p>- Flags: `u16` (bitfield: 0=debug,1=lto,2=pgo,3=asan,4=tsan,5=ubsan,6=sizeopt)</p>\n<p>- UUID build: 16 octets</p>\n<p>- Target triple: UTF-8 NUL-terminated (ex: `x86_64-unknown-linux-musl`)</p>\n<p>- Toolchain: `vittec <semver>` (UTF-8 NUL-term)</p>\n<p>- Timestamp: `u64` epoch ms</p>\n<p>- Offsets: table des sections Vitte (voir \u00a72)</p>\n<br/>\n<h2>2. Table Vitte (TLV)</h2>\n<p>Entr\u00e9es cl\u00e9/valeur:</p>\n<p>- `VT_SECTIONS` \u2192 liste des sections additionnelles</p>\n<p>- `VT_SYMS`     \u2192 table des symboles Vitte (nom, addr, size, linkage)</p>\n<p>- `VT_RELOS`    \u2192 relocations additionnelles si pertinentes</p>\n<p>- `VT_PGO`      \u2192 profil PGO embarqu\u00e9 (optionnel)</p>\n<p>- `VT_NOTE`     \u2192 texte libre (commit SHA, builder, etc.)</p>\n<br/>\n<h2>3. Symboles</h2>\n<p>Chaque symbole:</p>\n<p>- name: strz</p>\n<p>- addr: u64 RVA</p>\n<p>- size: u32</p>\n<p>- kind: u8 (func=1, obj=2, tls=3, sect=4)</p>\n<p>- vis:  u8 (local=0, extern=1, weak=2)</p>\n<p>- flags: u16 (inline=1, cold=2, hot=4)</p>\n<br/>\n<h2>4. S\u00e9curit\u00e9</h2>\n<p>- Signature binaire support\u00e9e via `vitsign` (annexe `VT_SIG`: algo, cl\u00e9 id, signature).</p>\n<p>- Recommand\u00e9: SHA-256 + Ed25519.</p>\n<br/>\n<h2>5. D\u00e9bogage</h2>\n<p>- DWARF/PDB suivant la plateforme, r\u00e9f\u00e9renc\u00e9 dans `.vmeta`. `vitobj` et `vitdis`</p>\n<p>peuvent lister symboles et g\u00e9n\u00e9rer des rapports (hot/cold).</p>\n<br/>\n<h2>6. Strip & ICF</h2>\n<p>- `vitstrip` op\u00e8re au niveau symbole (supprime noms et regroupe code identique).</p>\n<br/>\n<h2>7. Compatibilit\u00e9</h2>\n<p>- `.vitx` reste un ex\u00e9cutable standard. Les OS le chargent normalement.</p>\n<p>- La pr\u00e9sence de `.vmeta` n\u2019impacte pas l\u2019OS; seuls les outils Vitte l\u2019exploitent.</p>\n<br/>\n<h2>8. Exemple minimal `.vmeta`</h2>\n<pre><code>\nMagic  : 56 49 54 58\nVersion: 0x0100\nFlags  : 0x0023   # LTO + PGO + sizeopt\nUUID   : 16 bytes\nTriple : \"x86_64-unknown-linux-musl\u0000\"\nTool   : \"vittec 0.1.0\u0000\"\nTime   : 1720000000000\nTLV    : [...]\n</code></pre>"}, {"slug": "platforms", "title": "Plateformes", "html": "<h1>Platforms</h1>\n<p>Windows (MSVC/GNU), macOS (x64/arm64), Linux (glibc/musl), *BSD, WASI, AVR/ARM.</p>"}, {"slug": "commands", "title": "Commandes", "html": "<h1>Commands</h1>\n<p>vitte, vitc, vitcc, vitx, vitxx + suite vit* (vitr, vittest, vitcov, vitpack, ...)</p>"}];
const nav = document.getElementById('nav'), cont = document.getElementById('content');
files.forEach(f=>{ const a=document.createElement('a'); a.href='#'+f.slug; a.textContent=f.title; const li=document.createElement('li'); li.appendChild(a); nav.appendChild(li); });
function show(slug){
  const f = files.find(x=>x.slug===slug) || files[0];
  cont.innerHTML = `<div class="card"><h2>${f.title}</h2>`+f.html+`</div>`;
}
window.addEventListener('hashchange', ()=>show(location.hash.slice(1)));
show(location.hash.slice(1)||files[0].slug);
</script>
</body></html>
