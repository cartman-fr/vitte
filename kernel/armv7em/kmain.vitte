fn kmain(){ /* init clocks/gpio */ } 
//! kernel/armv7em/kmain.vitte
//! Kernel bootstrap pour ARMv7-EM (Cortex-M4/M7).
//!
//! Attentes linker script (exemples):
//!   PROVIDE(_estack = ORIGIN(RAM) + LENGTH(RAM));
//!   _sidata, _sdata, _edata, _sbss, _ebss, _heap_start, _heap_end
//! Mémoire:
//!   FLASH @ 0x0800_0000 (ex STM32) / SRAM @ 0x2000_0000 — à adapter.

#![version("0.1.0")]
#![no_std]
#![no_main]
#![strict]
#![warn("unsafe_ops","unused","dead_code")]

// ———————————————————————————————————————————————————————————————
// Constantes SoC (SCB, SysTick, NVIC, ITM)
// ———————————————————————————————————————————————————————————————
mod mmio {
    pub const SCS_BASE:      u32 = 0xE000E000;
    pub const STK_BASE:      u32 = 0xE000E010; // SysTick
    pub const NVIC_ISER0:    u32 = 0xE000E100; // 0..n enable
    pub const NVIC_ICER0:    u32 = 0xE000E180; // 0..n disable
    pub const NVIC_IPR0:     u32 = 0xE000E400; // priority
    pub const SCB_CPACR:     u32 = 0xE000ED88;
    pub const SCB_VTOR:      u32 = 0xE000ED08;
    pub const SCB_AIRCR:     u32 = 0xE000ED0C;
    pub const SCB_CCR:       u32 = 0xE000ED14;
    pub const SCB_SHCSR:     u32 = 0xE000ED24;

    pub const ITM_BASE:      u32 = 0xE0000000;
    pub const ITM_STIM0:     u32 = ITM_BASE + 0x000; // stimulus port 0
    pub const ITM_TCR:       u32 = ITM_BASE + 0xE80;
    pub const ITM_TER:       u32 = ITM_BASE + 0xE00;

    // SysTick registers
    pub const STK_CSR:       u32 = STK_BASE + 0x0;
    pub const STK_RVR:       u32 = STK_BASE + 0x4;
    pub const STK_CVR:       u32 = STK_BASE + 0x8;
    pub const STK_CALIB:     u32 = STK_BASE + 0xC;

    // Bits utiles
    pub const STK_CSR_ENABLE:   u32 = 1 << 0;
    pub const STK_CSR_TICKINT:  u32 = 1 << 1;
    pub const STK_CSR_CLKSOURCE:u32 = 1 << 2; // 0=ext, 1=CPU
    pub const AIRCR_VECTKEY:    u32 = 0x5FA << 16;

    // SCB->CCR bits (M7 caches si présents)
    pub const CCR_IC: u32 = 1 << 17; // I-Cache enable
    pub const CCR_DC: u32 = 1 << 16; // D-Cache enable
}

// ———————————————————————————————————————————————————————————————
mod memb {
    // Liaison avec les symboles du linker
    extern(c) {
        static _estack: u32;
        static _sidata: u32;
        static _sdata:  u32;
        static _edata:  u32;
        static _sbss:   u32;
        static _ebss:   u32;
        static _heap_start: u32;
        static _heap_end:   u32;
    }

    // Copies/zero bas niveau
    pub unsafe fn copy_data() {
        let mut src = &_sidata as *const u32;
        let mut dst = &_sdata  as *const u32 as *mut u32;
        let end =   &_edata  as *const u32 as *mut u32;
        while dst < end {
            *dst = *src;
            dst = dst.add(1);
            src = src.add(1);
        }
    }

    pub unsafe fn zero_bss() {
        let mut dst = &_sbss as *const u32 as *mut u32;
        let end      = &_ebss as *const u32 as *mut u32;
        while dst < end {
            *dst = 0;
            dst = dst.add(1);
        }
    }
}

// ———————————————————————————————————————————————————————————————
// Accès MMIO 32-bit
// ———————————————————————————————————————————————————————————————
#[inline] fn mmio32(addr: u32) -> *volatile u32 { addr as *volatile u32 }
#[inline] fn read32(addr: u32) -> u32 { unsafe { *mmio32(addr) } }
#[inline] fn write32(addr: u32, val: u32) { unsafe { *mmio32(addr) = val; } }
#[inline] fn set32(addr: u32, mask: u32) { write32(addr, read32(addr) | mask); }
#[inline] fn clr32(addr: u32, mask: u32) { write32(addr, read32(addr) & !mask); }

// Barrières
#[inline] fn dmb() { unsafe { asm!("dmb"); } }
#[inline] fn dsb() { unsafe { asm!("dsb"); } }
#[inline] fn isb() { unsafe { asm!("isb"); } }
#[inline] fn wfi() { unsafe { asm!("wfi"); } }

// ———————————————————————————————————————————————————————————————
// Mini logger ITM (SWO). Nécessite un débugger avec ITM actif.
// Silencieux si ITM désactivé.
// ———————————————————————————————————————————————————————————————
mod log {
    use super::mmio::*;
    use super::mmio as regs;

    pub fn enabled() -> bool {
        let tcr = read32(regs::ITM_TCR);
        let ter = read32(regs::ITM_TER);
        (tcr & 1) != 0 && (ter & 1) != 0
    }

    pub fn write_u8(b: u8) {
        if !enabled() { return; }
        unsafe {
            while (read32(regs::ITM_STIM0) & 1) == 0 { /* wait */ }
            write32(regs::ITM_STIM0, b as u32);
        }
    }

    pub fn print(s: str) {
        for ch in s.bytes() { write_u8(ch); }
    }

    pub fn println(s: str) {
        print(s);
        write_u8(b'\n');
    }
}

// ———————————————————————————————————————————————————————————————
// FPU & caches (M7) — activables selon cible
// ———————————————————————————————————————————————————————————————
mod cpu {
    use super::mmio::*;

    pub fn enable_fpu() {
        // CPACR: CP10/CP11 full access
        let mut v = read32(SCB_CPACR);
        v |= (0b11 << 20) | (0b11 << 22);
        write32(SCB_CPACR, v);
        dsb(); isb();
    }

    // Pour Cortex-M7 uniquement si caches présents
    pub fn enable_caches_m7() {
        // Activer I/D cache via SCB->CCR (suppose invalidations faites par ailleurs)
        set32(SCB_CCR, CCR_IC | CCR_DC);
        dsb(); isb();
    }

    pub fn set_vector_table(addr: u32) {
        write32(SCB_VTOR, addr);
        dsb(); isb();
    }

    pub fn set_priority_grouping(prigroup: u32) {
        // AIRCR VECTKEY | PRIGROUP[10:8]
        let cur = read32(SCB_AIRCR);
        let v = (cur & !(0x7 << 8 | 0xFFFF0000)) | (AIRCR_VECTKEY) | ((prigroup & 0x7) << 8);
        write32(SCB_AIRCR, v);
        dsb(); isb();
    }
}

// ———————————————————————————————————————————————————————————————
// SysTick 1 ms (par défaut). SYSCLK_HZ à ajuster selon ton clock tree.
// ———————————————————————————————————————————————————————————————
mod systick {
    use super::mmio::*;

    pub static mut TICKS: u64 = 0;

    pub const SYSCLK_HZ: u32 = {
        // Ajuste: 168_000_000 (F4), 216_000_000 (F7), etc.
        let env = std::env::get("SYSCLK_HZ").unwrap_or("168000000");
        env.parse::<u32>().unwrap_or(168_000_000)
    };

    pub fn init_1ms() {
        let reload = (SYSCLK_HZ / 1000) - 1;
        write32(STK_RVR, reload);
        write32(STK_CVR, 0);
        write32(
            STK_CSR,
            STK_CSR_ENABLE | STK_CSR_TICKINT | STK_CSR_CLKSOURCE
        );
    }

    // ISR appelée par le vecteur SysTick
    pub fn on_tick() {
        unsafe { TICKS += 1; }
    }

    pub fn delay_ms(ms: u32) {
        let start = unsafe { TICKS };
        while unsafe { TICKS } - start < ms as u64 {
            wfi();
        }
    }
}

// ———————————————————————————————————————————————————————————————
// NVIC helpers
// ———————————————————————————————————————————————————————————————
mod nvic {
    use super::mmio::*;

    pub fn enable(irqn: u32) {
        let reg = NVIC_ISER0 + ((irqn / 32) * 4);
        let bit = irqn % 32;
        set32(reg, 1u32 << bit);
    }

    pub fn disable(irqn: u32) {
        let reg = NVIC_ICER0 + ((irqn / 32) * 4);
        let bit = irqn % 32;
        set32(reg, 1u32 << bit);
    }

    pub fn set_priority(irqn: u32, prio: u8) {
        let addr = NVIC_IPR0 + irqn;
        write32(addr, prio as u32);
    }
}

// ———————————————————————————————————————————————————————————————
// Protos: kernel main + weak hooks utilisateur
// ———————————————————————————————————————————————————————————————
#[linkage("weak")] extern(c) fn board_clock_init() -> int { 0 }          // à surcharger
#[linkage("weak")] extern(c) fn board_early_init() -> int { 0 }          // à surcharger
#[linkage("weak")] extern(c) fn board_late_init() -> int { 0 }           // à surcharger
#[linkage("weak")] extern(c) fn kmain() -> int {
    log::println("kmain(): hello from ARMv7-EM ✨");
    // Démo: clignote via SysTick
    loop { wfi(); }
}

// ———————————————————————————————————————————————————————————————
// Handlers défauts (faibles) + faults détaillés
// ———————————————————————————————————————————————————————————————
type Isr = fn();
type IsrNoret = fn() -> !;

#[linkage("weak")] fn Default_Handler() -> ! {
    log::println("[fault] Default_Handler → halt");
    loop { /* spin */ }
}

#[linkage("weak")] fn NMI_Handler()      -> ! { Default_Handler() }
#[linkage("weak")] fn HardFault_Handler()-> ! { fault_report("HardFault") }
#[linkage("weak")] fn MemManage_Handler()-> ! { fault_report("MemManage") }
#[linkage("weak")] fn BusFault_Handler() -> ! { fault_report("BusFault") }
#[linkage("weak")] fn UsageFault_Handler()->! { fault_report("UsageFault") }
#[linkage("weak")] fn SVC_Handler()      { /* syscalls */ }
#[linkage("weak")] fn DebugMon_Handler() { }
#[linkage("weak")] fn PendSV_Handler()   { }
#[linkage("weak")] fn SysTick_Handler()  { systick::on_tick(); }

// IRQs périphériques (placeholder 64 entrées)
#[linkage("weak")] fn IRQ0() { Default_Handler() }
#[linkage("weak")] fn IRQ1() { Default_Handler() }
#[linkage("weak")] fn IRQ2() { Default_Handler() }
#[linkage("weak")] fn IRQ3() { Default_Handler() }
#[linkage("weak")] fn IRQ4() { Default_Handler() }
#[linkage("weak")] fn IRQ5() { Default_Handler() }
#[linkage("weak")] fn IRQ6() { Default_Handler() }
#[linkage("weak")] fn IRQ7() { Default_Handler() }
#[linkage("weak")] fn IRQ8() { Default_Handler() }
#[linkage("weak")] fn IRQ9() { Default_Handler() }
#[linkage("weak")] fn IRQ10() { Default_Handler() }
#[linkage("weak")] fn IRQ11() { Default_Handler() }
#[linkage("weak")] fn IRQ12() { Default_Handler() }
#[linkage("weak")] fn IRQ13() { Default_Handler() }
#[linkage("weak")] fn IRQ14() { Default_Handler() }
#[linkage("weak")] fn IRQ15() { Default_Handler() }
#[linkage("weak")] fn IRQ16() { Default_Handler() }
#[linkage("weak")] fn IRQ17() { Default_Handler() }
#[linkage("weak")] fn IRQ18() { Default_Handler() }
#[linkage("weak")] fn IRQ19() { Default_Handler() }
#[linkage("weak")] fn IRQ20() { Default_Handler() }
#[linkage("weak")] fn IRQ21() { Default_Handler() }
#[linkage("weak")] fn IRQ22() { Default_Handler() }
#[linkage("weak")] fn IRQ23() { Default_Handler() }
#[linkage("weak")] fn IRQ24() { Default_Handler() }
#[linkage("weak")] fn IRQ25() { Default_Handler() }
#[linkage("weak")] fn IRQ26() { Default_Handler() }
#[linkage("weak")] fn IRQ27() { Default_Handler() }
#[linkage("weak")] fn IRQ28() { Default_Handler() }
#[linkage("weak")] fn IRQ29() { Default_Handler() }
#[linkage("weak")] fn IRQ30() { Default_Handler() }
#[linkage("weak")] fn IRQ31() { Default_Handler() }
#[linkage("weak")] fn IRQ32() { Default_Handler() }
#[linkage("weak")] fn IRQ33() { Default_Handler() }
#[linkage("weak")] fn IRQ34() { Default_Handler() }
#[linkage("weak")] fn IRQ35() { Default_Handler() }
#[linkage("weak")] fn IRQ36() { Default_Handler() }
#[linkage("weak")] fn IRQ37() { Default_Handler() }
#[linkage("weak")] fn IRQ38() { Default_Handler() }
#[linkage("weak")] fn IRQ39() { Default_Handler() }
#[linkage("weak")] fn IRQ40() { Default_Handler() }
#[linkage("weak")] fn IRQ41() { Default_Handler() }
#[linkage("weak")] fn IRQ42() { Default_Handler() }
#[linkage("weak")] fn IRQ43() { Default_Handler() }
#[linkage("weak")] fn IRQ44() { Default_Handler() }
#[linkage("weak")] fn IRQ45() { Default_Handler() }
#[linkage("weak")] fn IRQ46() { Default_Handler() }
#[linkage("weak")] fn IRQ47() { Default_Handler() }
#[linkage("weak")] fn IRQ48() { Default_Handler() }
#[linkage("weak")] fn IRQ49() { Default_Handler() }
#[linkage("weak")] fn IRQ50() { Default_Handler() }
#[linkage("weak")] fn IRQ51() { Default_Handler() }
#[linkage("weak")] fn IRQ52() { Default_Handler() }
#[linkage("weak")] fn IRQ53() { Default_Handler() }
#[linkage("weak")] fn IRQ54() { Default_Handler() }
#[linkage("weak")] fn IRQ55() { Default_Handler() }
#[linkage("weak")] fn IRQ56() { Default_Handler() }
#[linkage("weak")] fn IRQ57() { Default_Handler() }
#[linkage("weak")] fn IRQ58() { Default_Handler() }
#[linkage("weak")] fn IRQ59() { Default_Handler() }
#[linkage("weak")] fn IRQ60() { Default_Handler() }
#[linkage("weak")] fn IRQ61() { Default_Handler() }
#[linkage("weak")] fn IRQ62() { Default_Handler() }
#[linkage("weak")] fn IRQ63() { Default_Handler() }

// ———————————————————————————————————————————————————————————————
// Reset handler: runtime init → hooks carte → FPU/caches → SysTick → kmain()
// ———————————————————————————————————————————————————————————————
#[naked]
fn Reset_Handler() -> ! {
    // Pas de prologue/epilogue — pur bootstrap
    unsafe {
        // 1) .data/.bss
        memb::copy_data();
        memb::zero_bss();

        // 2) Vector table (option: relocaliser si non à 0x0)
        //    Si la table est placée en FLASH au bon offset par le linker, rien à faire.
        // cpu::set_vector_table(&_vector_table as *const u32 as u32); // si besoin

        // 3) FPU (si présent)
        cpu::enable_fpu();

        // 4) Caches M7 (optionnels)
        #[cfg(feature="cortex_m7")]
        cpu::enable_caches_m7();

        // 5) Hooks board
        let _ = board_early_init();
        let _ = board_clock_init();

        // 6) SysTick 1ms
        systick::init_1ms();

        // 7) Entrée kernel
        let _code = kmain();

        // 8) Si retour, idle
        loop { wfi(); }
    }
}

// ———————————————————————————————————————————————————————————————
// Table des vecteurs (section spécifique, alignée 256)
// ———————————————————————————————————————————————————————————————
#[link_section(".vectors")]
#[align(256)]
static _vector_table: [*const void; 16 + 64] = [
    // Core
    &_estack as *const u32 as *const void,     // 0: SP initial
    Reset_Handler       as *const void,        // 1: Reset
    NMI_Handler         as *const void,        // 2
    HardFault_Handler   as *const void,        // 3
    MemManage_Handler   as *const void,        // 4
    BusFault_Handler    as *const void,        // 5
    UsageFault_Handler  as *const void,        // 6
    0 as *const void,                           // 7: reserved
    0 as *const void,                           // 8
    0 as *const void,                           // 9
    0 as *const void,                           // 10
    SVC_Handler         as *const void,        // 11
    DebugMon_Handler    as *const void,        // 12
    0 as *const void,                           // 13
    PendSV_Handler      as *const void,        // 14
    SysTick_Handler     as *const void,        // 15

    // IRQs 0..63
    IRQ0  as *const void, IRQ1  as *const void, IRQ2  as *const void, IRQ3  as *const void,
    IRQ4  as *const void, IRQ5  as *const void, IRQ6  as *const void, IRQ7  as *const void,
    IRQ8  as *const void, IRQ9  as *const void, IRQ10 as *const void, IRQ11 as *const void,
    IRQ12 as *const void, IRQ13 as *const void, IRQ14 as *const void, IRQ15 as *const void,
    IRQ16 as *const void, IRQ17 as *const void, IRQ18 as *const void, IRQ19 as *const void,
    IRQ20 as *const void, IRQ21 as *const void, IRQ22 as *const void, IRQ23 as *const void,
    IRQ24 as *const void, IRQ25 as *const void, IRQ26 as *const void, IRQ27 as *const void,
    IRQ28 as *const void, IRQ29 as *const void, IRQ30 as *const void, IRQ31 as *const void,
    IRQ32 as *const void, IRQ33 as *const void, IRQ34 as *const void, IRQ35 as *const void,
    IRQ36 as *const void, IRQ37 as *const void, IRQ38 as *const void, IRQ39 as *const void,
    IRQ40 as *const void, IRQ41 as *const void, IRQ42 as *const void, IRQ43 as *const void,
    IRQ44 as *const void, IRQ45 as *const void, IRQ46 as *const void, IRQ47 as *const void,
    IRQ48 as *const void, IRQ49 as *const void, IRQ50 as *const void, IRQ51 as *const void,
    IRQ52 as *const void, IRQ53 as *const void, IRQ54 as *const void, IRQ55 as *const void,
    IRQ56 as *const void, IRQ57 as *const void, IRQ58 as *const void, IRQ59 as *const void,
    IRQ60 as *const void, IRQ61 as *const void, IRQ62 as *const void, IRQ63 as *const void,
];

// ———————————————————————————————————————————————————————————————
// Fault reporter minimal (trace ITM + boucle)
// ———————————————————————————————————————————————————————————————
fn fault_report(name: str) -> ! {
    log::println(name);
    loop { /* halt */ }
}

// ———————————————————————————————————————————————————————————————
// Panic handler
// ———————————————————————————————————————————————————————————————
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    log::println("[panic] kernel");
    // Option: blink SOS sur une LED si board_early_init configure un GPIO.
    loop { /* halt */ }
}
