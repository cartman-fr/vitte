//! x86_64/kmain.vitte
//! Kernel x86_64 minimal : GDT/IDT, PIC, PIT, clavier, VGA texte, panic safe.
//! Hypothèses : long mode actif, paging OK, interrupts désactivées à l’entrée.
//! Boot via start64.S / bootloader (Limine/GRUB2 Multiboot2).

#![version("0.1.0")]
#![no_std]
#![no_main]
#![strict]
#![warn("unsafe_ops","unused","dead_code")]

////////////////////////////////////////////////////////////////
// Port I/O — in/out 8/16/32
////////////////////////////////////////////////////////////////
mod io {
    #[inline] pub fn outb(port: u16, val: u8)   { unsafe { asm!("out dx, al", in("dx") port, in("al") val); } }
    #[inline] pub fn outw(port: u16, val: u16)  { unsafe { asm!("out dx, ax", in("dx") port, in("ax") val); } }
    #[inline] pub fn outl(port: u16, val: u32)  { unsafe { asm!("out dx, eax", in("dx") port, in("eax") val); } }
    #[inline] pub fn inb(port: u16)  -> u8   { let mut x:u8=0;  unsafe { asm!("in al, dx", out("al") x, in("dx") port); }  return x; }
    #[inline] pub fn inw(port: u16)  -> u16  { let mut x:u16=0; unsafe { asm!("in ax, dx", out("ax") x, in("dx") port); } return x; }
    #[inline] pub fn inl(port: u16)  -> u32  { let mut x:u32=0; unsafe { asm!("in eax, dx", out("eax") x, in("dx") port); } return x; }
    #[inline] pub fn io_wait() { // petit délai via port 0x80
        unsafe { asm!("out 0x80, al", in("al") 0u8); }
    }
}

////////////////////////////////////////////////////////////////
// VGA texte — 80x25
////////////////////////////////////////////////////////////////
mod vga {
    const VGA_PTR: *mut u16 = 0xB8000 as *mut u16;
    const COLS: usize = 80;
    const ROWS: usize = 25;

    static mut CUR_X: usize = 0;
    static mut CUR_Y: usize = 0;
    static mut COLOR: u8 = 0x0F; // blanc sur noir

    pub fn clear() {
        unsafe {
            let blank: u16 = ((COLOR as u16) << 8) | (' ' as u16);
            let mut i = 0;
            while i < COLS*ROWS {
                *VGA_PTR.add(i) = blank;
                i += 1;
            }
            CUR_X = 0; CUR_Y = 0;
            update_hw_cursor();
        }
    }

    fn newline() {
        unsafe {
            CUR_X = 0;
            if CUR_Y + 1 >= ROWS { scroll(); } else { CUR_Y += 1; }
            update_hw_cursor();
        }
    }

    fn scroll() {
        unsafe {
            let mut r = 1usize;
            while r < ROWS {
                let mut c = 0usize;
                while c < COLS {
                    *VGA_PTR.add((r-1)*COLS + c) = *VGA_PTR.add(r*COLS + c);
                    c += 1;
                }
                r += 1;
            }
            let blank: u16 = ((COLOR as u16) << 8) | (' ' as u16);
            let mut c = 0usize;
            while c < COLS { *VGA_PTR.add((ROWS-1)*COLS + c) = blank; c+=1; }
            CUR_Y = ROWS - 1;
        }
    }

    pub fn putc(ch: u8) {
        unsafe {
            match ch {
                b'\n' => { newline(); return; }
                b'\r' => { CUR_X = 0; update_hw_cursor(); return; }
                _ => {}
            }
            let off = CUR_Y*COLS + CUR_X;
            *VGA_PTR.add(off) = ((COLOR as u16) << 8) | (ch as u16);
            CUR_X += 1;
            if CUR_X >= COLS { newline(); }
            update_hw_cursor();
        }
    }

    pub fn write(s: str) { for b in s.bytes() { putc(b); } }
    pub fn set_color(fg: u8, bg: u8) { unsafe { COLOR = ((bg & 0x0F) << 4) | (fg & 0x0F); } }

    fn update_hw_cursor() {
        // optionnel : programmer le curseur VGA (ports 0x3D4/0x3D5)
        use super::io::*;
        unsafe {
            let pos: u16 = (CUR_Y*COLS + CUR_X) as u16;
            outb(0x3D4, 0x0F); outb(0x3D5, (pos & 0xFF) as u8);
            outb(0x3D4, 0x0E); outb(0x3D5, ((pos >> 8) & 0xFF) as u8);
        }
    }
}

////////////////////////////////////////////////////////////////
// GDT — flat 64-bit (code/data), TSS optionnelle (non utilisée ici)
////////////////////////////////////////////////////////////////
mod gdt {
    #[repr(C, packed)]
    struct Descriptor(u64);
    #[repr(C, packed)]
    struct GDTR { limit: u16, base: u64 }

    static mut GDT: [Descriptor; 3] = [
        Descriptor(0),                           // null
        Descriptor(0x00AF9A000000FFFF),          // code 64
        Descriptor(0x00AF92000000FFFF),          // data 64
    ];

    pub fn load() {
        unsafe {
            let gdtr = GDTR {
                limit: (core::mem::size_of_val(&GDT)-1) as u16,
                base: &GDT as *const _ as u64
            };
            asm!("lgdt [{}]", in(reg) &gdtr);
            // CS via far jump, DS/ES/SS rechargés
            asm!(
                "pushq $0x08",     // code selector
                "leaq 1f(%rip), %rax",
                "pushq %rax",
                "lretq",
                "1:",
                "mov $0x10, %rax",
                "mov %rax, %ds; mov %rax, %es; mov %rax, %ss",
                out("rax") _
            );
        }
    }
}

////////////////////////////////////////////////////////////////
// IDT + ISRs (exceptions, IRQ), stub par défaut
////////////////////////////////////////////////////////////////
mod idt {
    #[repr(C, packed)] struct IDTR { limit: u16, base: u64 }
    #[repr(C, packed)] struct Gate {
        off_lo: u16, sel: u16, ist: u8, flags: u8, off_mid: u16, off_hi: u32, zero: u32
    }

    static mut IDT: [Gate; 256] = [Gate{off_lo:0,sel:0,ist:0,flags:0,off_mid:0,off_hi:0,zero:0};256];

    const KCODE: u16 = 0x08;
    const FLAG_INT: u8 = 0b1000_1110; // P=1 DPL=00 Type=0xE (interrupt gate)

    fn set_gate(vec: u8, handler: extern "C" fn(), ist: u8) {
        unsafe {
            let addr = handler as u64;
            IDT[vec as usize] = Gate {
                off_lo:  (addr & 0xFFFF) as u16,
                sel: KCODE,
                ist,
                flags: FLAG_INT,
                off_mid: ((addr >> 16) & 0xFFFF) as u16,
                off_hi:  ((addr >> 32) & 0xFFFF_FFFF) as u32,
                zero: 0
            };
        }
    }

    extern "C" {
        fn isr_default();
        fn isr_timer();
        fn isr_keyboard();
        fn isr_gp();
        fn isr_pf();
        fn isr_de();
    }

    pub fn load() {
        unsafe {
            // Exceptions essentielles
            set_gate(0x00, isr_de, 0);  // #DE
            set_gate(0x0D, isr_gp, 0);  // #GP
            set_gate(0x0E, isr_pf, 0);  // #PF

            // IRQ remappées PIC : timer=32, keyboard=33
            set_gate(32, isr_timer, 0);
            set_gate(33, isr_keyboard, 0);

            // Défaut pour le reste
            let mut v = 0usize;
            while v < 256 {
                // n’écrase pas ceux déjà posés
                if (v != 0 && v != 13 && v != 14 && v != 32 && v != 33) {
                    set_gate(v as u8, isr_default, 0);
                }
                v += 1;
            }

            let idtr = IDTR{ limit:(core::mem::size_of_val(&IDT)-1) as u16, base: &IDT as *const _ as u64 };
            asm!("lidt [{}]", in(reg) &idtr);
            asm!("sti"); // OK on ouvre les IT
        }
    }
}

////////////////////////////////////////////////////////////////
// PIC 8259A — remap vers 0x20..0x2F, masques
////////////////////////////////////////////////////////////////
mod pic {
    use super::io::*;
    const PIC1: u16=0x20; const PIC2: u16=0xA0;
    const PIC1_DATA: u16=PIC1+1; const PIC2_DATA: u16=PIC2+1;
    const ICW1_INIT:u8=0x10; const ICW1_ICW4:u8=0x01;
    const ICW4_8086:u8=0x01;
    pub fn remap() {
        let a1 = inb(PIC1_DATA);
        let a2 = inb(PIC2_DATA);
        outb(PIC1, ICW1_INIT|ICW1_ICW4); io_wait();
        outb(PIC2, ICW1_INIT|ICW1_ICW4); io_wait();
        outb(PIC1_DATA, 0x20); io_wait(); // master offset 32
        outb(PIC2_DATA, 0x28); io_wait(); // slave offset 40
        outb(PIC1_DATA, 0x04); io_wait(); // tell master about slave at IRQ2
        outb(PIC2_DATA, 0x02); io_wait();
        outb(PIC1_DATA, ICW4_8086); io_wait();
        outb(PIC2_DATA, ICW4_8086); io_wait();
        outb(PIC1_DATA, a1); // restore mask
        outb(PIC2_DATA, a2);
    }
    pub fn mask_all() {
        outb(PIC1_DATA, 0xFF); outb(PIC2_DATA, 0xFF);
    }
    pub fn unmask_timer_keyboard() {
        // autorise IRQ0 (timer) et IRQ1 (kbd) sur master
        outb(PIC1_DATA, 0b1111_1100);
        // masque tout sur slave
        outb(PIC2_DATA, 0xFF);
    }
    pub fn eoi(irq: u8) {
        if irq >= 8 { outb(PIC2, 0x20); }
        outb(PIC1, 0x20);
    }
}

////////////////////////////////////////////////////////////////
// PIT — 1 kHz pour un TICKS++
////////////////////////////////////////////////////////////////
mod pit {
    use super::io::*;
    const PIT_CH0:u16=0x40; const PIT_CMD:u16=0x43;
    static mut TICKS: u64 = 0;
    pub fn init_1khz() {
        // PIT freq = 1193182 Hz → compteur = 1193182 / 1000 ≈ 1193
        let div: u16 = 1193;
        outb(PIT_CMD, 0x36); // ch0, lobyte/hibyte, mode3 square
        outb(PIT_CH0, (div & 0xFF) as u8);
        outb(PIT_CH0, (div >> 8) as u8);
    }
    pub fn on_tick() { unsafe { TICKS += 1; } }
    pub fn ticks() -> u64 { unsafe { TICKS } }
}

////////////////////////////////////////////////////////////////
// Clavier PS/2 — IRQ1, simple scancode set 1 -> ASCII minimal
////////////////////////////////////////////////////////////////
mod kbd {
    use super::io::*;
    use super::vga;
    const DATA:u16=0x60; const STAT:u16=0x64;
    pub fn on_irq() {
        let sc = inb(DATA);
        // ultra-minimal: Enter, Backspace, lettres A..Z
        match sc {
            0x1C => vga::write("\n"),
            0x0E => vga::write("\x08"), // (non géré proprement)
            0x02..=0x0A => { let n = (sc - 0x01) + b'0'; vga::putc(n); }
            0x10..=0x19 => { let ch = (sc - 0x10) + b'q'; vga::putc(ch); }
            0x1E..=0x26 => { let ch = (sc - 0x1E) + b'a'; vga::putc(ch); }
            0x2C..=0x32 => { let ch = (sc - 0x2C) + b'z'; vga::putc(ch); }
            _ => {}
        }
    }
}

////////////////////////////////////////////////////////////////
// ISRs en C ABI — trampolines asm fournis par start64.S
////////////////////////////////////////////////////////////////
extern(c) {
    // Ces symboles sont définis en ASM et appellent ces fonctions Vitte.
    fn register_isr_rust(vec: u8, cb: extern(c) fn());
}

// Callbacks appelés par stubs d’ISR
extern(c) fn irq_timer_cb() { pit::on_tick(); super::pic::eoi(0); }
extern(c) fn irq_kbd_cb()   { kbd::on_irq();  super::pic::eoi(1); }
extern(c) fn isr_default_cb() { /* no-op */ }
extern(c) fn isr_gp_cb() { panic("GP Fault"); }
extern(c) fn isr_pf_cb() { panic("Page Fault"); }
extern(c) fn isr_de_cb() { panic("Divide Error"); }

////////////////////////////////////////////////////////////////
// Entrée kernel
////////////////////////////////////////////////////////////////
fn banner() {
    vga::set_color(0x0A, 0x00); // vert sur noir
    vga::write("Vitte/x86_64 kernel — prêt. ⚡\n");
    vga::set_color(0x07, 0x00);
}

fn kinit() {
    vga::clear();
    banner();
    gdt::load();

    // PIC/PIT
    pic::mask_all();
    pic::remap();
    pit::init_1khz();
    pic::unmask_timer_keyboard();

    // IDT
    idt::load();

    vga::write("Interruptions activées (sti). Tape sur le clavier, regarde le timer…\n");
}

fn kloop() -> ! {
    loop {
        // Affiche une barre d’activités toutes les ~100ms
        let t = pit::ticks();
        if (t % 100) == 0 {
            vga::write(".");
        }
        unsafe { asm!("hlt"); } // yield CPU jusqu’à la prochaine IRQ
    }
}

////////////////////////////////////////////////////////////////
// Reset / entry (appelé par start64.S après long mode init)
////////////////////////////////////////////////////////////////
#[no_mangle]
fn kmain() -> int {
    kinit();
    kloop();
}

////////////////////////////////////////////////////////////////
// Panic
////////////////////////////////////////////////////////////////
fn panic(msg: str) -> ! {
    vga::set_color(0x0C, 0x00);
    vga::write("\n[panic] "); vga::write(msg); vga::write("\nSystème figé.\n");
    loop { unsafe { asm!("cli; hlt"); } }
}
