//! wasm-add/main.vitte
//! Module WebAssembly d'addition — ABI stable & no_std par défaut.
//!
//! Cibles supportées :
//! - wasm32-unknown-unknown  → no_std (exports purs, logs via import `console_log`)
//! - wasm32-wasi             → std dispo (println via WASI)
//!
//! Exports principaux :
//!   add_i32(a:i32,b:i32)->i32
//!   add_i64(a:i64,b:i64)->i64
//!   add_f64(a:f64,b:f64)->f64
//!   sum_i32(ptr:u32,len:u32)->i32
//!   sum_f64(ptr:u32,len:u32)->f64
//!   vec_add_i32(a_ptr:u32,b_ptr:u32,out_ptr:u32,len:u32)->i32 (0=OK)
//!   alloc(size:u32,align:u32)->u32
//!   dealloc(ptr:u32,size:u32,align:u32)
//!   get_version(buf_ptr:u32, buf_cap:u32)->u32  // écrit "wasm-add 0.1.0", renvoie la longueur écrite
//!
//! Notes d'hôte (JS):
//!   - Mappez l'import `env.console_log(ptr,len)` pour tracer (optionnel).
//!   - Utilisez `instance.exports.alloc/dealloc` pour I/O de buffers.

#![version("0.1.0")]
#![strict]
#![warn("unsafe_ops","unused","dead_code")]
#![cfg_attr(target="wasm32-unknown-unknown", no_std)]

// ———————————————————————————————————————————————————————————————
// Imports/compatibilité hôte
// ———————————————————————————————————————————————————————————————
#[cfg(target="wasm32-unknown-unknown")]
extern(c) {
    // Import facultatif : côté JS, fournissez:
    // imports = { env: { console_log(ptr,len){ ... } } }
    fn console_log(ptr: u32, len: u32);
}

#[cfg(target="wasm32-wasi")]
use std::io; // autorise println si WASI

// Symboles spéciaux du toolchain WASM (fournis par le linker)
//   __heap_base = début du tas linéaire (juste après .data/.bss)
extern(c) {
    static __heap_base: u32;
    // (selon toolchain, __data_end peut exister; on n'en a pas besoin ici)
}

// ———————————————————————————————————————————————————————————————
// Logger minimal (no_std-friendly)
// ———————————————————————————————————————————————————————————————
mod log {
    #[cfg(target="wasm32-wasi")]
    pub fn info(msg: str) { println("[wasm] {}", msg); }

    #[cfg(target="wasm32-unknown-unknown")]
    pub fn info(msg: str) {
        unsafe {
            let (ptr, len) = super::str_to_tmp_ptr(msg);
            if ptr != 0 { console_log(ptr, len); }
        }
    }

    #[cfg(not(any(target="wasm32-unknown-unknown", target="wasm32-wasi")))]
    pub fn info(msg: str) { eprintln("[wasm(host)] {}", msg); }
}

// ———————————————————————————————————————————————————————————————
// Bump allocator trivial (alloc uniquement; free = no-op)
// ———————————————————————————————————————————————————————————————
mod heap {
    static mut HP: u32 = 0; // curseur heap
    static mut INIT: bool = false;

    #[inline]
    fn align_up(x: u32, a: u32) -> u32 {
        if a <= 1 { return x; }
        let mask = a - 1;
        (x + mask) & !mask
    }

    pub fn init_once() {
        unsafe {
            if !INIT {
                HP = __heap_base;
                INIT = true;
            }
        }
    }

    pub fn alloc(size: u32, align: u32) -> u32 {
        unsafe {
            init_once();
            let cur = align_up(HP, if align == 0 { 8 } else { align });
            let next = cur + size;
            // Pas de memory.grow ici : on suppose la mémoire initiale suffisante (ajoutez grow si besoin)
            HP = next;
            cur
        }
    }

    pub fn dealloc(_ptr: u32, _size: u32, _align: u32) {
        // no-op (bump). À remplacer par un allocateur réel si nécessaire.
    }

    pub fn ptr() -> u32 { unsafe { HP } }
}

// ———————————————————————————————————————————————————————————————
// Aides mémoire (load/store) — attention à l’alignement
// ———————————————————————————————————————————————————————————————
#[inline] unsafe fn as_i32(p: u32) -> *i32 { p as *i32 }
#[inline] unsafe fn as_f64(p: u32) -> *f64 { p as *f64 }

#[inline] unsafe fn load_i32(base: u32, idx: u32) -> i32 {
    *(as_i32(base).add(idx as int))
}
#[inline] unsafe fn store_i32(base: u32, idx: u32, v: i32) {
    *(as_i32(base).add(idx as int)) = v;
}
#[inline] unsafe fn load_f64(base: u32, idx: u32) -> f64 {
    *(as_f64(base).add(idx as int))
}
#[inline] unsafe fn store_f64(base: u32, idx: u32, v: f64) {
    *(as_f64(base).add(idx as int)) = v;
}

// Conversion str → buffer temporaire dans le heap (log/exports)
// (UTF-8, copie immuable; renvoie (ptr,len) ou (0,0) si erreur)
unsafe fn str_to_tmp_ptr(s: str) -> (u32, u32) {
    let bytes = s.as_bytes();
    let len = bytes.len() as u32;
    let ptr = heap::alloc(len, 1);
    if ptr == 0 { return (0,0); }
    let mut i = 0;
    while i < len {
        *((ptr as *u8).add(i as int)) = bytes[i as usize];
        i += 1;
    }
    (ptr, len)
}

// ———————————————————————————————————————————————————————————————
// Exports math simples (scalaires)
// ———————————————————————————————————————————————————————————————
#[export("add_i32")]
fn add_i32(a: i32, b: i32) -> i32 { a + b }

#[export("add_i64")]
fn add_i64(a: i64, b: i64) -> i64 { a + b }

#[export("add_f64")]
fn add_f64(a: f64, b: f64) -> f64 { a + b }

// ———————————————————————————————————————————————————————————————
// Exports tableaux : somme & addition vectorielle
// ———————————————————————————————————————————————————————————————
#[export("sum_i32")]
fn sum_i32(ptr: u32, len: u32) -> i32 {
    let mut acc: i32 = 0;
    unsafe {
        let mut i: u32 = 0;
        while i < len {
            acc = acc + load_i32(ptr, i);
            i += 1;
        }
    }
    acc
}

#[export("sum_f64")]
fn sum_f64(ptr: u32, len: u32) -> f64 {
    let mut acc: f64 = 0.0;
    unsafe {
        let mut i: u32 = 0;
        while i < len {
            acc = acc + load_f64(ptr, i);
            i += 1;
        }
    }
    acc
}

// out[k] = a[k] + b[k], pour k in [0..len)
// Retourne 0 si OK, -1 si paramètre invalide (ex: len trop grand qui overflow l’addr)
#[export("vec_add_i32")]
fn vec_add_i32(a_ptr: u32, b_ptr: u32, out_ptr: u32, len: u32) -> i32 {
    // micro-sanity: évite overflow u32 → index * 4
    if len > (0xFFFF_FFFFu32 / 4) { return -1; }
    unsafe {
        let mut i: u32 = 0;
        while i < len {
            let a = load_i32(a_ptr, i);
            let b = load_i32(b_ptr, i);
            store_i32(out_ptr, i, a + b);
            i += 1;
        }
    }
    0
}

// ———————————————————————————————————————————————————————————————
/* Allocateur exporté pour l’hôte (JS/Go/Rust…) */
// ———————————————————————————————————————————————————————————————
#[export("alloc")]
fn wasm_alloc(size: u32, align: u32) -> u32 {
    heap::alloc(size, if align == 0 { 8 } else { align })
}

#[export("dealloc")]
fn wasm_dealloc(ptr: u32, size: u32, align: u32) {
    heap::dealloc(ptr, size, align)
}

// Version : écrit la chaîne dans buf[0..cap], renvoie la longueur écrite.
#[export("get_version")]
fn get_version(buf_ptr: u32, buf_cap: u32) -> u32 {
    let s = "wasm-add 0.1.0";
    let bytes = s.as_bytes();
    let want = bytes.len() as u32;
    let n = if want > buf_cap { buf_cap } else { want };
    unsafe {
        let mut i: u32 = 0;
        while i < n {
            *((buf_ptr as *u8).add(i as int)) = bytes[i as usize];
            i += 1;
        }
    }
    n
}

// ———————————————————————————————————————————————————————————————
// Optionnel : point d’entrée de confort (appelable depuis l’hôte)
// Initialise le heap et logge un petit “hello” (no-op si console_log absent).
// ———————————————————————————————————————————————————————————————
#[export("init")]
fn init() {
    heap::init_once();
    log::info("wasm-add: init()");
}

// ———————————————————————————————————————————————————————————————
// Panic handler — évite un trap muet; trace & boucle.
// ———————————————————————————————————————————————————————————————
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    // Compose un message court (selon ce que Vitte fournit en no_std)
    let msg = "panic in wasm-add";
    log::info(msg);
    loop { /* trap-friendly spin */ }
}
