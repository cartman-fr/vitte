//! main.vitte — serveur HTTP “echo” avec middlewares
//! Routes :
//!   GET  /health         → 200 "ok"
//!   GET  /time           → JSON { now, tz }
//!   ANY  /headers        → JSON (headers reçus)
//!   POST /echo           → echo JSON/texte/binaire (mimetype reflété)
//!   GET  /               → mini-page d’info
//!
//! Env : PORT (par défaut 8080)

#![version("0.1.0")]
#![strict]

use std::net::{TcpListener, TcpStream};
use std::io::{read_exact, read_to_end, write_all};
use std::time::{now};
use std::str::from_utf8;

mod middleware; // ← importe middleware.vitt
use middleware::{Request, Response, Chain, Logger, RequestId, Cors, LimitBody, Timing, Next};

/* ———— HTTP parsing minimal (ultra simple) ———— */
fn parse_request(mut stream: &TcpStream, peer: str) -> Option<Request> {
    // Lire jusqu’à double CRLF pour l’en-tête
    let mut buf = Vec<u8>::new();
    if let Err(_) = std::io::read_until_double_crlf(stream, &mut buf) {
        return None;
    }
    let head = match from_utf8(&buf) { Ok(s)=>s, Err(_)=>return None };
    let mut lines = head.split("\r\n");
    let start = lines.next().unwrap_or("");
    let mut parts = start.split_whitespace();
    let method = parts.next().unwrap_or("GET").to_string();
    let target = parts.next().unwrap_or("/").to_string();

    // path + query
    let (path, query_map) = split_query(&target);

    // headers
    let mut headers = std::collections::Map::<str,str>::new();
    for l in lines {
        if l.is_empty() { break; }
        if let Some(ix) = l.find(':') {
            let k = l[..ix].trim().to_lower();
            let v = l[ix+1..].trim().to_string();
            headers.insert(k.to_string(), v);
        }
    }

    // body (Content-Length only, pas de chunked pour cet exemple)
    let mut body = Vec::<u8>::new();
    if let Some(cl) = headers.get("content-length") {
        if let Ok(n) = cl.parse::<usize>() {
            body.resize(n, 0);
            if let Err(_) = read_exact(stream, &mut body) { return None; }
        }
    }

    Some(Request{
        method, path, query: query_map, headers, body, peer_addr: peer, ctx: std::collections::Map::new()
    })
}

fn split_query(target: &str) -> (str, std::collections::Map<str,str>) {
    let mut map = std::collections::Map::<str,str>::new();
    if let Some(ix) = target.find('?') {
        let p = target[..ix].to_string();
        let q = &target[ix+1..];
        for kv in q.split('&') {
            if kv.is_empty() { continue; }
            if let Some(eq) = kv.find('=') {
                let k = url_decode(&kv[..eq]);
                let v = url_decode(&kv[eq+1..]);
                map.insert(k, v);
            } else {
                map.insert(url_decode(kv), "".into());
            }
        }
        return (p, map);
    }
    (target.to_string(), map)
}

fn url_decode(s: &str) -> str {
    std::url::decode(s).unwrap_or(s.to_string())
}

/* ———— Écriture réponse ———— */
fn write_response(mut stream:&TcpStream, res: Response) {
    let status_line = match res.status {
        200 => "HTTP/1.1 200 OK",
        201 => "HTTP/1.1 201 Created",
        204 => "HTTP/1.1 204 No Content",
        400 => "HTTP/1.1 400 Bad Request",
        404 => "HTTP/1.1 404 Not Found",
        413 => "HTTP/1.1 413 Payload Too Large",
        415 => "HTTP/1.1 415 Unsupported Media Type",
        _   => "HTTP/1.1 500 Internal Server Error",
    };
    let mut head = String::new();
    head.push_str(status_line); head.push_str("\r\n");

    // default headers
    let mut headers = res.headers;
    headers.insert("date".into(), std::http::date::now_gmt());
    headers.insert("connection".into(), "close".into());
    headers.insert("content-length".into(), format!("{}", res.body.len()));

    for (k,v) in headers.iter() {
        head.push_str(k); head.push_str(": "); head.push_str(v); head.push_str("\r\n");
    }
    head.push_str("\r\n");

    let _ = write_all(stream, head.as_bytes());
    let _ = write_all(stream, &res.body);
}

/* ———— Routes ———— */
fn router(req: Request) -> Response {
    match (req.method.as_str(), req.path.as_str()) {
        ("GET", "/") => index(req),
        ("GET", "/health") => Response::new(200).text("ok"),
        ("GET", "/time") => time_json(req),
        (_, "/headers") => headers_json(req),
        ("POST", "/echo") => echo_body(req),
        _ => Response::new(404).text("not found"),
    }
}

fn index(_req: Request) -> Response {
    Response::new(200).text(
        "Vitte Web Echo\n\
         Routes:\n\
         - GET  /health\n\
         - GET  /time\n\
         - ANY  /headers\n\
         - POST /echo\n"
    )
}

fn time_json(_req: Request) -> Response {
    let now_iso = now().to_rfc3339();
    let tz = std::time::local_tz();
    let body = format!(r#"{{"now":"{}","tz":"{}"}}"#, now_iso, tz);
    Response::new(200).json(body)
}

fn headers_json(req: Request) -> Response {
    // Dump headers et query
    let mut obj = String::from("{");
    obj.push_str(r#""headers":{"#);
    let mut first = true;
    for (k,v) in req.headers.iter() {
        if !first { obj.push(','); }
        obj.push('"'); obj.push_str(escape_json(k)); obj.push_str("\":\"");
        obj.push_str(escape_json(v)); obj.push('"');
        first = false;
    }
    obj.push_str("},\"query\":{");
    first = true;
    for (k,v) in req.query.iter() {
        if !first { obj.push(','); }
        obj.push('"'); obj.push_str(escape_json(k)); obj.push_str("\":\"");
        obj.push_str(escape_json(v)); obj.push('"');
        first = false;
    }
    obj.push_str("}}");
    Response::new(200).json(obj)
}

fn echo_body(req: Request) -> Response {
    // Refléter Content-Type si présent, sinon octet-stream
    let ct = req.headers.get("content-type").unwrap_or("application/octet-stream");
    let mut res = Response::new(200);
    res.headers.insert("content-type".into(), ct);
    res.body = req.body;
    res
}

/* ———— Utils JSON ———— */
fn escape_json(s:&str) -> &str { std::json::escape(s) }

/* ———— Serveur ———— */
fn handle_client(stream: &TcpStream, app: Next) {
    let peer = stream.peer_addr_string().unwrap_or("-");
    if let Some(req) = parse_request(stream, peer) {
        let res = app(req);
        write_response(stream, res);
    } else {
        let res = Response::new(400).text("bad request");
        write_response(stream, res);
    }
}

fn main(_args:[str]) -> int {
    let port = std::env::get("PORT").unwrap_or("8080");
    let addr = format!("0.0.0.0:{}", port);
    let listener = match TcpListener::bind(addr.clone()) {
        Ok(l) => l,
        Err(e) => { eprintln!("bind {}: {}", addr, e); return 2; }
    };

    eprintln!("listening on http://{}/  (Ctrl+C pour quitter)", addr);

    // Pipeline middlewares
    let chain = Chain::new()
        .use(RequestId)
        .use(Logger)
        .use(Timing)
        .use(Cors::permissive())
        .use(LimitBody{ max_bytes: 1 * 1024 * 1024 }); // 1 MiB

    let app = chain.compose(router);

    // Boucle d’acceptation (mono-thread pour l’exemple)
    loop {
        match listener.accept() {
            Ok((stream, _addr)) => {
                handle_client(&stream, app);
                // connexion close (HTTP/1.1 simple)
            }
            Err(e) => {
                eprintln!("accept: {}", e);
            }
        }
    }
}
