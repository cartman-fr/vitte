//! middleware.vitt — pipeline HTTP minimal pour Vitte
//! Fournit : types Request/Response/Next, interface Middleware,
//! middlewares prêts à l’emploi : Logger, RequestId, Cors, LimitBody, Timing.

#![version("0.1.0")]
#![strict]

/* ———— Types de base ———— */
pub struct Request {
    pub method: str,
    pub path: str,
    pub query: std::collections::Map<str, str>,
    pub headers: std::collections::Map<str, str>,
    pub body: Vec<u8>,
    pub ctx: std::collections::Map<str, std::any::Any>, // sac de contexte
    pub peer_addr: str,
}

pub struct Response {
    pub status: int,
    pub headers: std::collections::Map<str, str>,
    pub body: Vec<u8>,
}

impl Response {
    pub fn new(status:int) -> Self {
        let mut h = std::collections::Map<str,str>::new();
        h.insert("server".into(), "vitte-web-echo/0.1".into());
        Self{ status, headers: h, body: Vec<u8>::new() }
    }
    pub fn json(mut self, s: str) -> Self {
        self.headers.insert("content-type".into(), "application/json; charset=utf-8".into());
        self.body = s.as_bytes().to_vec(); self
    }
    pub fn text(mut self, s: str) -> Self {
        self.headers.insert("content-type".into(), "text/plain; charset=utf-8".into());
        self.body = s.as_bytes().to_vec(); self
    }
}

/* ———— Contrat middleware ———— */
pub type Next = fn(req: Request) -> Response;

pub trait Middleware {
    fn handle(&self, req: Request, next: Next) -> Response;
}

/* ———— Pipeline ———— */
pub struct Chain {
    stack: Vec<Box<dyn Middleware>>,
}

impl Chain {
    pub fn new() -> Self { Self{ stack: Vec::new() } }
    pub fn use<M: Middleware + 'static>(mut self, m: M) -> Self {
        self.stack.push(Box::new(m)); self
    }
    pub fn compose(self, terminal: Next) -> Next {
        // on réduit de droite à gauche : next = m.handle(req, next)
        let mut next = terminal;
        let mut i = self.stack.len();
        while i > 0 {
            let m = self.stack[i-1].as_ref();
            let prev = next;
            next = move |req: Request| {
                m.handle(req, prev)
            };
            i -= 1;
        }
        next
    }
}

/* ———— Middlewares fournis ———— */
pub struct Logger;

impl Middleware for Logger {
    fn handle(&self, req: Request, next: Next) -> Response {
        let t0 = std::time::now();
        let method = req.method.clone();
        let path = req.path.clone();
        let peer = req.peer_addr.clone();
        let res = next(req);
        let dt = (std::time::now() - t0).as_millis();
        eprintln("[web] {} {} ←{} → {} ({} ms)", method, path, peer, res.status, dt);
        res
    }
}

pub struct RequestId;
impl Middleware for RequestId {
    fn handle(&self, mut req: Request, next: Next) -> Response {
        let rid = std::uuid::v4();
        req.headers.insert("x-request-id".into(), rid.clone());
        req.ctx.insert("request_id".into(), std::any::Any::from(rid.clone()));
        let mut res = next(req);
        res.headers.insert("x-request-id".into(), rid);
        res
    }
}

pub struct Cors {
    pub allow_origin: str,
    pub allow_headers: str,
    pub allow_methods: str,
}
impl Cors {
    pub fn permissive() -> Self {
        Self{
            allow_origin: "*".into(),
            allow_headers: "*,content-type".into(),
            allow_methods: "GET,POST,OPTIONS".into(),
        }
    }
}
impl Middleware for Cors {
    fn handle(&self, req: Request, next: Next) -> Response {
        if req.method == "OPTIONS" {
            let mut res = Response::new(204);
            res.headers.insert("access-control-allow-origin".into(), self.allow_origin.clone());
            res.headers.insert("access-control-allow-headers".into(), self.allow_headers.clone());
            res.headers.insert("access-control-allow-methods".into(), self.allow_methods.clone());
            return res;
        }
        let mut res = next(req);
        res.headers.insert("access-control-allow-origin".into(), self.allow_origin.clone());
        res.headers.insert("vary".into(), "origin".into());
        res
    }
}

pub struct LimitBody { pub max_bytes: usize }
impl Middleware for LimitBody {
    fn handle(&self, mut req: Request, next: Next) -> Response {
        if req.body.len() > self.max_bytes {
            return Response::new(413).text("Payload Too Large");
        }
        next(req)
    }
}

pub struct Timing;
impl Middleware for Timing {
    fn handle(&self, req: Request, next: Next) -> Response {
        let t0 = std::time::now();
        let mut res = next(req);
        let dt = (std::time::now() - t0).as_millis();
        res.headers.insert("server-timing".into(), format!("app;dur={}", dt));
        res
    }
}
