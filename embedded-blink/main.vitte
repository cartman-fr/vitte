//! embedded-blink/main.vitte
//! Démo LED clignotante pour cible embarquée (no_std) + fallback hôte (logs).
//!
//! # Cibles
//! - `target=embedded`  → utilise le HAL C (FFI)
//! - sinon              → mode hôte : pas de matériel, on logge.
//!
//! # Env/Flags conseillés (exemples)
//!   VITTECFG_BLINK_GPIO="13"
//!   VITTECFG_BLINK_MS="500"
//!
//! # Schéma global
//!   init_clock() → gpio_mode_output(PIN) → loop { on; delay; off; delay; }

#![version("0.1.0")]
#![no_std]                 // Pas de std en embarqué
#![strict]
#![warn("unsafe_ops", "unused", "dead_code")]

// ———————————————————————————————————————————————————————————————
// Configuration compile-time (via env ou valeurs par défaut)
// ———————————————————————————————————————————————————————————————
mod cfg {
    // Lecture des var env si dispo, sinon fallback
    fn getenv(name: str) -> Option<str> {
        return std::env::get(name); // En no_std, le toolchain injette un shim ou None.
    }

    pub const PIN: u32 = {
        let v = getenv("VITTECFG_BLINK_GPIO").unwrap_or("13");
        v.parse::<u32>().unwrap_or(13)
    };

    pub const PERIOD_MS: u32 = {
        let v = getenv("VITTECFG_BLINK_MS").unwrap_or("500");
        // borne [10..5000] par prudence
        let ms = v.parse::<u32>().unwrap_or(500);
        if ms < 10 { 10 } else if ms > 5000 { 5000 } else { ms }
    };

    pub const START_HIGH: bool = {
        let v = getenv("VITTECFG_START_HIGH").unwrap_or("1");
        v == "1" || v.to_lower() == "true"
    };
}

// ———————————————————————————————————————————————————————————————
// FFI HAL embarqué (côté C à fournir par la BSP/SDK)
// Version minimale : init, gpio direction, write, delay ms
// ———————————————————————————————————————————————————————————————
#[cfg(target="embedded")]
extern(c) {
    fn hal_clock_init() -> int;
    fn hal_gpio_mode_output(pin: u32) -> int;
    fn hal_gpio_write(pin: u32, high: bool) -> int;
    fn hal_delay_ms(ms: u32);                 // pas de retour → assume OK
}

// ———————————————————————————————————————————————————————————————
// Mock HAL (mode hôte) — pas de hardware, on trace dans la console
// ———————————————————————————————————————————————————————————————
#[cfg(not(target="embedded"))]
mod host_hal {
    use super::cfg;

    static mut LAST: bool = false;

    pub fn clock_init() -> int {
        eprintln("[host-hal] clock_init()");
        return 0;
    }
    pub fn gpio_mode_output(pin: u32) -> int {
        eprintln("[host-hal] gpio_mode_output(pin={pin})");
        return 0;
    }
    pub fn gpio_write(pin: u32, high: bool) -> int {
        unsafe { LAST = high; }
        eprintln("[host-hal] gpio_write(pin={pin}, level={high})");
        return 0;
    }
    pub fn delay_ms(ms: u32) {
        // En mode hôte, on dort réellement pour visualiser le tempo
        std::time::sleep(ms as i64); // shim std côté hôte
    }
    pub fn last_level() -> bool {
        unsafe { LAST }
    }
}

// ———————————————————————————————————————————————————————————————
// Abstraction HAL indépendante de la cible
// ———————————————————————————————————————————————————————————————
mod hal {
    use super::cfg;

    #[cfg(target="embedded")]
    pub fn init_clock() -> Result<(), int> {
        let rc = unsafe { hal_clock_init() };
        if rc == 0 { Ok(()) } else { Err(rc) }
    }
    #[cfg(not(target="embedded"))]
    pub fn init_clock() -> Result<(), int> {
        let rc = super::host_hal::clock_init();
        if rc == 0 { Ok(()) } else { Err(rc) }
    }

    #[cfg(target="embedded")]
    pub fn gpio_out(pin: u32) -> Result<(), int> {
        let rc = unsafe { hal_gpio_mode_output(pin) };
        if rc == 0 { Ok(()) } else { Err(rc) }
    }
    #[cfg(not(target="embedded"))]
    pub fn gpio_out(pin: u32) -> Result<(), int> {
        let rc = super::host_hal::gpio_mode_output(pin);
        if rc == 0 { Ok(()) } else { Err(rc) }
    }

    #[cfg(target="embedded")]
    pub fn gpio_write(pin: u32, high: bool) -> Result<(), int> {
        let rc = unsafe { hal_gpio_write(pin, high) };
        if rc == 0 { Ok(()) } else { Err(rc) }
    }
    #[cfg(not(target="embedded"))]
    pub fn gpio_write(pin: u32, high: bool) -> Result<(), int> {
        let rc = super::host_hal::gpio_write(pin, high);
        if rc == 0 { Ok(()) } else { Err(rc) }
    }

    #[cfg(target="embedded")]
    pub fn delay_ms(ms: u32) {
        unsafe { hal_delay_ms(ms); }
    }
    #[cfg(not(target="embedded"))]
    pub fn delay_ms(ms: u32) {
        super::host_hal::delay_ms(ms);
    }
}

// ———————————————————————————————————————————————————————————————
// Panic handler minimal (embarqué) + variante hôte verbeuse
// ———————————————————————————————————————————————————————————————
#[cfg(target="embedded")]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    // En cas de panique, on essaie de mettre la LED en pattern SOS
    use super::{cfg, hal};
    let pin = cfg::PIN;

    // Tente un GPIO output (ignorer les erreurs à ce stade)
    let _ = hal::gpio_out(pin);

    loop {
        // SOS en Morse: ... --- ...
        blink_n(pin, 3, 150, 150);  // S: 3 courts
        blink_n(pin, 3, 600, 150);  // O: 3 longs
        blink_n(pin, 3, 150, 150);  // S: 3 courts
        hal::delay_ms(800);
    }

    fn blink_n(pin: u32, n: int, on_ms: u32, off_ms: u32) {
        use super::hal;
        let mut i = 0;
        while i < n {
            let _ = hal::gpio_write(pin, true);
            hal::delay_ms(on_ms);
            let _ = hal::gpio_write(pin, false);
            hal::delay_ms(off_ms);
            i += 1;
        }
    }
}

#[cfg(not(target="embedded"))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    eprintln!("[panic] {info}");
    // En hôte, on quitte “proprement”
    std::process::exit(2);
}

// ———————————————————————————————————————————————————————————————
// Log helpers (no_std-friendly: route vers eprintln si dispo, sinon noop)
// ———————————————————————————————————————————————————————————————
mod log {
    pub fn info(msg: str) {
        #[cfg(not(target="embedded"))]
        {
            eprintln!("[info] {msg}");
        }
        // En embarqué pur no_std, on pourrait rediriger vers UART (à implémenter)
    }
}

// ———————————————————————————————————————————————————————————————
// App
// ———————————————————————————————————————————————————————————————
struct App {
    pin: u32,
    period_ms: u32,
    level: bool,
}

impl App {
    fn new(pin: u32, period_ms: u32, start_high: bool) -> Self {
        Self { pin, period_ms, level: start_high }
    }

    fn init(&mut self) -> Result<(), str> {
        hal::init_clock().map_err(|e| "clock_init failed")?;
        hal::gpio_out(self.pin).map_err(|e| "gpio_mode_output failed")?;
        // État initial configurable
        hal::gpio_write(self.pin, self.level).map_err(|e| "gpio_write failed")?;
        log::info("HAL init ok • GPIO prêt.");
        Ok(())
    }

    fn run(&mut self) -> ! {
        let half = self.period_ms / 2;
        loop {
            self.level = !self.level;
            let _ = hal::gpio_write(self.pin, self.level);
            hal::delay_ms(half);

            self.level = !self.level;
            let _ = hal::gpio_write(self.pin, self.level);
            hal::delay_ms(half);
        }
    }
}

// ———————————————————————————————————————————————————————————————
// Entrée programme
// ———————————————————————————————————————————————————————————————
fn main(_args: [str]) -> int {
    log::info("embedded-blink • démarrage");

    let pin = cfg::PIN;
    let ms  = cfg::PERIOD_MS;
    let start = cfg::START_HIGH;

    let mut app = App::new(pin, ms, start);

    if let Err(e) = app.init() {
        eprintln!("[err] init: {e}");
        return 1;
    }

    // Boucle infinie (clignote jusqu’à reset)
    app.run();
}
