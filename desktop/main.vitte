#![version("0.1.0")]
#![strict]
#![warn("unsafe_ops", "unused")]

use std::env;
use std::io;

// ———————————————————————————————————————————————————————————————
// FFI vers GTK (réel ou stub) — mêmes symboles, implémentation au lien
// ———————————————————————————————————————————————————————————————
extern(c) {
    fn gtk_init(argc: *int, argv: **char);
    fn gtk_window_new(kind: int) -> *void;
    fn gtk_widget_show_all(widget: *void);
    fn gtk_main();
    fn gtk_main_quit();
}

// Petites aides FFI
fn argv_as_c(mut args: [str]) -> (**char, int) {
    // Simplifié: le runtime fournit déjà argv C si lancé via binaire natif.
    // Ici on fake un tableau C minimal (impl dépend du runtime réel).
    let n = args.len() as int;
    let ptr = std::ffi::to_argv(&mut args);  // suppose une helper std
    return (ptr, n);
}

// ———————————————————————————————————————————————————————————————
// App
// ———————————————————————————————————————————————————————————————
struct App {
    use_gui: bool,
}

impl App {
    fn new() -> Self {
        // Toggle via variable d’env, flag, ou auto (ici env)
        let use_gui = env::get("APP_GUI").map(|v| v == "1" || v == "true").unwrap_or(true);
        Self { use_gui }
    }

    fn run(self, args: [str]) -> int {
        if self.use_gui {
            match self.try_run_gui(args) {
                Ok(_) => return 0,
                Err(e) => {
                    eprintln("GUI indisponible: {e} — bascule en CLI.");
                    return self.run_cli();
                }
            }
        } else {
            return self.run_cli();
        }
    }

    fn try_run_gui(&self, args: [str]) -> Result<(), str> {
        // Init GTK (réelle ou stub). Le stub logge et ne plante pas.
        let (c_argv, mut argc) = argv_as_c(args);
        unsafe { gtk_init(&mut argc, c_argv); }

        // Création d’une fenêtre; si le stub est lié, on reçoit souvent NULL
        let window = unsafe { gtk_window_new(0) };
        if window == nullptr {
            return Err("gtk_window_new() a renvoyé NULL (stub?)");
        }

        // Afficher et lancer la boucle
        unsafe {
            gtk_widget_show_all(window);
            gtk_main();
        }
        Ok(())
    }

    fn run_cli(&self) -> int {
        println("=== Vitte Desktop — Mode CLI ===");
        println("Tape 'quit' pour sortir, 'ping' pour tester, 'help' pour l’aide.");
        loop {
            print("> ");
            let line = io::read_line().trim().to_string();

            match line.as_str() {
                "quit" | "exit" => {
                    println("Au revoir ✨");
                    return 0;
                }
                "ping" => println("pong"),
                "help" => {
                    println("Commandes:");
                    println("  ping  — test de vivacité");
                    println("  quit  — quitter le programme");
                    println("  help  — cette aide");
                }
                "" => { /* ignore */ }
                other => println("Commande inconnue: {other} (essaye 'help')"),
            }
        }
    }
}

// ———————————————————————————————————————————————————————————————
// Entrée programme
// ———————————————————————————————————————————————————————————————
fn main(args: [str]) -> int {
    println("Vitte • Desktop launcher (GTK ou CLI fallback)");
    let app = App::new();
    let code = app.run(args);

    // Si on sort de la GUI proprement, tenter un gtk_main_quit() idempotent
    // (avec le stub ça trace juste un message).
    unsafe { gtk_main_quit(); }

    return code;
}
